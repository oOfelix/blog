<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JAVA并发</title>
    <link href="/2022/04/18/JAVA%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/04/18/JAVA%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h1><p>本博客内容来自<a href="https://www.bilibili.com/video/av81461839?from=search&seid=8445102345230304010"><strong>黑马java并发编程教程</strong></a></p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享<ul><li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h4 id="进程和线程的切换"><a href="#进程和线程的切换" class="headerlink" title="进程和线程的切换"></a>进程和线程的切换</h4><p><strong>上下文切换</strong></p><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li></ul><p><strong>进程切换和线程切换的主要区别</strong></p><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p><p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p><p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p><p><strong>为什么TLB能加快访问速度</strong></p><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p><h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p>并发是一个CPU在不同的时间去不同线程中执行指令。</p><p>并行是多个CPU同时处理不同的线程。</p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力</li><li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li></ul><h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><ol><li>设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</li><li>结论</li></ol><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li><li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><p>结论</p><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承Thread创建线程"><a href="#方法一：通过继承Thread创建线程" class="headerlink" title="方法一：通过继承Thread创建线程"></a>方法一：通过继承Thread创建线程</h3><figure class="highlight scala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread</span> </span>&#123;<br>public static void main(<span class="hljs-type">String</span>[] args) &#123;<br><span class="hljs-type">Thread</span> myThread = <span class="hljs-keyword">new</span> <span class="hljs-type">MyThread</span>();<br>        <span class="hljs-comment">// 启动线程</span><br>myThread.start();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br>public void run() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;my thread running...&quot;</span>);<br>&#125;<br>&#125;<span class="hljs-type">Copy</span><br></code></pre></td></tr></table></figure><p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p><h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><span class="hljs-comment">//创建线程任务</span><br><span class="hljs-title class_">Runnable</span> r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Runnable running&quot;</span>);<br>&#125;<br>&#125;;<br><span class="hljs-comment">//将Runnable对象传给Thread</span><br><span class="hljs-title class_">Thread</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br><span class="hljs-comment">//启动线程</span><br>t.<span class="hljs-title function_">start</span>();<br>&#125;<br>&#125;<span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateThread2</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;my runnable running...&quot;</span>);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>      <span class="hljs-title class_">MyRunnable</span> myRunnable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>      <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>      thread.<span class="hljs-title function_">start</span>();<br>   &#125;<br>&#125;<span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p><h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p><p>所以方法二中的代码可以被简化为</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-comment">//创建线程任务</span><br>Runnable r = () -&gt; &#123;<br>            <span class="hljs-comment">//直接写方法体即可</span><br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Hello Thread&quot;</span>);<br>&#125;;<br><span class="hljs-comment">//将Runnable对象传给Thread</span><br>Thread t = <span class="hljs-keyword">new</span> Thread(r);<br><span class="hljs-comment">//启动线程</span><br>t.start();<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>可以再Runnable上使用Alt+Enter</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144534.png" alt="img"></a></p><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test3 &#123;<br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws ExecutionException, InterruptedException &#123;<br>        //需要传入一个Callable对象<br>FutureTask&lt;<span class="hljs-type">Integer</span>&gt; task = <span class="hljs-built_in">new</span> FutureTask&lt;<span class="hljs-type">Integer</span>&gt;(<span class="hljs-built_in">new</span> Callable&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">Integer</span> <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;线程执行!&quot;);<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br>&#125;);<br><br>Thread r1 = <span class="hljs-built_in">new</span> Thread(task, &quot;t2&quot;);<br>r1.<span class="hljs-keyword">start</span>();<br>//获取线程中方法执行后的返回结果<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(task.<span class="hljs-keyword">get</span>());<br>&#125;<br>&#125;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseFutureTask</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) throws ExecutionException, InterruptedException &#123;<br>      FutureTask&lt;<span class="hljs-keyword">String</span>&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-type">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">MyCall</span>());<br>      Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(futureTask);<br>      thread.start();<br>      <span class="hljs-comment">// 获得线程运行后的返回值</span><br>      System.out.println(futureTask.<span class="hljs-keyword">get</span>());<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCall</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Callable</span></span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>   @Override<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> call() throws Exception &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>   &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p><h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol><li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.<span class="hljs-keyword">sleep</span>(1);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.<span class="hljs-keyword">sleep</span>(1);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-regexp">//</span>设置为优先级最高Copy<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>();<br><span class="hljs-comment">//等待thread线程执行结束</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>();<br><span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>(<span class="hljs-number">1000</span>);Copy<br></code></pre></td></tr></table></figure><h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。</li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>用于查看打断标记，返回值被boolean类型<br>t1.isInterrupted();Copy<br></code></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>) &#123;<br>        break;<br>    &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144553.png" alt="img"></a></p><p><strong>代码</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>monitor.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>monitor.stop();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;<br><br>Thread monitor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span> &#123;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br><span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br><span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span>()</span> &#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.interrupt();<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul><li>stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）&#x2F;resume（恢复线程）方法</li></ul><h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//将线程设置为守护线程, 默认为<span class="hljs-literal">false</span><br><span class="hljs-literal">monitor</span>.setDaemon(<span class="hljs-literal">true</span>);Copy<br></code></pre></td></tr></table></figure><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144606.png" alt="img"></a></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144621.png" alt="img"></a></p><ul><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>() </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br>&#123;   <br>    counter++; <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span>() </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br>&#123; <br>    counter--; <br>&#125;Copy<br></code></pre></td></tr></table></figure><h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(对象)</span></span> &#123;<br><span class="hljs-comment">//临界区</span><br>&#125;Copy<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br><span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;    <br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;            <br>        <span class="hljs-keyword">synchronized</span> (room) &#123;     <br>        counter++;            <br>        &#125;       <br>    &#125;    <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;       <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;         <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;            <br>            counter--;          <br>            &#125;    <br>        &#125; <br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br> <br>    t1.start();    <br>    t2.start(); <br>    t1.join();   <br>    t2.join();    <br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter); <br>&#125;Copy<br></code></pre></td></tr></table></figure><h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul><li><p>加在成员方法上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-comment">//在方法上加上synchronized关键字</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;<br><br>&#125;<br>&#125;<br>&#125;<span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure></li><li><p>加在静态方法上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params">Demo.<span class="hljs-keyword">class</span></span>) &#123;<br><br>&#125;<br>&#125;<br>&#125;<span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul><li><p>局部变量是线程安全的</p></li><li><p>但局部变量引用的对象则未必 （要看该对象</p><p>是否被共享</p><p>且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li><li><p>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144636.png" alt="img"></a></p><ul><li>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144649.png" alt="img"></a></p><ul><li>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144702.png" alt="img"></a></p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer</li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li>它们的每个方法是原子的（都被加上了synchronized）</li><li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144903.png" alt="img"></a></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h2 id="4、Monitor概念"><a href="#4、Monitor概念" class="headerlink" title="4、Monitor概念"></a>4、Monitor概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144917.png" alt="img"></a></p><ul><li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p><ul><li><p>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</p></li><li><p>如果</p><p>已经绑定</p><p>，则会去查询该Monitor是否已经有了Owner</p><ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p></li><li><p><strong>注意</strong>：</p><ul><li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li><li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li></ul></li></ul><h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144926.png" alt="img"></a></p><h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><ul><li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144942.png" alt="img"></a></p></li><li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144950.png" alt="img"></a></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608144957.png" alt="img"></a></p><h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145004.png" alt="img"></a></p><ul><li><p>此时便会给对象加上重量级锁（使用Monitor）</p><ul><li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p></li><li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145148.png" alt="img"></a></p></li></ul></li></ul><h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p><ul><li>第一种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145136.png" alt="img"></a></p><ul><li>第二种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145125.png" alt="img"></a></p><h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145109.png" alt="img"></a></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145101.png" alt="img"></a></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li></ul><h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait&#x2F;notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h2 id="6、Wait-x2F-Notify"><a href="#6、Wait-x2F-Notify" class="headerlink" title="6、Wait&#x2F;Notify"></a>6、Wait&#x2F;Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145204.png" alt="img"></a></p><ul><li><p>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</p></li><li><p>处于BLOCKED和WAITING状态的线程都为</p><p>阻塞</p><p>状态，CPU都不会分给他们时间片。但是有所区别：</p><ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify&#x2F;obj.notifyAll)，才会被唤醒。</p></li></ul><p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">LOCK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span><br><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>LOCK.wait();<br>&#125;<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</li><li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h3 id="3-优雅地使用wait-x2F-notify"><a href="#3-优雅地使用wait-x2F-notify" class="headerlink" title="(3)优雅地使用wait&#x2F;notify"></a>(3)优雅地使用wait&#x2F;notify</h3><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait&#x2F;notify需要注意什么</strong></p><ul><li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法</li></ul><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cos">synchronized (<span class="hljs-keyword">LOCK</span>) &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span><br><span class="hljs-keyword">LOCK</span>.wait()<span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-comment">//满足条件后再运行</span><br>&#125;<br><br>synchronized (<span class="hljs-keyword">LOCK</span>) &#123;<br><span class="hljs-comment">//唤醒所有等待线程</span><br><span class="hljs-keyword">LOCK</span>.notifyAll()<span class="hljs-comment">;</span><br>&#125;Copy<br></code></pre></td></tr></table></figure><h2 id="7、模式之保护性暂停"><a href="#7、模式之保护性暂停" class="headerlink" title="7、模式之保护性暂停"></a>7、模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145223.png" alt="img"></a></p><h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br><span class="hljs-built_in">String</span> hello = <span class="hljs-string">&quot;hello thread!&quot;</span>;<br>Guarded guarded = <span class="hljs-keyword">new</span> Guarded();<br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(<span class="hljs-string">&quot;想要得到结果&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (guarded) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(<span class="hljs-string">&quot;结果是：&quot;</span>+guarded.getResponse());</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(<span class="hljs-string">&quot;得到结果&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(<span class="hljs-string">&quot;设置结果&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (guarded) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">guarded.setResponse(hello);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Guarded</span> &#123;</span><br><span class="hljs-function">/**</span><br><span class="hljs-function"> * 要返回的结果</span><br><span class="hljs-function"> */</span><br><span class="hljs-function"><span class="hljs-title">private</span> <span class="hljs-title">Object</span> <span class="hljs-title">response</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    //优雅地使用<span class="hljs-title">wait</span>/<span class="hljs-title">notify</span></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">Object</span> <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">//如果返回结果为空就一直等待，避免虚假唤醒</span><br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(response == <span class="hljs-literal">null</span>)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">synchronized</span> <span class="hljs-params">(this)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">wait</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">response</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(<span class="hljs-built_in">Object</span> response)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">response</span> = <span class="hljs-title">response</span>;</span><br><span class="hljs-function"><span class="hljs-title">synchronized</span> <span class="hljs-params">(this)</span> &#123;</span><br><span class="hljs-function">//唤醒休眠的线程</span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">@<span class="hljs-title">Override</span></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">return</span> &quot;<span class="hljs-title">Guarded</span>&#123;&quot; +</span><br><span class="hljs-function">&quot;<span class="hljs-title">response</span>=&quot; + <span class="hljs-title">response</span> +</span><br><span class="hljs-function">&#x27;&#125;&#x27;;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;<span class="hljs-title">Copy</span></span><br></code></pre></td></tr></table></figure><p><strong>带超时判断的暂停</strong></p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">getResponse</span>(<span class="hljs-params">long</span> <span class="hljs-params">time</span>) &#123;<br><span class="hljs-title function_">synchronized</span> (<span class="hljs-variable language_">this</span>) &#123;<br><span class="hljs-comment">//获取开始时间</span><br><span class="hljs-variable">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">System</span>.<span class="hljs-property">currentTimeMillis</span>();<br><span class="hljs-comment">//用于保存已经等待了的时间</span><br><span class="hljs-variable">long</span> <span class="hljs-variable">passedTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-variable">response</span> <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span><br><span class="hljs-variable">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> <span class="hljs-variable">time</span> <span class="hljs-operator">-</span><span class="hljs-variable">passedTime</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">waitTime</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-title function_">try</span> &#123;<br>                   <span class="hljs-comment">//等待剩余时间</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">wait</span>(<span class="hljs-variable">waitTime</span>);<br>&#125; <span class="hljs-title function_">catch</span> (<span class="hljs-title class_">InterruptedException</span> <span class="hljs-variable">e</span>) &#123;<br><span class="hljs-variable">e</span>.<span class="hljs-property">printStackTrace</span>();<br>&#125;<br><span class="hljs-comment">//获取当前时间</span><br><span class="hljs-variable">passedTime</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">System</span>.<span class="hljs-property">currentTimeMillis</span>()<span class="hljs-operator">-</span><span class="hljs-variable">currentTime</span><br>            &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">response</span>;<br>&#125;<span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span></span><br><span class="hljs-function">    throws InterruptedException </span>&#123;<br>        <span class="hljs-type">long</span> base = System.<span class="hljs-built_in">currentTimeMillis</span>();<br>        <span class="hljs-type">long</span> now = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isAlive</span>()) &#123;<br>                <span class="hljs-built_in">wait</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isAlive</span>()) &#123;<br>                <span class="hljs-type">long</span> delay = millis - now;<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-built_in">wait</span>(delay);<br>                now = System.<span class="hljs-built_in">currentTimeMillis</span>() - base;<br>            &#125;<br>        &#125;<br>    &#125;Copy<br></code></pre></td></tr></table></figure><h2 id="8、park-x2F-unpark"><a href="#8、park-x2F-unpark" class="headerlink" title="8、park&#x2F;unpark"></a>8、park&#x2F;unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park&#x2F;unpark都是LockSupport类中的的方法</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//暂停线程运行</span><br>LockSupport.park;<br><br><span class="hljs-comment">//恢复线程运行</span><br>LockSupport.<span class="hljs-built_in">unpark</span>(thread);<span class="hljs-function">Copy</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(()-&gt; &#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;park&quot;</span>);<br>            <span class="hljs-comment">//暂停线程运行</span><br>LockSupport.<span class="hljs-built_in">park</span>();<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;resume&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>thread.<span class="hljs-built_in">start</span>();<br><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;unpark&quot;</span>);<br>    <span class="hljs-comment">//恢复线程运行</span><br>LockSupport.<span class="hljs-built_in">unpark</span>(thread);<br>&#125;Copy<br></code></pre></td></tr></table></figure><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait&#x2F;notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p><ul><li><p>先调用park再调用unpark时</p><ul><li><p>先调用park</p><ul><li>线程运行时，会将Park对象中的**_counter的值设为0**；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li><p>然后调用unpark</p><ul><li><p>调用unpark方法后，会将counter的值设置为1</p></li><li><p>去唤醒阻塞队列cond中的线程</p></li><li><p>线程继续运行并将counter的值设为0</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145250.png" alt="img"></a></p></li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145303.png" alt="img"></a></p><ul><li>先调用unpark，再调用park<ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145313.png" alt="img"></a></p><h2 id="9、线程中的状态转换"><a href="#9、线程中的状态转换" class="headerlink" title="9、线程中的状态转换"></a>9、线程中的状态转换</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145330.png" alt="img"></a></p><h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul><li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE</li></ul><h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul><li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li><li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li></ul></li></ul></li></ul><h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul><li><p>当前线程</p><p>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p><ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li></ul></li></ul><h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li><p>当前线程调用 t.join</p><p>(long n</p><p>) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p></li></ul><h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul><h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED</li></ul><h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p><h2 id="10、多把锁"><a href="#10、多把锁" class="headerlink" title="10、多把锁"></a>10、多把锁</h2><p><strong>将锁的粒度细分</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br>    <span class="hljs-comment">//额外创建对象来作为锁</span><br>private <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span> studyRoom = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>private <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span> bedRoom = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>&#125;Copy<br></code></pre></td></tr></table></figure><h2 id="11、活跃性"><a href="#11、活跃性" class="headerlink" title="11、活跃性"></a>11、活跃性</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>final <span class="hljs-built_in">Object</span> A = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>final <span class="hljs-built_in">Object</span> B = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (A) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">Thread.sleep(<span class="hljs-number">2000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (B) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (B) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">Thread.sleep(<span class="hljs-number">1000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (A) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;<span class="hljs-title">Copy</span></span><br></code></pre></td></tr></table></figure><h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul><li>互斥条件<ul><li>在一段时间内，一种资源只能被一个进程所使用</li></ul></li><li>请求和保持条件<ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul></li><li>不可抢占条件<ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul></li><li>循环等待条件<ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul></li></ul><h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul><li><p>jps+jstack ThreadID</p><ul><li><p>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145351.png" alt="img"></a></p></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">F:\Thread_study&gt;<span class="hljs-keyword">jps</span><br><span class="hljs-keyword"></span><span class="hljs-number">20672</span> RemoteMavenServer36<br><span class="hljs-number">22880</span> <span class="hljs-keyword">Jps</span><br><span class="hljs-keyword"></span><span class="hljs-number">4432</span> Launcher<br><span class="hljs-number">5316</span> Test5<br><span class="hljs-number">20184</span> KotlinCompileDaemon<br><span class="hljs-number">11132</span><br><br>F:\Thread_study&gt;<span class="hljs-keyword">jstack </span><span class="hljs-number">5316</span>Copy<br></code></pre></td></tr></table></figure></li><li><p>打印的结果</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs smali">//找到一个java级别的死锁<br>Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;Thread-1&quot;</span>:<br>  waiting to lock<span class="hljs-built_in"> monitor </span>0x0000000017f40de8 (object 0x00000000d6188880, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;Thread-0&quot;</span><br><span class="hljs-string">&quot;Thread-0&quot;</span>:<br>  waiting to lock<span class="hljs-built_in"> monitor </span>0x0000000017f43678 (object 0x00000000d6188890, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;Thread-1&quot;</span>Copy<br></code></pre></td></tr></table></figure></li><li><p>jconsole检测死锁</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145405.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145416.png" alt="img"></a></p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145436.png" alt="img"></a></p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145450.png" alt="img"></a></p><h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>在使用顺序加锁时，可能会出现饥饿现象</p><h2 id="12、ReentrantLock"><a href="#12、ReentrantLock" class="headerlink" title="12、ReentrantLock"></a>12、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li></ul><p><strong>基本语法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//获取ReentrantLock对象</span><br><span class="hljs-keyword">private</span> ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//加锁</span><br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//需要执行的代码</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//释放锁</span><br><span class="hljs-keyword">lock</span>.unlock();<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//加锁，可打断锁</span><br><span class="hljs-keyword">lock</span>.lockInterruptibly();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>                <span class="hljs-comment">//被打断，返回，不再向下执行</span><br><span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//释放锁</span><br><span class="hljs-keyword">lock</span>.unlock();<br>&#125;<br><br>&#125;);<br><br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>t1.start();<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//打断</span><br>t1.interrupt();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">lock</span>.unlock();<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-regexp">//未设置等待时间，一旦获取失败，直接返回false</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">if(!lock.tryLock()) &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">System.out.println(&quot;获取失败&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                //</span>获取失败，不再向下执行，返回</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span>&#123;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">3000</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;<span class="hljs-title">Copy</span></span><br></code></pre></td></tr></table></figure><p>设置等待时间</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-regexp">//判断获取锁是否成功，最多等待1秒</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">if(!lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">System.out.println(&quot;获取失败&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">//</span>获取失败，不再向下执行，直接返回</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-regexp">//被打断，不再向下执行，直接返回</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">return;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">&#125;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">System.out.println(&quot;得到了锁&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">//</span>释放锁</span></span><br><span class="hljs-params"><span class="hljs-function">lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span>&#123;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">//打断等待</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">3000</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;<span class="hljs-title">Copy</span></span><br></code></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span><br>ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-literal">true</span>);Copy<br></code></pre></td></tr></table></figure><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li>await 前需要<strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-literal">false</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//获得条件变量</span><br>Condition condition = <span class="hljs-keyword">lock</span>.newCondition();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">while</span>(!judge) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;不满足条件，等待...&quot;</span>);<br><span class="hljs-comment">//等待</span><br>condition.<span class="hljs-keyword">await</span>();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;执行完毕！&quot;</span>);<br><span class="hljs-keyword">lock</span>.unlock();<br>&#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1</span>);<br>judge = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//释放</span><br>condition.signal();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">lock</span>.unlock();<br>&#125;<br><br>&#125;).start();<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="通过Lock与AQS实现可重入锁"><a href="#通过Lock与AQS实现可重入锁" class="headerlink" title="通过Lock与AQS实现可重入锁"></a>通过Lock与AQS实现可重入锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>               setExclusiveOwnerThread(Thread.currentThread());<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == Thread.currentThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> getState();<br>            compareAndSetState(state, state + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>         <span class="hljs-keyword">if</span> (getState() &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>         &#125;<br><br>         <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> getState();<br>         <span class="hljs-keyword">if</span> (state == <span class="hljs-number">1</span>) &#123;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            compareAndSetState(state, <span class="hljs-number">0</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            compareAndSetState(state, state - <span class="hljs-number">1</span>);<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> getState() &gt;= <span class="hljs-number">1</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>      &#125;<br><br>   &#125;<br><br>   <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>      sync.acquire(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, time);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>      sync.release(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> sync.newCondition();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>      <span class="hljs-type">MyLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLock</span>();<br><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">syncLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>               lock.lock();<br>               <span class="hljs-keyword">try</span> &#123;<br>                  lock.lock();<br>                  <span class="hljs-keyword">try</span> &#123;<br>                     num++;<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     lock.unlock();<br>                  &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  lock.unlock();<br>               &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               lock.unlock();<br>            &#125;<br>         &#125;<br>      &#125;);<br><br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>               lock.lock();<br>               <span class="hljs-keyword">try</span> &#123;<br>                  lock.lock();<br>                  <span class="hljs-keyword">try</span> &#123;<br>                     num--;<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     lock.unlock();<br>                  &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  lock.unlock();<br>               &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               lock.unlock();<br>            &#125;<br>         &#125;<br>      &#125;);<br><br>      t1.start();<br>      t2.start();<br>      t1.join();<br>      t2.join();<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h2 id="13、同步模式之顺序控制"><a href="#13、同步模式之顺序控制" class="headerlink" title="13、同步模式之顺序控制"></a>13、同步模式之顺序控制</h2><h3 id="Wait-x2F-Notify版本"><a href="#Wait-x2F-Notify版本" class="headerlink" title="Wait&#x2F;Notify版本"></a>Wait&#x2F;Notify版本</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">static final <span class="hljs-keyword">Object</span> <span class="hljs-keyword">LOCK</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>();<br>//判断先执行的内容是否执行完毕<br>static <span class="hljs-type">Boolean</span> judge = <span class="hljs-keyword">false</span>;<br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><span class="hljs-built_in">new</span> Thread(()-&gt;&#123;<br>synchronized (<span class="hljs-keyword">LOCK</span>) &#123;<br><span class="hljs-keyword">while</span> (!judge) &#123;<br>try &#123;<br><span class="hljs-keyword">LOCK</span>.wait();<br>&#125; catch (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;2&quot;);<br>&#125;<br>&#125;).<span class="hljs-keyword">start</span>();<br><br><span class="hljs-built_in">new</span> Thread(()-&gt;&#123;<br>synchronized (<span class="hljs-keyword">LOCK</span>) &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;1&quot;);<br>judge = <span class="hljs-keyword">true</span>;<br>               //执行完毕，唤醒所有等待线程<br><span class="hljs-keyword">LOCK</span>.notifyAll();<br>&#125;<br>&#125;).<span class="hljs-keyword">start</span>();<br>&#125;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p><strong>wait&#x2F;notify版本</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">Symbol</span> symbol = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Symbol</span>();<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">symbol.run(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">symbol.run(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">symbol</span>.<span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Symbol</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">synchronized</span> <span class="hljs-title">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-built_in">String</span> str, int flag, int nextFlag)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(flag != this.flag)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">wait</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(str)</span>;</span><br><span class="hljs-function">//设置下一个运行的线程标记</span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">flag</span> = <span class="hljs-title">nextFlag</span>;</span><br><span class="hljs-function">//唤醒所有线程</span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">/**</span><br><span class="hljs-function"> * 线程的执行标记， 1-&gt;</span>a <span class="hljs-number">2</span>-&gt;b <span class="hljs-number">3</span>-&gt;c<br> */<br>private int flag = <span class="hljs-number">1</span>;<br>private int loopNumber = <span class="hljs-number">5</span>;<br><br>public int getFlag() &#123;<br><span class="hljs-keyword">return</span> flag;<br>&#125;<br><br>public <span class="hljs-literal">void</span> setFlag(int flag) &#123;<br>this.flag = flag;<br>&#125;<br><br>public int getLoopNumber() &#123;<br><span class="hljs-keyword">return</span> loopNumber;<br>&#125;<br><br>public <span class="hljs-literal">void</span> setLoopNumber(int loopNumber) &#123;<br>this.loopNumber = loopNumber;<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>await&#x2F;signal版本</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br><span class="hljs-keyword">static</span> AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal();<br><span class="hljs-keyword">static</span> Condition conditionA = awaitSignal.newCondition();<br><span class="hljs-keyword">static</span> Condition conditionB = awaitSignal.newCondition();<br><span class="hljs-keyword">static</span> Condition conditionC = awaitSignal.newCondition();<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">awaitSignal.run(<span class="hljs-string">&quot;a&quot;</span>, conditionA, conditionB);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">awaitSignal.run(<span class="hljs-string">&quot;b&quot;</span>, conditionB, conditionC);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">awaitSignal.run(<span class="hljs-string">&quot;c&quot;</span>, conditionC, conditionA);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">awaitSignal</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            //唤醒一个等待的线程</span><br><span class="hljs-function"><span class="hljs-title">conditionA</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;<span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">awaitSignal</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-title">extends</span> <span class="hljs-title">ReentrantLock</span>&#123;</span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-built_in">String</span> str, Condition thisCondition, Condition nextCondition)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">                //全部进入等待状态</span><br><span class="hljs-function"><span class="hljs-title">thisCondition</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">print</span><span class="hljs-params">(str)</span>;</span><br><span class="hljs-function"><span class="hljs-title">nextCondition</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">loopNumber</span>=5;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(int loopNumber)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">loopNumber</span> = <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;<span class="hljs-title">Copy</span></span><br></code></pre></td></tr></table></figure><h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么<strong>访问这个变量的每个线程都会有这个变量的一个本地副本</strong>。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalStudy</span> &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>      <span class="hljs-comment">// 创建ThreadLocal变量</span><br>      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>      ThreadLocal&lt;User&gt; userThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>      <span class="hljs-comment">// 创建两个线程，分别使用上面的两个ThreadLocal变量</span><br>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>         <span class="hljs-comment">// stringThreadLocal第一次赋值</span><br>         stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;thread1 stringThreadLocal first&quot;</span>);<br>         <span class="hljs-comment">// stringThreadLocal第二次赋值</span><br>         stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;thread1 stringThreadLocal second&quot;</span>);<br>         <span class="hljs-comment">// userThreadLocal赋值</span><br>         userThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Nyima&quot;</span>, <span class="hljs-number">20</span>));<br><br>         <span class="hljs-comment">// 取值</span><br>         System.<span class="hljs-keyword">out</span>.println(stringThreadLocal.<span class="hljs-keyword">get</span>());<br>         System.<span class="hljs-keyword">out</span>.println(userThreadLocal.<span class="hljs-keyword">get</span>());<br>          <br>          <span class="hljs-comment">// 移除</span><br> userThreadLocal.<span class="hljs-keyword">remove</span>();<br> System.<span class="hljs-keyword">out</span>.println(userThreadLocal.<span class="hljs-keyword">get</span>());<br>      &#125;);<br><br>      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>         <span class="hljs-comment">// stringThreadLocal第一次赋值</span><br>         stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;thread2 stringThreadLocal first&quot;</span>);<br>         <span class="hljs-comment">// stringThreadLocal第二次赋值</span><br>         stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;thread2 stringThreadLocal second&quot;</span>);<br>         <span class="hljs-comment">// userThreadLocal赋值</span><br>         userThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Hulu&quot;</span>, <span class="hljs-number">20</span>));<br><br>         <span class="hljs-comment">// 取值</span><br>         System.<span class="hljs-keyword">out</span>.println(stringThreadLocal.<span class="hljs-keyword">get</span>());<br>         System.<span class="hljs-keyword">out</span>.println(userThreadLocal.<span class="hljs-keyword">get</span>());<br>      &#125;);<br><br>      <span class="hljs-comment">// 启动线程</span><br>      thread1.start();<br>      thread2.start();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> &#123;<br>   String name;<br>   <span class="hljs-built_in">int</span> age;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span>(<span class="hljs-params">String name, <span class="hljs-built_in">int</span> age</span>)</span> &#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.age = age;<br>   &#125;<br><br>   @Override<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>   &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">thread1 stringThreadLocal second<br>thread2 stringThreadLocal second<br>User&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Nyima&#x27;</span>, <span class="hljs-attribute">age</span>=20&#125;<br>User&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Hulu&#x27;</span>, <span class="hljs-attribute">age</span>=20&#125;<br>nullCopy<br></code></pre></td></tr></table></figure><p>从运行结果可以看出</p><ul><li>每个线程中的ThreadLocal变量是每个线程私有的，而不是共享的<ul><li>从线程1和线程2的打印结果可以看出</li></ul></li><li>ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的<ul><li>stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果</li></ul></li><li>ThreadLocal可以进行以下几个操作<ul><li>set 设置值</li><li>get 取出值</li><li>remove 移除值</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Thread中的threadLocals"><a href="#Thread中的threadLocals" class="headerlink" title="Thread中的threadLocals"></a>Thread中的threadLocals</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br> ...<br><br> <span class="hljs-type">ThreadLocal</span>.<span class="hljs-type">ThreadLocalMap</span> threadLocals = <span class="hljs-literal">null</span>;<br><br> <span class="hljs-comment">// 放在后面说</span><br> <span class="hljs-type">ThreadLocal</span>.<span class="hljs-type">ThreadLocalMap</span> inheritableThreadLocals = <span class="hljs-literal">null</span>;<br><br> ...<br>&#125;<span class="hljs-type">Copy</span><br>static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br>    static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        <span class="hljs-type">Object</span> value;<br><br>        <span class="hljs-type">Entry</span>(<span class="hljs-type">ThreadLocal</span>&lt;?&gt; k, <span class="hljs-type">Object</span> v) &#123;<br>            <span class="hljs-keyword">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<span class="hljs-type">Copy</span><br></code></pre></td></tr></table></figure><p>可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论</p><h4 id="ThreadLocal中的方法"><a href="#ThreadLocal中的方法" class="headerlink" title="ThreadLocal中的方法"></a><strong>ThreadLocal中的方法</strong></h4><p><strong>set方法</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> <span class="hljs-built_in">set</span>(T value) &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-keyword">Thread</span> t = <span class="hljs-keyword">Thread</span>.currentThread();<br>    <br>    <span class="hljs-comment">// 获得ThreadLocalMap对象 </span><br>    <span class="hljs-comment">// 这里的get会返回Thread类中的threadLocals</span><br>    ThreadLocalMap <span class="hljs-built_in">map</span> = getMap(t);<br>    <br>    <span class="hljs-comment">// 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span> != <span class="hljs-built_in">null</span>)<br>        <span class="hljs-comment">// ThreadLocal自生的引用作为key，传入的值作为value</span><br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">set</span>(this, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>如果未创建</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void create<span class="hljs-constructor">Map(Thread <span class="hljs-params">t</span>, T <span class="hljs-params">firstValue</span>)</span> &#123;<br>    <span class="hljs-comment">// 创建的同时设置想放入的值</span><br>    <span class="hljs-comment">// hreadLocal自生的引用作为key，传入的值作为value</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadLocalMap(<span class="hljs-params">this</span>, <span class="hljs-params">firstValue</span>)</span>;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>get方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 获取当前线程的threadLocals变量</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <br>    <span class="hljs-comment">// 判断threadLocals是否被初始化了</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 已经初始化则直接返回</span><br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 否则就创建threadLocals</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;Copy<br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 这个方法返回是null</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <br>    <span class="hljs-comment">// 无论map创建与否，最终value的值都为null</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;Copy<br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>remove方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>()</span> &#123;<br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 如果threadLocals已经被初始化，则移除</span><br>        m.<span class="hljs-keyword">remove</span>(<span class="hljs-keyword">this</span>);<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中<strong>key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值</strong>。每个线程的本地变量存放在线程自己的内存变量threadLocals中</p><p>只有当前线程<strong>第一次调用ThreadLocal的set或者get方法时才会创建threadLocals</strong>（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</p><h2 id="15、InheritableThreadLocal"><a href="#15、InheritableThreadLocal" class="headerlink" title="15、InheritableThreadLocal"></a>15、InheritableThreadLocal</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>Copy<br></code></pre></td></tr></table></figure><p>所以ThreadLocal无法从父线程传向子线程，所以InheritableThreadLocal出现了，<strong>它能够让父线程中ThreadLocal的值传给子线程。</strong></p><p>也就是从main所在的线程，传给thread1或thread2</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>      ThreadLocal&lt;<span class="hljs-keyword">String</span>&gt; stringThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadLocal</span>&lt;&gt;();<br>      InheritableThreadLocal&lt;<span class="hljs-keyword">String</span>&gt; stringInheritable = <span class="hljs-keyword">new</span> <span class="hljs-type">InheritableThreadLocal</span>&lt;&gt;();<br><br>      <span class="hljs-comment">// 主线程赋对上面两个变量进行赋值</span><br>      stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;this is threadLocal&quot;</span>);<br>      stringInheritable.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;this is inheritableThreadLocal&quot;</span>);<br><br>      <span class="hljs-comment">// 创建线程</span><br>      Thread thread1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(()-&gt;&#123;<br>         <span class="hljs-comment">// 获得ThreadLocal中存放的值</span><br>         System.out.println(stringThreadLocal.<span class="hljs-keyword">get</span>());<br><br>         <span class="hljs-comment">// 获得InheritableThreadLocal存放的值</span><br>         System.out.println(stringInheritable.<span class="hljs-keyword">get</span>());<br>      &#125;);<br><br>      thread1.start();<br>   &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-literal">null</span><br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> inheritableThreadLocalCopy<br></code></pre></td></tr></table></figure><p>可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocal&lt;T&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadLocal&lt;T&gt;</span> </span>&#123;<br>    <span class="hljs-comment">// 传入父线程中的一个值，然后直接返回</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">T</span> childValue(<span class="hljs-type">T</span> parentValue) &#123;<br>        <span class="hljs-keyword">return</span> parentValue;<br>    &#125;<br><br>  <span class="hljs-comment">// 返回传入线程的inheritableThreadLocals</span><br>    <span class="hljs-comment">// Thread中有一个inheritableThreadLocals变量</span><br>    <span class="hljs-comment">// ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br>    <span class="hljs-type">ThreadLocalMap</span> getMap(<span class="hljs-type">Thread</span> t) &#123;<br>       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>    &#125;<br><br> <span class="hljs-comment">// 创建一个inheritableThreadLocals</span><br>    void createMap(<span class="hljs-type">Thread</span> t, <span class="hljs-type">T</span> firstValue) &#123;<br>        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadLocalMap</span>(<span class="hljs-keyword">this</span>, firstValue);<br>    &#125;<br>&#125;<span class="hljs-type">Copy</span><br></code></pre></td></tr></table></figure><p>由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了<strong>createMap方法</strong>，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用<strong>getMap方法</strong>获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals</p><h4 id="childValue-T-parentValue-方法的调用"><a href="#childValue-T-parentValue-方法的调用" class="headerlink" title="childValue(T parentValue)方法的调用"></a>childValue(T parentValue)方法的调用</h4><p>在主函数运行时，会调用Thread的默认构造函数（<strong>创建主线程</strong>，也就是父线程），所以我们先看看Thread的默认构造函数</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;<br>    init(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>&#125;Copy<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable <span class="hljs-keyword">target</span>, String name,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;<br>   ...<br>        <br><span class="hljs-comment">// 获得当前线程的，在这里是主线程</span><br>    Thread parent = currentThread();<br>   <br>    ...<br>    <br>    <span class="hljs-comment">// 如果父线程的inheritableThreadLocals存在</span><br>    <span class="hljs-comment">// 我们在主线程中调用set和get时，会创建inheritableThreadLocals</span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 设置子线程的inheritableThreadLocals</span><br>        <span class="hljs-keyword">this</span>.inheritableThreadLocals =<br>            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br>    <br>    <span class="hljs-comment">/* Stash the specified stack size in case the VM cares */</span><br>    <span class="hljs-keyword">this</span>.stackSize = stackSize;<br><br>    <span class="hljs-comment">/* Set thread ID */</span><br>    tid = nextThreadID();<br>&#125;Copy<br><span class="hljs-keyword">static</span> <span class="hljs-function">ThreadLocalMap <span class="hljs-title">createInheritedMap</span><span class="hljs-params">(ThreadLocalMap parentMap)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadLocalMap(parentMap);<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> <span class="hljs-constructor">ThreadLocalMap(ThreadLocalMap <span class="hljs-params">parentMap</span>)</span> &#123;<br>    Entry<span class="hljs-literal">[]</span> parentTable = parentMap.table;<br>    <span class="hljs-built_in">int</span> len = parentTable.length;<br>    set<span class="hljs-constructor">Threshold(<span class="hljs-params">len</span>)</span>;<br>    table = <span class="hljs-keyword">new</span> Entry<span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        Entry e = parentTable<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>        <span class="hljs-keyword">if</span> (e != null) &#123;<br>            @<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)</span><br>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get<span class="hljs-literal">()</span>;<br>            <span class="hljs-keyword">if</span> (key != null) &#123;<br>                <span class="hljs-comment">// 这里调用了 childValue 方法</span><br>                <span class="hljs-comment">// 该方法会返回parent的值</span><br>                Object value = key.child<span class="hljs-constructor">Value(<span class="hljs-params">e</span>.<span class="hljs-params">value</span>)</span>;<br>                <br>                Entry c = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Entry(<span class="hljs-params">key</span>, <span class="hljs-params">value</span>)</span>;<br>                <span class="hljs-built_in">int</span> h = key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (table<span class="hljs-literal">[<span class="hljs-identifier">h</span>]</span> != null)<br>                    h = next<span class="hljs-constructor">Index(<span class="hljs-params">h</span>, <span class="hljs-params">len</span>)</span>;<br>                table<span class="hljs-literal">[<span class="hljs-identifier">h</span>]</span> = c;<br>                size++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>InheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。</p><p><strong>当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。</strong></p><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> Boolean run = <span class="hljs-literal">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(()-&gt;&#123;<br><span class="hljs-keyword">while</span> (run) &#123;<br><span class="hljs-comment">//如果run为真，则一直执行</span><br>&#125;<br>&#125;).<span class="hljs-built_in">start</span>();<br><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>run = <span class="hljs-literal">false</span>;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145505.png" alt="img"></a></p><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145517.png" alt="img"></a></p><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145529.png" alt="img"></a></p><p><strong>解决方法</strong></p><ul><li>使用<strong>volatile</strong>易变关键字</li><li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//使用易变关键字</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">static</span> Boolean run = <span class="hljs-literal">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(()-&gt;&#123;<br><span class="hljs-keyword">while</span> (run) &#123;<br><span class="hljs-comment">//如果run为真，则一直执行</span><br>&#125;<br>&#125;).<span class="hljs-built_in">start</span>();<br><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>run = <span class="hljs-literal">false</span>;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li><p>因为使用了<strong>synchronized</strong>关键字</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">println</span>(String x) &#123;<br><span class="hljs-comment">//使用了synchronized关键字</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">print</span>(x);<br>            newLine();<br>        &#125;<br>    &#125;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>monitor.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>monitor.stop();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;<br><br>Thread monitor;<br><span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> boolean stop = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span> &#123;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-keyword">if</span>(stop) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span>()</span> &#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.interrupt();<br>        <span class="hljs-comment">//修改标记</span><br>stop = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong></p><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题<ul><li>加锁的代码块要尽量的小，以保证性能</li></ul></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package com.nyima.day1;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author Chen Panwen</span><br><span class="hljs-comment"> * @data 2020/3/26 16:11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>monitor.start();<br>monitor.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>monitor.stop();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;<br><br>Thread monitor;<br><span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> boolean stop = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><br><span class="hljs-keyword">private</span> boolean starting = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span> &#123;<br><span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><br>synchronized (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">if</span> (starting) &#123;<br><span class="hljs-comment">//已被启动，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//启动监视器，改变标记</span><br>starting = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-keyword">if</span>(stop) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span>()</span> &#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.interrupt();<br>stop = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145546.png" alt="img"></a></p><p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145615.png" alt="img"></a></p><ul><li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p></li><li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 可以重排的例子 </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; <br>System.out.<span class="hljs-keyword">println</span>( a + b );<br><br><span class="hljs-comment">// 不能重排的例子 </span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC &#x3D; 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145602.png" alt="img"></a></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><ul><li>禁止的是加volatile关键字变量之前的代码被重排序</li></ul><h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><ul><li>可见性<ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中</li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul></li></ul><h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145630.png" alt="img"></a></p></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145713.png" alt="img"></a></p></li></ul><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145723.png" alt="img"></a></p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145729.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145741.png" alt="img"></a></p><p><strong>但是不能解决指令交错问题</strong></p><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><h3 id="实现原理之Lock前缀"><a href="#实现原理之Lock前缀" class="headerlink" title="实现原理之Lock前缀"></a>实现原理之Lock前缀</h3><p>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">instance</span> <span class="hljs-operator">=</span> new Singleton()<span class="hljs-comment">;Copy</span><br></code></pre></td></tr></table></figure><p>对应的汇编代码是</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">... <span class="hljs-keyword">lock</span> addl .<span class="hljs-built_in">..Copy</span><br></code></pre></td></tr></table></figure><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，<strong>Lock前缀</strong>的指令在多核处理器下会引发了两件事</p><ul><li><p>Lock前缀指令会引起处理器</p><p>缓存回写到内存</p><ul><li>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是<strong>锁缓存</strong>，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong></li></ul></li><li><p>一个处理器的缓存回写到内存会</p><p>导致其他处理器的缓存无效</p><ul><li>在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能<strong>嗅探其他处理器访问系统内存和它们的内部缓存</strong>。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</li></ul></li></ul><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><ul><li><p>使用<strong>原子整数</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">AtomicInteger balance <span class="hljs-operator">=</span> new AtomicInteger()<span class="hljs-comment">;Copy</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br><span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">long</span> start = System.nanoTime();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>account.withdraw(<span class="hljs-number">10</span>);<br>&#125;));<br>&#125;<br>ts.forEach(Thread::start);<br>ts.forEach(t -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>t.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br><span class="hljs-keyword">long</span> end = System.nanoTime();<br>System.out.println(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000</span>_000 + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//线程不安全的做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br><span class="hljs-keyword">private</span> Integer balance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.balance = balance;<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>balance -= amount;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));<br>Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//线程安全的做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br><span class="hljs-comment">//使用原子整数</span><br><span class="hljs-keyword">private</span> AtomicInteger balance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//得到原子整数的值</span><br><span class="hljs-function"><span class="hljs-keyword">return</span> balance.<span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">//获得修改前的值</span><br><span class="hljs-keyword">int</span> prev = balance.get();<br><span class="hljs-comment">//获得修改后的值</span><br><span class="hljs-keyword">int</span> next = prev-amount;<br><span class="hljs-comment">//比较并设值</span><br><span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145914.png" alt="img"></a></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><p><strong>注意</strong></p><ul><li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><p><strong>注意</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">volatile</span> 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145931.png" alt="img"></a></p><p><strong>原因</strong></p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li><p>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p></li><li><p>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p></li><li><p>CAS 体现的是</p><p>无锁并发、无阻塞并发</p><p>，请仔细体会这两句话的意思</p><ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p><strong>以 AtomicInteger 为例</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> AtomicInteger i = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AtomicInteger(0)</span>;<br> <br><span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span><br> <br><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span><br> <br><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span><br> <br><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.get<span class="hljs-constructor">AndDecrement()</span>);<br> <br><span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.get<span class="hljs-constructor">AndAdd(5)</span>);<br> <br><span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.add<span class="hljs-constructor">AndGet(-5)</span>);<br> <br><span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.get<span class="hljs-constructor">AndUpdate(<span class="hljs-params">p</span> -&gt; <span class="hljs-params">p</span> - 2)</span>);<br> <br><span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.update<span class="hljs-constructor">AndGet(<span class="hljs-params">p</span> -&gt; <span class="hljs-params">p</span> + 2)</span>);<br> <br><span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><br><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><br>final <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.get<span class="hljs-constructor">AndAccumulate(10, (<span class="hljs-params">p</span>, <span class="hljs-params">x</span>)</span> -&gt; p + x));<br> <br><span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.accumulate<span class="hljs-constructor">AndGet(-10, (<span class="hljs-params">p</span>, <span class="hljs-params">x</span>)</span> -&gt; p + x));Copy<br></code></pre></td></tr></table></figure><h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public interface DecimalAccount &#123;<br>BigDecimal getBalance();<br><br><span class="hljs-literal">void</span> withdraw(BigDecimal amount);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> demo(DecimalAccountImpl account) &#123;<br>List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>long start = System.nanoTime();<br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>ts.add<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">account.withdraw(BigDecimal.TEN);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;))</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">ts</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(Thread::start)</span>;</span><br><span class="hljs-function"><span class="hljs-title">ts</span>.<span class="hljs-title">forEach</span><span class="hljs-params">(t -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">t.join();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"><span class="hljs-title">long</span> <span class="hljs-title">end</span> = <span class="hljs-title">System</span>.<span class="hljs-title">nanoTime</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(account.getBalance() + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>)</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">DecimalAccount</span> &#123;</span><br><span class="hljs-function">//原子引用，泛型类型为小数类型</span><br><span class="hljs-function"><span class="hljs-title">AtomicReference</span>&lt;<span class="hljs-title">BigDecimal</span>&gt; <span class="hljs-title">balance</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">this</span>.<span class="hljs-title">balance</span> = <span class="hljs-title">new</span> <span class="hljs-title">AtomicReference</span>&lt;<span class="hljs-title">BigDecimal</span>&gt;<span class="hljs-params">(balance)</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">@<span class="hljs-title">Override</span></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">BigDecimal</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">balance</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">@<span class="hljs-title">Override</span></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">BigDecimal</span> <span class="hljs-title">pre</span> = <span class="hljs-title">balance</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">BigDecimal</span> <span class="hljs-title">next</span> = <span class="hljs-title">pre</span>.<span class="hljs-title">subtract</span><span class="hljs-params">(amount)</span>;</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(balance.compareAndSet(pre, next))</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">break</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-built_in">String</span>[] args)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">DecimalAccount</span>.<span class="hljs-title">demo</span><span class="hljs-params">(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)))</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;<span class="hljs-title">Copy</span></span><br></code></pre></td></tr></table></figure><h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> &#123;<br><span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>String pre = str.<span class="hljs-keyword">get</span>();<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//把str中的A改为C</span><br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));<br>&#125;).start();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span>() throws InterruptedException</span> &#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>));<br>&#125;).start();<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>));<br>&#125;).start();<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608145952.png" alt="img"></a></p><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Demo3 &#123;<br><span class="hljs-comment">//指定版本号</span><br>static AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>String pre = str.get<span class="hljs-constructor">Reference()</span>;<br><span class="hljs-comment">//获得版本号</span><br><span class="hljs-built_in">int</span> stamp = str.get<span class="hljs-constructor">Stamp()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other<span class="hljs-literal">()</span>;<br>&#125; catch (InterruptedException e) &#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>&#125; catch (InterruptedException e) &#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br><span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + str.compare<span class="hljs-constructor">AndSet(<span class="hljs-params">pre</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-params">stamp</span>, <span class="hljs-params">stamp</span>+1)</span>);<br>&#125;).start<span class="hljs-literal">()</span>;<br>&#125;<br><br>static void other<span class="hljs-literal">()</span> throws InterruptedException &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt; &#123;<br><span class="hljs-built_in">int</span> stamp = str.get<span class="hljs-constructor">Stamp()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + str.compare<span class="hljs-constructor">AndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-params">stamp</span>, <span class="hljs-params">stamp</span>+1)</span>);<br>&#125;).start<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt; &#123;<br><span class="hljs-built_in">int</span> stamp = str.get<span class="hljs-constructor">Stamp()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp +  str.compare<span class="hljs-constructor">AndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-params">stamp</span>, <span class="hljs-params">stamp</span>+1)</span>);<br>&#125;).start<span class="hljs-literal">()</span>;<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608150003.png" alt="img"></a></p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> &#123;<br><span class="hljs-comment">//指定版本号</span><br><span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>String pre = str.getReference();<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> +  str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>));<br>&#125;).start();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span>() throws InterruptedException</span> &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>));<br>&#125;).start();<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608150017.png" alt="img"></a></p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul><li><strong>AtomicStampedReference</strong> 需要我们传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</li><li><strong>AtomicMarkableReference</strong>需要我们传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</li></ul><h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><h3 id="lamba表达式的使用"><a href="#lamba表达式的使用" class="headerlink" title="lamba表达式的使用"></a>lamba表达式的使用</h3><ul><li>提供者<ul><li>无参又返回</li><li>()-&gt;返回结果</li></ul></li><li>方法<ul><li>有参有返回</li><li>(参数一…)-&gt;返回结果</li></ul></li><li>消费者<ul><li>有参无返回</li><li>(参数一…)-&gt;void</li></ul></li></ul><h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul><li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdate</li></ul><p>原子更新器用于帮助我们改变某个对象中的某个属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>      <span class="hljs-title class_">Student</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>       <br>      <span class="hljs-comment">// 获得原子更新器</span><br>      <span class="hljs-comment">// 泛型</span><br>      <span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span><br>      <span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span><br>      <span class="hljs-title class_">AtomicReferenceFieldUpdater</span>&lt;<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">String</span>&gt; updater = <span class="hljs-title class_">AtomicReferenceFieldUpdater</span>.<span class="hljs-title function_">newUpdater</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property">class</span>, <span class="hljs-title class_">String</span>.<span class="hljs-property">class</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>       <br>      <span class="hljs-comment">// 修改</span><br>      updater.<span class="hljs-title function_">compareAndSet</span>(student, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Nyima&quot;</span>);<br>      <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(student);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>   volatile <span class="hljs-title class_">String</span> name;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>   &#125;<br>&#125;<span class="hljs-title class_">Copy</span><br></code></pre></td></tr></table></figure><h3 id="原子更新器初始化过程"><a href="#原子更新器初始化过程" class="headerlink" title="原子更新器初始化过程"></a>原子更新器初始化过程</h3><p>从上面的例子可以看出，原子更新器是通过newUpdater来获取实例的。其中传入了三个参数</p><ul><li>拥有属性的类的Class</li><li>属性的Class</li><li>属性的名称</li></ul><p>大概可以猜出来，<strong>初始化过程用到了反射</strong>，让我们看看源码来验证一下这个猜测。</p><h4 id="newUpdater方法"><a href="#newUpdater方法" class="headerlink" title="newUpdater方法"></a>newUpdater方法</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U,W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Updater</span>(Class&lt;U&gt; tclass,<br>                                                                Class&lt;W&gt; vclass,<br>                                                                <span class="hljs-keyword">String</span> fieldName) &#123;<br>    <span class="hljs-comment">// 返回了一个AtomicReferenceFieldUpdaterImpl实例</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicReferenceFieldUpdaterImpl</span>&lt;U,W&gt;<br>        (tclass, vclass, fieldName, Reflection.getCallerClass());<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>从newUpdater方法还并不能看出来具体的初始化过程</p><h4 id="内部实现类"><a href="#内部实现类" class="headerlink" title="内部实现类"></a>内部实现类</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20201020145006.png" alt="img"></a></p><p>AtomicReferenceFieldUpdater为抽象类，该类<strong>内部有一个自己的实现类AtomicReferenceFieldUpdaterImpl</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">AtomicReferenceFieldUpdaterImpl</span>&lt;<span class="hljs-symbol">T,<span class="hljs-symbol">V</span></span>&gt;<br>        <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AtomicReferenceFieldUpdater</span>&lt;<span class="hljs-symbol">T,<span class="hljs-symbol">V</span></span>&gt;<span class="hljs-symbol">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20201020145119.png" alt="img"></a></p><p><strong>构造方法</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs gradle">AtomicReferenceFieldUpdaterImpl(<span class="hljs-keyword">final</span> <span class="hljs-keyword">Class</span>&lt;T&gt; tclass,<br>                                <span class="hljs-keyword">final</span> <span class="hljs-keyword">Class</span>&lt;V&gt; vclass,<br>                                <span class="hljs-keyword">final</span> String fieldName,<br>                                <span class="hljs-keyword">final</span> <span class="hljs-keyword">Class</span>&lt;?&gt; caller) &#123;<br>    <span class="hljs-comment">// 用于保存要被修改的属性</span><br>    <span class="hljs-keyword">final</span> Field field;<br>    <br>    <span class="hljs-comment">// 属性的Class</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">Class</span>&lt;?&gt; fieldClass;<br>    <br>    <span class="hljs-comment">// field的修饰符</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> modifiers;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 反射获得属性</span><br>        field = AccessController.doPrivileged(<br>            <span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Field&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Field run() <span class="hljs-keyword">throws</span> NoSuchFieldException &#123;<br>                    <span class="hljs-comment">// tclass为传入的属性的Class，可以通过它来获得属性</span><br>                    <span class="hljs-keyword">return</span> tclass.getDeclaredField(fieldName);<br>                &#125;<br>            &#125;);<br>        <br>        <span class="hljs-comment">// 获得属性的修饰符，主要用于判断</span><br>        <span class="hljs-comment">// 1、vclass 与 属性确切的类型是否匹配</span><br>        <span class="hljs-comment">// 2、是否为引用类型</span><br>        <span class="hljs-comment">// 3、被修改的属性是否加了volatile关键字</span><br>        modifiers = field.getModifiers();<br>        sun.reflect.misc.ReflectUtil.ensureMemberAccess(<br>            caller, tclass, <span class="hljs-keyword">null</span>, modifiers);<br>        ClassLoader cl = tclass.getClassLoader();<br>        ClassLoader ccl = caller.getClassLoader();<br>        <span class="hljs-keyword">if</span> ((ccl != <span class="hljs-keyword">null</span>) &amp;&amp; (ccl != cl) &amp;&amp;<br>            ((cl == <span class="hljs-keyword">null</span>) || !isAncestor(cl, ccl))) &#123;<br>            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获得属性类的Class</span><br>        fieldClass = field.getType();<br>    &#125; <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(pae.getException());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (vclass != fieldClass)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException();<br>    <span class="hljs-keyword">if</span> (vclass.isPrimitive())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Must be reference type&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (!Modifier.isVolatile(modifiers))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Must be volatile type&quot;</span>);<br><br>    <span class="hljs-comment">// Access to protected field members is restricted to receivers only</span><br>    <span class="hljs-comment">// of the accessing class, or one of its subclasses, and the</span><br>    <span class="hljs-comment">// accessing class must in turn be a subclass (or package sibling)</span><br>    <span class="hljs-comment">// of the protected member&#x27;s defining class.</span><br>    <span class="hljs-comment">// If the updater refers to a protected field of a declaring class</span><br>    <span class="hljs-comment">// outside the current package, the receiver argument will be</span><br>    <span class="hljs-comment">// narrowed to the type of the accessing class.</span><br> <span class="hljs-comment">// 对类中的属性进行初始化</span><br>    <span class="hljs-keyword">this</span>.cclass = (Modifier.isProtected(modifiers) &amp;&amp;<br>                   tclass.isAssignableFrom(caller) &amp;&amp;<br>                   !isSamePackage(tclass, caller))<br>                  ? caller : tclass;<br>    <span class="hljs-keyword">this</span>.tclass = tclass;<br>    <span class="hljs-keyword">this</span>.vclass = vclass;<br>    <span class="hljs-comment">// 获得偏移量</span><br>    <span class="hljs-keyword">this</span>.offset = U.objectFieldOffset(field);<br>&#125;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>可以看出，原子引用更新器确实使用了反射</strong></p><h2 id="8、LongAdder原理"><a href="#8、LongAdder原理" class="headerlink" title="8、LongAdder原理"></a>8、LongAdder原理</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608150037.png" alt="img"></a></p><p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608150051.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608150102.png" alt="img"></a></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608150111.png" alt="img"></a></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1]</li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]&#x3D;6000, Cell[1]&#x3D;8000 要累加 Cell[0]&#x3D;6001, Cell[1]&#x3D;8000 ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608150119.png" alt="img"></a></p><p><strong>累加主要调用以下方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> x</span>)</span> &#123;<br>       Cell[] <span class="hljs-keyword">as</span>; <span class="hljs-built_in">long</span> b, v; <span class="hljs-built_in">int</span> m; Cell a;<br>       <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">as</span> = cells) != <span class="hljs-literal">null</span> || !casBase(b = <span class="hljs-keyword">base</span>, b + x)) &#123;<br>           boolean uncontended = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">as</span> == <span class="hljs-literal">null</span> || (m = <span class="hljs-keyword">as</span>.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>               (a = <span class="hljs-keyword">as</span>[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>               !(uncontended = a.cas(v = a.<span class="hljs-keyword">value</span>, v + x)))<br>               longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>       &#125;<br>   &#125;Copy<br></code></pre></td></tr></table></figure><p><strong>累加流程图</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20200608150129.png" alt="img"></a></p><h2 id="9、Unsafe"><a href="#9、Unsafe" class="headerlink" title="9、Unsafe"></a>9、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GetUnsafe</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException</span> &#123;<br><span class="hljs-comment">// 通过反射获得Unsafe对象</span><br>Class unsafeClass = Unsafe.<span class="hljs-keyword">class</span>;<br><span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span><br>Constructor constructor = unsafeClass.getDeclaredConstructor();<br><span class="hljs-comment">// 设置为允许访问私有内容</span><br>constructor.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 创建Unsafe对象</span><br>Unsafe <span class="hljs-keyword">unsafe</span> = (Unsafe) constructor.newInstance();<br><br><span class="hljs-comment">// 创建Person对象</span><br>Person person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-comment">// 获得其属性 name 的偏移量</span><br>Field field = Person.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-built_in">long</span> offset = <span class="hljs-keyword">unsafe</span>.objectFieldOffset(field);<br><br><span class="hljs-comment">// 通过unsafe的CAS操作改变值</span><br><span class="hljs-keyword">unsafe</span>.compareAndSwapObject(person, offset, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Nyima&quot;</span>);<br>System.<span class="hljs-keyword">out</span>.println(person);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span><br> <span class="hljs-keyword">volatile</span> String name;<br><br><br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br><span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br><span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h3 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h3><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><h3 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h3><h4 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_ inherited__">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">char</span> value[];<br><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <br>   <span class="hljs-comment">//....</span><br>  &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>ﬁnal 的使用 **<br>发现该类、类中所有属性都是 **ﬁnal</strong> 的</p><ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改</li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li></ul><p>**保护性拷贝 **</p><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public String substring(<span class="hljs-built_in">int</span> beginIndex) &#123;<br>        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">beginIndex</span>)</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> subLen = value.length - beginIndex;<br>        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">subLen</span>)</span>;<br>        &#125;<br>    <span class="hljs-comment">//返回的是一个新的对象</span><br>        return (beginIndex<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) ? this : <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">value</span>, <span class="hljs-params">beginIndex</span>, <span class="hljs-params">subLen</span>)</span>;<br>    &#125;Copy<br></code></pre></td></tr></table></figure><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">String(<span class="hljs-params">char</span> <span class="hljs-params">value</span>[], <span class="hljs-params">int</span> <span class="hljs-params">offset</span>, <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">offset</span>)</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>                throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">count</span>)</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>                this.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>                return;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>        <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringIndexOutOfBoundsException(<span class="hljs-params">offset</span> + <span class="hljs-params">count</span>)</span>;<br>        &#125;<br>        this.value = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">value</span>, <span class="hljs-params">offset</span>, <span class="hljs-params">offset</span>+<span class="hljs-params">count</span>)</span>;<br>    &#125;Copy<br></code></pre></td></tr></table></figure><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive copy）】</p><h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20201021154837.png" alt="img"></a></p><ul><li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li><li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li><li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>   public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>      ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">2</span>,  TimeUnit.SECONDS, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>      <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>         threadPool.execute<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">               TimeUnit.SECONDS.sleep(<span class="hljs-number">10000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">               e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            System.out.println(<span class="hljs-string">&quot;任务正在执行!&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">         &#125;)</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">/**</span><br><span class="hljs-function"> * 自定义线程池</span><br><span class="hljs-function"> */</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">ThreadPool</span> &#123;</span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 自定义阻塞队列</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">Runnable</span>&gt; <span class="hljs-title">blockingQueue</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 核心线程数</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">coreSize</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">Worker</span>&gt; <span class="hljs-title">workers</span> = <span class="hljs-title">new</span> <span class="hljs-title">HashSet</span>&lt;&gt;<span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 用于指定线程最大存活时间</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">TimeUnit</span> <span class="hljs-title">timeUnit</span>;</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">long</span> <span class="hljs-title">timeout</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 工作线程类</span><br><span class="hljs-function">    * 内部封装了<span class="hljs-title">Thread</span>类，并且添加了一些属性</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">class</span> <span class="hljs-title">Worker</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;</span><br><span class="hljs-function">      <span class="hljs-title">Runnable</span> <span class="hljs-title">task</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">      <span class="hljs-title">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;</span><br><span class="hljs-function">         <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;初始化任务&quot;</span>)</span>;</span><br><span class="hljs-function">         <span class="hljs-title">this</span>.<span class="hljs-title">task</span> = <span class="hljs-title">task</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">      @<span class="hljs-title">Override</span></span><br><span class="hljs-function">      <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">         // 如果有任务就执行</span><br><span class="hljs-function">         // 如果阻塞队列中有任务，就继续执行</span><br><span class="hljs-function">         <span class="hljs-title">while</span> <span class="hljs-params">(task != <span class="hljs-literal">null</span> || (task = blockingQueue.take()) != <span class="hljs-literal">null</span>)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">               <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;执行任务&quot;</span>)</span>;</span><br><span class="hljs-function">               <span class="hljs-title">task</span>.<span class="hljs-title">run</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(Exception e)</span> &#123;</span><br><span class="hljs-function">               <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">               // 任务执行完毕，设为空</span><br><span class="hljs-function">               <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;任务执行完毕&quot;</span>)</span>;</span><br><span class="hljs-function">               <span class="hljs-title">task</span> = <span class="hljs-title">null</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">         &#125;</span><br><span class="hljs-function">         // 移除任务</span><br><span class="hljs-function">         <span class="hljs-title">synchronized</span> <span class="hljs-params">(workers)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;移除任务&quot;</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">workers</span>.<span class="hljs-title">remove</span><span class="hljs-params">(this)</span>;</span><br><span class="hljs-function">         &#125;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   <span class="hljs-title">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(int coreSize, TimeUnit timeUnit, long timeout, int capacity)</span> &#123;</span><br><span class="hljs-function">      <span class="hljs-title">this</span>.<span class="hljs-title">coreSize</span> = <span class="hljs-title">coreSize</span>;</span><br><span class="hljs-function">      <span class="hljs-title">this</span>.<span class="hljs-title">timeUnit</span> = <span class="hljs-title">timeUnit</span>;</span><br><span class="hljs-function">      <span class="hljs-title">blockingQueue</span> = <span class="hljs-title">new</span> <span class="hljs-title">BlockingQueue</span>&lt;&gt;<span class="hljs-params">(capacity)</span>;</span><br><span class="hljs-function">      <span class="hljs-title">this</span>.<span class="hljs-title">timeout</span> = <span class="hljs-title">timeout</span>;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> &#123;</span><br><span class="hljs-function">      <span class="hljs-title">synchronized</span> <span class="hljs-params">(workers)</span> &#123;</span><br><span class="hljs-function">         // 创建任务</span><br><span class="hljs-function">         // 池中还有空余线程时，可以运行任务</span><br><span class="hljs-function">         // 否则阻塞</span><br><span class="hljs-function">         <span class="hljs-title">if</span> <span class="hljs-params">(workers.size() &lt; coreSize)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">Worker</span> <span class="hljs-title">worker</span> = <span class="hljs-title">new</span> <span class="hljs-title">Worker</span><span class="hljs-params">(task)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">workers</span>.<span class="hljs-title">add</span><span class="hljs-params">(worker)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">worker</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">         &#125; <span class="hljs-title">else</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;线程池中线程已用完，请稍等&quot;</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">blockingQueue</span>.<span class="hljs-title">put</span><span class="hljs-params">(task)</span>;</span><br><span class="hljs-function">         &#125;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">/**</span><br><span class="hljs-function"> * 阻塞队列</span><br><span class="hljs-function"> * 用于存放主线程或其他线程产生的任务</span><br><span class="hljs-function"> */</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt; &#123;</span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 阻塞队列</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">private</span>  <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">blockingQueue</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 阻塞队列容量</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">capacity</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 锁</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-title">lock</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 条件队列</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">Condition</span> <span class="hljs-title">fullQueue</span>;</span><br><span class="hljs-function">   <span class="hljs-title">private</span> <span class="hljs-title">Condition</span> <span class="hljs-title">emptyQueue</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">   <span class="hljs-title">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(int capacity)</span> &#123;</span><br><span class="hljs-function">      <span class="hljs-title">blockingQueue</span> = <span class="hljs-title">new</span> <span class="hljs-title">ArrayDeque</span>&lt;&gt;<span class="hljs-params">(capacity)</span>;</span><br><span class="hljs-function">      <span class="hljs-title">lock</span> = <span class="hljs-title">new</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      <span class="hljs-title">fullQueue</span> = <span class="hljs-title">lock</span>.<span class="hljs-title">newCondition</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      <span class="hljs-title">emptyQueue</span> = <span class="hljs-title">lock</span>.<span class="hljs-title">newCondition</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      <span class="hljs-title">this</span>.<span class="hljs-title">capacity</span> = <span class="hljs-title">capacity</span>;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 获取任务的方法</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">public</span> <span class="hljs-title">T</span> <span class="hljs-title">take</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">      // 加锁</span><br><span class="hljs-function">      <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">         // 如果阻塞队列为空（没有任务），就一直等待</span><br><span class="hljs-function">         <span class="hljs-title">while</span> <span class="hljs-params">(blockingQueue.isEmpty())</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">               <span class="hljs-title">emptyQueue</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">               <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">         &#125;</span><br><span class="hljs-function">         // 获取任务并唤醒生产者线程</span><br><span class="hljs-function">         <span class="hljs-title">T</span> <span class="hljs-title">task</span> = <span class="hljs-title">blockingQueue</span>.<span class="hljs-title">removeFirst</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">         <span class="hljs-title">fullQueue</span>.<span class="hljs-title">signalAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">         <span class="hljs-title">return</span> <span class="hljs-title">task</span>;</span><br><span class="hljs-function">      &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">         <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   <span class="hljs-title">public</span> <span class="hljs-title">T</span> <span class="hljs-title">takeNanos</span><span class="hljs-params">(long timeout, TimeUnit unit)</span> &#123;</span><br><span class="hljs-function">      // 转换等待时间</span><br><span class="hljs-function">      <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">         <span class="hljs-title">long</span> <span class="hljs-title">nanos</span> = <span class="hljs-title">unit</span>.<span class="hljs-title">toNanos</span><span class="hljs-params">(timeout)</span>;</span><br><span class="hljs-function">         <span class="hljs-title">while</span> <span class="hljs-params">(blockingQueue.isEmpty())</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">               // <span class="hljs-title">awaitNanos</span>会返回剩下的等待时间</span><br><span class="hljs-function">               <span class="hljs-title">nanos</span> = <span class="hljs-title">emptyQueue</span>.<span class="hljs-title">awaitNanos</span><span class="hljs-params">(nanos)</span>;</span><br><span class="hljs-function">               <span class="hljs-title">if</span> <span class="hljs-params">(nanos &lt; <span class="hljs-number">0</span>)</span> &#123;</span><br><span class="hljs-function">                  <span class="hljs-title">return</span> <span class="hljs-title">null</span>;</span><br><span class="hljs-function">               &#125;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">               <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">         &#125;</span><br><span class="hljs-function">         <span class="hljs-title">T</span> <span class="hljs-title">task</span> = <span class="hljs-title">blockingQueue</span>.<span class="hljs-title">removeFirst</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">         <span class="hljs-title">fullQueue</span>.<span class="hljs-title">signalAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">         <span class="hljs-title">return</span> <span class="hljs-title">task</span>;</span><br><span class="hljs-function">      &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">         <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   /**</span><br><span class="hljs-function">    * 放入任务的方法</span><br><span class="hljs-function">    * @<span class="hljs-title">param</span> <span class="hljs-title">task</span> 放入阻塞队列的任务</span><br><span class="hljs-function">    */</span><br><span class="hljs-function">   <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T task)</span> &#123;</span><br><span class="hljs-function">      <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">         <span class="hljs-title">while</span> <span class="hljs-params">(blockingQueue.size() == capacity)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">               <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;阻塞队列已满&quot;</span>)</span>;</span><br><span class="hljs-function">               <span class="hljs-title">fullQueue</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">               <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">         &#125;</span><br><span class="hljs-function">         <span class="hljs-title">blockingQueue</span>.<span class="hljs-title">add</span><span class="hljs-params">(task)</span>;</span><br><span class="hljs-function">         // 唤醒等待的消费者</span><br><span class="hljs-function">         <span class="hljs-title">emptyQueue</span>.<span class="hljs-title">signalAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">         <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">   <span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">      <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">         <span class="hljs-title">return</span> <span class="hljs-title">blockingQueue</span>.<span class="hljs-title">size</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">         <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">   &#125;</span><br><span class="hljs-function">&#125;<span class="hljs-title">Copy</span></span><br></code></pre></td></tr></table></figure><p>实现了一个简单的线程池</p><ul><li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul><li>也可以说是平衡生产者和消费者执行速度上的差异</li><li>里面的获取任务和放入任务用到了<strong>生产者消费者模式</strong></li></ul></li><li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul><li>在调用任务的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li></ul></li><li>线程池中执行任务的主要方法为execute方法<ul><li>执行时要判断正在执行的线程数是否大于了线程池容量</li></ul></li></ul><h2 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20201022212832.png" alt="img"></a></p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 线程池状态</span><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-comment">// RUNNING 高3位为111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// SHUTDOWN 高3位为000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 001</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 010</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 011</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p><ul><li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 并不是所有平台的int都是32位。</span><br><span class="hljs-comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><br><span class="hljs-comment">// 高3位为0，剩余位数全为1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.<span class="hljs-keyword">SIZE</span> - <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span><br><span class="hljs-comment">// CAPACITY 的高3位为 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>获取线程池状态、线程数量以及合并两个值的操作</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// Packing and unpacking ctl</span><br><span class="hljs-comment">// 获取运行状态</span><br><span class="hljs-comment">// 该操作会让除高3位以外的数全部变为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><br><span class="hljs-comment">// 获取运行线程数</span><br><span class="hljs-comment">// 该操作会让高3位为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><br><span class="hljs-comment">// 计算ctl新值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;Copy<br></code></pre></td></tr></table></figure><h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Worker</span><br>        <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AbstractQueuedSynchronizer</span><br>        <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Runnable</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br><span class="hljs-comment">// 锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = new ReentrantLock();<br><br><span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();Copy<br></code></pre></td></tr></table></figure><h3 id="构造方法极其参数"><a href="#构造方法极其参数" class="headerlink" title="构造方法极其参数"></a>构造方法极其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p><p>也是构造自定义线程池的方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,<br>                          <span class="hljs-keyword">int</span> maximumPoolSize,<br>                          <span class="hljs-keyword">long</span> keepAliveTime,<br>                          TimeUnit unit,<br>                          BlockingQueue&lt;Runnable&gt; workQueue,<br>                          ThreadFactory threadFactory,<br>                          RejectedExecutionHandler <span class="hljs-keyword">handler</span>)Copy<br></code></pre></td></tr></table></figure><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数<ul><li>maximumPoolSize - corePoolSize &#x3D; 救急线程数</li></ul></li><li>keepAliveTime：救急线程空闲时的最大生存时间</li><li>unit：时间单位</li><li>workQueue：阻塞队列（存放任务）<ul><li>有界阻塞队列 ArrayBlockingQueue</li><li>无界阻塞队列 LinkedBlockingQueue</li><li>最多只有一个同步元素的 SynchronousQueue</li><li>优先队列 PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂（给线程取名字）</li><li>handler：拒绝策略</li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>当一个任务传给线程池以后，可能有以下几种可能<ul><li>将任务分配给一个核心线程来执行</li><li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li><li>阻塞队列满了，使用救急线程来执行任务<ul><li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li></ul></li><li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li></ul></li></ul><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png"><img src="/JAVA%E5%B9%B6%E5%8F%91.assets/20201022194718.png" alt="img"></a></p><ul><li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li><li>CallerRunsPolicy：让调用者运行任务</li><li>DiscardPolicy：放弃本次任务</li><li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 手动创建线程池</span><br>      <span class="hljs-comment">// 创建有界阻塞队列</span><br>      ArrayBlockingQueue&lt;Runnable&gt; runnable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">10</span>);<br>      <span class="hljs-comment">// 创建线程工厂</span><br>      <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;working_thread_&quot;</span>+threadId.getAndIncrement());<br>            <span class="hljs-keyword">return</span> thread;<br>         &#125;<br>      &#125;;<br><br>      <span class="hljs-comment">// 手动创建线程池</span><br>      <span class="hljs-comment">// 拒绝策略采用默认策略</span><br>      <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS, runnable, threadFactory);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>         executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>               System.out.println(Thread.currentThread());<br>               <span class="hljs-keyword">try</span> &#123;<br>                  Thread.sleep(<span class="hljs-number">100000</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>               &#125;<br>            &#125;<br>         &#125;);<br>      &#125;<br>   &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestFixedThreadPool &#123;<br>   public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>      <span class="hljs-comment">// 自定义线程工厂</span><br>      ThreadFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThreadFactory()</span> &#123;<br>         AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AtomicInteger(1)</span>;<br><br>         @Override<br>         public Thread <span class="hljs-keyword">new</span><span class="hljs-constructor">Thread(Runnable <span class="hljs-params">r</span>)</span> &#123;<br>            return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">r</span>, <span class="hljs-string">&quot;myThread_&quot;</span> + <span class="hljs-params">atomicInteger</span>.<span class="hljs-params">getAndIncrement</span>()</span>);<br>         &#125;<br>      &#125;;<br><br>      <span class="hljs-comment">// 创建核心线程数量为2的线程池</span><br>      <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span><br><br>      ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(2, <span class="hljs-params">factory</span>)</span>;<br><br>      <span class="hljs-comment">// 任务</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>         @Override<br>         public void run<span class="hljs-literal">()</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;this is fixedThreadPool&quot;</span>);<br>         &#125;<br>      &#125;;<br>      <br>      executorService.execute(runnable);<br>   &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>固定大小的线程池可以传入两个参数</p><ul><li>核心线程数：nThreads</li><li>线程工厂：threadFactory</li></ul><p>内部调用的构造方法</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ThreadPoolExecutor(nThreads, nThreads,<br><span class="hljs-built_in">                              0L,</span> TimeUnit.MILLISECONDS,<br>                              <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                              threadFactory)<span class="hljs-comment">;Copy</span><br></code></pre></td></tr></table></figure><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ExecutorService executorService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">CachedThreadPool()</span>;Copy<br></code></pre></td></tr></table></figure><p><strong>内部构造方法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ThreadPoolExecutor(<span class="hljs-number">0</span>, <span class="hljs-type">Integer</span>.MAX_VALUE,<br>                              <span class="hljs-number">60</span>L, TimeUnit.SECONDS,<br>                              <span class="hljs-built_in">new</span> SynchronousQueue&lt;Runnable&gt;());<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ul><li><p>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</p></li><li><p>阻塞队列使用的是SynchronousQueue</p><ul><li><p>SynchronousQueue</p><p>是一种特殊的队列</p><ul><li><strong>没有容量</strong>，没有线程来取是放不进去的</li><li>只有当线程取任务时，才会将任务放入该阻塞队列中</li></ul></li></ul></li></ul><h3 id="SingleThread"><a href="#SingleThread" class="headerlink" title="SingleThread"></a>SingleThread</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ExecutorService service = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">SingleThreadExecutor()</span>;Copy<br></code></pre></td></tr></table></figure><p><strong>内部构造方法</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type">FinalizableDelegatedExecutorService</span><br>    (<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                            <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));Copy<br></code></pre></td></tr></table></figure><p>内部调用了<strong>new ThreadPoolExecutor</strong>的构造方法，传入的corePoolSize和maximumPoolSize都为1。然后将该对象传给了FinalizableDelegatedExecutorService。该类修饰了ThreadPoolExecutor，让外部无法调用ThreadPoolExecutor内部的某些方法来修改所创建的线程池的大小。</p><h4 id="几个注意"><a href="#几个注意" class="headerlink" title="几个注意"></a>几个注意</h4><ul><li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p><ul><li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。</li></ul></li><li><p>SingleThread和newFixedThreadPool(1)的区别</p><ul><li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 强转为ThreadPoolExecutor</span><br>ThreadPoolExecutor threadPool = (ThreadPoolExecutor) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(1)</span>;<br><span class="hljs-comment">// 改变核心线程数</span><br>threadPool.set<span class="hljs-constructor">CorePoolSize(2)</span>;Copy<br></code></pre></td></tr></table></figure><ul><li>而SingleThread无法修改核心线程数</li></ul></li></ul><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span><span class="hljs-title">Copy</span></span><br></code></pre></td></tr></table></figure><p>传入一个Runnable对象，执行其中的run方法</p><p><strong>源码解析</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void execute(Runnable command) &#123;<br>    <span class="hljs-keyword">if</span> (command<span class="hljs-operator"> == </span>null)<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">NullPointerException()</span>;<br><br>    <span class="hljs-comment">// 获取ctl</span><br>    <span class="hljs-built_in">int</span> c = ctl.get<span class="hljs-literal">()</span>;<br>    <br>    <span class="hljs-comment">// 判断当前启用的线程数是否小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (worker<span class="hljs-constructor">CountOf(<span class="hljs-params">c</span>)</span> &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">// 为该任务分配线程</span><br>        <span class="hljs-keyword">if</span> (add<span class="hljs-constructor">Worker(<span class="hljs-params">command</span>, <span class="hljs-params">true</span>)</span>)<br>            <span class="hljs-comment">// 分配成功就返回</span><br>            return;<br>        <br>        <span class="hljs-comment">// 分配失败再次获取ctl</span><br>        c = ctl.get<span class="hljs-literal">()</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分配和信息线程失败以后</span><br>    <span class="hljs-comment">// 如果池状态为RUNNING并且插入到任务队列成功</span><br>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Running(<span class="hljs-params">c</span>)</span><span class="hljs-operator"> &amp;&amp; </span>workQueue.offer(command)) &#123;<br>        <br>        <span class="hljs-comment">// 双重检测，可能在添加后线程池状态变为了非RUNNING</span><br>        <span class="hljs-built_in">int</span> recheck = ctl.get<span class="hljs-literal">()</span>;<br>        <br>        <span class="hljs-comment">// 如果池状态为非RUNNING，则不会执行新来的任务</span><br>        <span class="hljs-comment">// 将该任务从阻塞队列中移除</span><br>        <span class="hljs-keyword">if</span> (! is<span class="hljs-constructor">Running(<span class="hljs-params">recheck</span>)</span><span class="hljs-operator"> &amp;&amp; </span>remove(command))<br>            <span class="hljs-comment">// 调用拒绝策略，拒绝该任务的执行</span><br>            reject(command);<br>        <br>        <span class="hljs-comment">// 如果没有正在运行的线程</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (worker<span class="hljs-constructor">CountOf(<span class="hljs-params">recheck</span>)</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 就创建新线程来执行该任务</span><br>            add<span class="hljs-constructor">Worker(<span class="hljs-params">null</span>, <span class="hljs-params">false</span>)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果添加失败了（任务队列已满），就调用拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!add<span class="hljs-constructor">Worker(<span class="hljs-params">command</span>, <span class="hljs-params">false</span>)</span>)<br>        reject(command);<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>其中调用了**addWoker()**方法，再看看看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">// 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-comment">// 创建新线程失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获得当前工作线程数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>            <span class="hljs-comment">// 参数中 core 为true</span><br>            <span class="hljs-comment">// CAPACITY 为 1 &lt;&lt; COUNT_BITS-1，一般不会超过</span><br>            <span class="hljs-comment">// 如果工作线程数大于了核心线程数，则创建失败</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 通过CAS操作改变c的值</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-comment">// 更改成功就跳出多重循环，且不再运行循环</span><br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 更改失败，重新获取ctl的值</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-comment">// 跳出多重循环，且重新进入循环</span><br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 用于标记work中的任务是否成功执行</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 用于标记worker是否成功加入了线程池中</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建新线程来执行任务</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            <span class="hljs-comment">// 加锁</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-comment">// 加锁的同时再次检测</span><br>                <span class="hljs-comment">// 避免在释放锁之前调用了shut down</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    <span class="hljs-comment">// 将线程添加到线程池中</span><br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    <span class="hljs-comment">// 添加成功标志位变为true</span><br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">// 如果worker成功加入了线程池，就执行其中的任务</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                <span class="hljs-comment">// 启动成功</span><br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果执行失败</span><br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            <span class="hljs-comment">// 调用添加失败的函数</span><br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Future<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> submit(Callable<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> task)Copy<br></code></pre></td></tr></table></figure><p>传入一个Callable对象，用Future来<strong>捕获返回值</strong></p><p><strong>使用</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 通过submit执行Callable中的call方法</span><br><span class="hljs-comment">// 通过Future来捕获返回值</span><br>Future&lt;<span class="hljs-type">String</span>&gt; future = threadPool.<span class="hljs-built_in">submit</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Callable</span>&lt;<span class="hljs-type">String</span>&gt;() &#123;<br>   @Override<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-built_in">call</span>() throws Exception &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello submit&quot;</span>;<br>   &#125;<br>&#125;);<br><br><span class="hljs-comment">// 查看捕获的返回值</span><br>System.out.<span class="hljs-built_in">println</span>(future.<span class="hljs-built_in">get</span>());Copy<br></code></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将线程池的状态改为 SHUTDOWN</span><br><span class="hljs-comment">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span><br><span class="hljs-comment">*/</span><br>public void shutdown<span class="hljs-literal">()</span> &#123;<br>    final ReentrantLock mainLock = this.mainLock;<br>    mainLock.lock<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        check<span class="hljs-constructor">ShutdownAccess()</span>;<br>        <br>        <span class="hljs-comment">// 修改线程池状态为 SHUTDOWN</span><br>        advance<span class="hljs-constructor">RunState(SHUTDOWN)</span>;<br>        <br>  <span class="hljs-comment">// 中断空闲线程（没有执行任务的线程）</span><br>        <span class="hljs-comment">// Idle：空闲的</span><br>        interrupt<span class="hljs-constructor">IdleWorkers()</span>;<br>        on<span class="hljs-constructor">Shutdown()</span>; <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>    &#125; finally &#123;<br>        mainLock.unlock<span class="hljs-literal">()</span>;<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结，不一定成功</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">try</span><span class="hljs-constructor">Terminate()</span>;<br>&#125;Copy<br>final void <span class="hljs-keyword">try</span><span class="hljs-constructor">Terminate()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-built_in">int</span> c = ctl.get<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">// 终结失败的条件</span><br>        <span class="hljs-comment">// 线程池状态为RUNNING</span><br>        <span class="hljs-comment">// 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span><br>        <span class="hljs-comment">// 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span><br>        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Running(<span class="hljs-params">c</span>)</span><span class="hljs-operator"> ||</span><br><span class="hljs-operator">            </span>run<span class="hljs-constructor">StateAtLeast(<span class="hljs-params">c</span>, TIDYING)</span><span class="hljs-operator"> ||</span><br><span class="hljs-operator">            </span>(run<span class="hljs-constructor">StateOf(<span class="hljs-params">c</span>)</span><span class="hljs-operator"> == </span>SHUTDOWN<span class="hljs-operator"> &amp;&amp; </span>! workQueue.is<span class="hljs-constructor">Empty()</span>))<br>            return;<br>        <br>        <span class="hljs-comment">// 如果活跃线程数不为0</span><br>        <span class="hljs-keyword">if</span> (worker<span class="hljs-constructor">CountOf(<span class="hljs-params">c</span>)</span> != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            <span class="hljs-comment">// 中断空闲线程</span><br>            interrupt<span class="hljs-constructor">IdleWorkers(ONLY_ONE)</span>;<br>            return;<br>        &#125;<br><br>        final ReentrantLock mainLock = this.mainLock;<br>        mainLock.lock<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 处于可以终结的状态</span><br>            <span class="hljs-comment">// 通过CAS将线程池状态改为TIDYING</span><br>            <span class="hljs-keyword">if</span> (ctl.compare<span class="hljs-constructor">AndSet(<span class="hljs-params">c</span>, <span class="hljs-params">ctlOf</span>(TIDYING, 0)</span>)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated<span class="hljs-literal">()</span>;<br>                &#125; finally &#123;<br>                    <span class="hljs-comment">// 通过CAS将线程池状态改为TERMINATED</span><br>                    ctl.set(ctl<span class="hljs-constructor">Of(TERMINATED, 0)</span>);<br>                    termination.signal<span class="hljs-constructor">All()</span>;<br>                &#125;<br>                return;<br>            &#125;<br>        &#125; finally &#123;<br>            mainLock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将线程池的状态改为 STOP</span><br><span class="hljs-comment">* 不再接受新任务，也不会在执行阻塞队列中的任务</span><br><span class="hljs-comment">* 会将阻塞队列中未执行的任务返回给调用者</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span>()</span> &#123;<br>    List&lt;Runnable&gt; tasks;<br>    final ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.<span class="hljs-keyword">lock</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <br>        <span class="hljs-comment">// 修改状态为STOP，不执行任何任务</span><br>        advanceRunState(STOP);<br>        <br>        <span class="hljs-comment">// 中断所有线程</span><br>        interruptWorkers();<br>        <br>        <span class="hljs-comment">// 将未执行的任务从队列中移除，然后返回给调用者</span><br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结，一定会成功，因为阻塞队列为空了</span><br>    tryTerminate();<br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2022/04/18/JVM/"/>
    <url>/2022/04/18/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p>本博客内容来自<a href="https://www.bilibili.com/video/BV1yE411Z7AP"><strong>解密JVM【黑马程序员出品】</strong></a></p><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>JVM JRE JDK的区别</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png"><img src="/JVM.assets/20200608150422.png" alt="img"></a></p><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="/JVM.assets/20200608150440.png" alt="img"></a></p><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>method1();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png"><img src="/JVM.assets/20200608150534.png" alt="img"></a></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png"><img src="/JVM.assets/20200608150547.png" alt="img"></a></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png"><img src="/JVM.assets/20200608150602.png" alt="img"></a></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">F</span>:\JAVA\JDK8<span class="hljs-number">.0</span>\bin&gt;javac <span class="hljs-name">F</span>:\Thread_study\src\com\nyima\JVM\day01\Main.javaCopy<br></code></pre></td></tr></table></figure><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">javap -v <span class="hljs-name">F</span>:\Thread_study\src\com\nyima\JVM\day01\Main.classCopy<br></code></pre></td></tr></table></figure></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png"><img src="/JVM.assets/20200608150618.png" alt="img"></a></p></li><li><p>常量池</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png"><img src="/JVM.assets/20200608150630.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png"><img src="/JVM.assets/20200608150641.png" alt="img"></a></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png"><img src="/JVM.assets/20200608150653.png" alt="img"></a></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">0</span>: ldc           <span class="hljs-comment">#2                  // String a</span><br><span class="hljs-attribute">2</span>: astore_1<br><span class="hljs-attribute">3</span>: ldc           <span class="hljs-comment">#3                  // String b</span><br><span class="hljs-attribute">5</span>: astore_2<br><span class="hljs-attribute">6</span>: ldc           <span class="hljs-comment">#4                  // String ab</span><br><span class="hljs-attribute">8</span>: astore_3<br><span class="hljs-attribute">9</span>: return<br></code></pre></td></tr></table></figure><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//拼接字符串对象来创建新的字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ab2</span> <span class="hljs-operator">=</span> a+b; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"> <span class="hljs-attr">Code:</span><br>      <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=5,</span> <span class="hljs-string">args_size=1</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  // String a</span><br>         <span class="hljs-attr">2:</span> <span class="hljs-string">astore_1</span><br>         <span class="hljs-attr">3:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#3                  // String b</span><br>         <span class="hljs-attr">5:</span> <span class="hljs-string">astore_2</span><br>         <span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#4                  // String ab</span><br>         <span class="hljs-attr">8:</span> <span class="hljs-string">astore_3</span><br>         <span class="hljs-attr">9:</span> <span class="hljs-string">new</span>           <span class="hljs-comment">#5                  // class java/lang/StringBuilder</span><br>        <span class="hljs-attr">12:</span> <span class="hljs-string">dup</span><br>        <span class="hljs-attr">13:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-attr">16:</span> <span class="hljs-string">aload_1</span><br>        <span class="hljs-attr">17:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br><span class="hljs-string">;)Ljava/lang/StringBuilder;</span><br>        <span class="hljs-attr">20:</span> <span class="hljs-string">aload_2</span><br>        <span class="hljs-attr">21:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br><span class="hljs-string">;)Ljava/lang/StringBuilder;</span><br>        <span class="hljs-attr">24:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br><span class="hljs-string">ing;</span><br>        <span class="hljs-attr">27:</span> <span class="hljs-string">astore</span>        <span class="hljs-number">4</span><br>        <span class="hljs-attr">29:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab2</span> <span class="hljs-operator">=</span> a+b;<br><span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br>System.out.println(ab == ab2);<br></code></pre></td></tr></table></figure><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTableStudy</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ab2</span> <span class="hljs-operator">=</span> a+b;<br><span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ab3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">   Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>         <span class="hljs-number">2</span>: astore_1<br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>         <span class="hljs-number">5</span>: astore_2<br>         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>         <span class="hljs-number">8</span>: astore_3<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>        <span class="hljs-number">12</span>: dup<br>        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">16</span>: aload_1<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">20</span>: aload_2<br>        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br>;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br>ing;<br>        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>        <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span><br>        <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span><br>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab &#x3D; “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">st2</span> <span class="hljs-operator">=</span> str.intern();<br><span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br>System.out.println(str == st2);<br>System.out.println(str == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.intern();<br>        <span class="hljs-comment">//false</span><br>System.out.println(str == str2);<br>        <span class="hljs-comment">//false</span><br>System.out.println(str == str3);<br>        <span class="hljs-comment">//true</span><br>System.out.println(str2 == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:StringTableSize=xxxx<br></code></pre></td></tr></table></figure></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png"><img src="/JVM.assets/20200608150715.png" alt="img"></a></p><p><strong>使用了DirectBuffer</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png"><img src="/JVM.assets/20200608150736.png" alt="img"></a></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(_1M);<br></code></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocateDirect</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectByteBuffer</span>(capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>DirectByteBuffer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-type">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-built_in">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> VM.isDirectMemoryPageAligned();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> Bits.pageSize();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-type">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span><br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-type">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deallocator</span>(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br>    att = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clean</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-built_in">this</span>)) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-built_in">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span><br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>                   <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-literal">null</span>) &#123;<br>                           (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                       &#125;<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                   &#125;<br>               &#125;);<br>           &#125;<br></code></pre></td></tr></table></figure><p>对应对象的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Paranoia</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span><br>    address = <span class="hljs-number">0</span>;<br>    Bits.unreserveMemory(size, capacity);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png"><img src="/JVM.assets/20200608150750.png" alt="img"></a></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png"><img src="/JVM.assets/20200608150800.png" alt="img"></a></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4M</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4M]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4M</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span><br>ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4M]);<br><br><span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span><br>Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br><span class="hljs-keyword">while</span>(poll != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span><br>list.remove(poll);<br><span class="hljs-comment">//移动到引用队列中的下一个元素</span><br>poll = queue.poll();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软&#x2F;弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png"><img src="/JVM.assets/20200608150813.png" alt="img"></a></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png"><img src="/JVM.assets/20200608150827.png" alt="img"></a></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png"><img src="/JVM.assets/20200608150842.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png"><img src="/JVM.assets/20200608150856.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png"><img src="/JVM.assets/20200608150907.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png"><img src="/JVM.assets/20200608150919.png" alt="img"></a></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png"><img src="/JVM.assets/20200608150931.png" alt="img"></a></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png"><img src="/JVM.assets/20200608150939.png" alt="img"></a></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png"><img src="/JVM.assets/20200608150946.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png"><img src="/JVM.assets/20200608150955.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png"><img src="/JVM.assets/20200608151002.png" alt="img"></a></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png"><img src="/JVM.assets/20200608151010.png" alt="img"></a></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png"><img src="/JVM.assets/20200608151018.png" alt="img"></a></p><p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><p><img src="/JVM.assets/image-20220418220923748.png" alt="常见的垃圾回收器"></p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png"><img src="/JVM.assets/20200608151027.png" alt="img"></a></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png"><img src="/JVM.assets/20200608151039.png" alt="img"></a></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png"><img src="/JVM.assets/20200608151052.png" alt="img"></a></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b&#x2F;s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png"><img src="/JVM.assets/20200909201212.png" alt="img"></a></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png"><img src="/JVM.assets/20200608151100.png" alt="img"></a></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png"><img src="/JVM.assets/20200608151109.png" alt="img"></a></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png"><img src="/JVM.assets/20200608151119.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png"><img src="/JVM.assets/20200608151129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png"><img src="/JVM.assets/20200608151140.png" alt="img"></a></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png"><img src="/JVM.assets/20200608151150.png" alt="img"></a></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png"><img src="/JVM.assets/20200608151201.png" alt="img"></a></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png"><img src="/JVM.assets/20200608151211.png" alt="img"></a></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png"><img src="/JVM.assets/20200608151222.png" alt="img"></a></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png"><img src="/JVM.assets/20200608151229.png" alt="img"></a></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png"><img src="/JVM.assets/20200608151239.png" alt="img"></a></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png"><img src="/JVM.assets/20200608151249.png" alt="img"></a></p><h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p>查看虚拟机参数命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;F:\JAVA\JDK8.0\bin\java&quot;</span> -XX:+PrintFlagsFinal -version | findstr <span class="hljs-string">&quot;GC&quot;</span><br></code></pre></td></tr></table></figure><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟&#x2F;高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png"><img src="/JVM.assets/20200608151300.png" alt="img"></a></p><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:…\XXX.java</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png"><img src="/JVM.assets/20200910155135.png" alt="img"></a></p><p>以下是字节码文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000</span> ca fe ba be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">34</span> <span class="hljs-number">00</span> <span class="hljs-number">23</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">09</span> <br><span class="hljs-attribute">0000020</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span> <span class="hljs-number">17</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">18</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>a <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">07</span> <br><span class="hljs-attribute">0000040</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>c <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">3</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">3</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span> <br><span class="hljs-attribute">0000060</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">43</span> <span class="hljs-number">6</span>f <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>f <span class="hljs-number">4</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">65</span> <span class="hljs-number">4</span>e <br><span class="hljs-attribute">0000100</span> <span class="hljs-number">75</span> <span class="hljs-number">6</span>d <span class="hljs-number">62</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>f <span class="hljs-number">63</span> <br><span class="hljs-attribute">0000120</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>c <span class="hljs-number">56</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <br><span class="hljs-attribute">0000140</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">69</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">4</span>c <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2</span>f <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">63</span> <br><span class="hljs-attribute">0000160</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2</span>f <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2</span>f <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6</span>f <br><span class="hljs-attribute">0000200</span> <span class="hljs-number">57</span> <span class="hljs-number">6</span>f <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <br><span class="hljs-attribute">0000220</span> <span class="hljs-number">28</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <br><span class="hljs-attribute">0000240</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">67</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <br><span class="hljs-attribute">0000260</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <br><span class="hljs-attribute">0000300</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">6</span>f <span class="hljs-number">64</span> <span class="hljs-number">50</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">61</span> <br><span class="hljs-attribute">0000320</span> <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">53</span> <span class="hljs-number">6</span>f <span class="hljs-number">75</span> <span class="hljs-number">72</span> <span class="hljs-number">63</span> <span class="hljs-number">65</span> <span class="hljs-number">46</span> <br><span class="hljs-attribute">0000340</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>f <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6</span>f <span class="hljs-number">57</span> <span class="hljs-number">6</span>f <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span><br><span class="hljs-attribute">0000360</span> <span class="hljs-number">2</span>e <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">1</span>e <br><span class="hljs-attribute">0000400</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>f <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6</span>f <span class="hljs-number">20</span> <span class="hljs-number">77</span> <span class="hljs-number">6</span>f <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <br><span class="hljs-attribute">0000420</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">20</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">22</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2</span>f <span class="hljs-number">69</span> <span class="hljs-number">74</span> <br><span class="hljs-attribute">0000440</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2</span>f <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2</span>f <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <br><span class="hljs-attribute">0000460</span> <span class="hljs-number">6</span>f <span class="hljs-number">57</span> <span class="hljs-number">6</span>f <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <br><span class="hljs-attribute">0000500</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">4</span>f <span class="hljs-number">62</span> <span class="hljs-number">6</span>a <span class="hljs-number">65</span> <span class="hljs-number">63</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <br><span class="hljs-attribute">0000520</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">53</span> <span class="hljs-number">79</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>d <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">6</span>f <br><span class="hljs-attribute">0000540</span> <span class="hljs-number">75</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">69</span> <span class="hljs-number">6</span>f <span class="hljs-number">2</span>f <span class="hljs-number">50</span> <span class="hljs-number">72</span> <br><span class="hljs-attribute">0000560</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <br><span class="hljs-attribute">0000600</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">69</span> <span class="hljs-number">6</span>f <span class="hljs-number">2</span>f <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <br><span class="hljs-attribute">0000620</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">70</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">28</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <br><span class="hljs-attribute">0000640</span> <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2</span>f <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2</span>f <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <br><span class="hljs-attribute">0000660</span> <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <br><span class="hljs-attribute">0000700</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">2</span>f <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <br><span class="hljs-attribute">0000720</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">2</span>a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <br><span class="hljs-attribute">0000740</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <br><span class="hljs-attribute">0000760</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <br><span class="hljs-attribute">0001000</span> <span class="hljs-number">0</span>f <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">37</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">0001020</span> <span class="hljs-number">09</span> b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <br><span class="hljs-attribute">0001040</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <br><span class="hljs-attribute">0001060</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">0001100</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">0001120</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">u4  magic<br>u2             minor_version<span class="hljs-comment">;    </span><br>u2             major_version<span class="hljs-comment">;    </span><br>u2             constant_pool_count<span class="hljs-comment">;    </span><br>cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>]<span class="hljs-comment">;    </span><br>u2             access_flags<span class="hljs-comment">;    </span><br>u2             this_class<span class="hljs-comment">;    </span><br>u2             super_class<span class="hljs-comment">;   </span><br>u2             interfaces_count<span class="hljs-comment">;    </span><br>u2             interfaces[interfaces_count]<span class="hljs-comment">;   </span><br>u2             fields_count<span class="hljs-comment">;    </span><br>field_info     fields[fields_count]<span class="hljs-comment">;   </span><br>u2             methods_count<span class="hljs-comment">;    </span><br>method_info    methods[methods_count]<span class="hljs-comment">;    </span><br>u2             attributes_count<span class="hljs-comment">;    </span><br>attribute_info attributes[attributes_count]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic</p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2 minor_version;</p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><p>34H &#x3D; 52，代表JDK8</p><h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件</p><p>…略</p><h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopy<br>F:\Thread_study&gt;javap -v F:\Thread_study\src\com\nyima\JVM\day5\Demo1.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">Classfile</span> /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">6</span>-<span class="hljs-number">6</span>; size <span class="hljs-number">434</span> bytes<br>  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e<br>  Compiled from <span class="hljs-string">&quot;Demo1.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.nyima.JVM.day5.Demo1<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">15</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">16.</span>#<span class="hljs-number">17</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">3</span> = String             #<span class="hljs-number">18</span>            <span class="hljs-comment">// hello world</span><br>   #<span class="hljs-number">4</span> = Methodref          #<span class="hljs-number">19.</span>#<span class="hljs-number">20</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">21</span>            <span class="hljs-comment">// com/nyima/JVM/day5/Demo1</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">22</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               main<br>  #<span class="hljs-number">12</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">13</span> = Utf8               SourceFile<br>  #<span class="hljs-number">14</span> = Utf8               Demo1.java<br>  #<span class="hljs-number">15</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">16</span> = Class              #<span class="hljs-number">23</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">17</span> = NameAndType        #<span class="hljs-number">24</span>:#<span class="hljs-number">25</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">18</span> = Utf8               hello world<br>  #<span class="hljs-number">19</span> = Class              #<span class="hljs-number">26</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">20</span> = NameAndType        #<span class="hljs-number">27</span>:#<span class="hljs-number">28</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">21</span> = Utf8               com/nyima/JVM/day5/Demo1<br>  #<span class="hljs-number">22</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">23</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">24</span> = Utf8               out<br>  #<span class="hljs-number">25</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">26</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">27</span> = Utf8               println<br>  #<span class="hljs-number">28</span> = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  <span class="hljs-keyword">public</span> com.nyima.JVM.day5.Demo1();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String hello world</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_1</span> &#123;    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        <br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Short.MAX_VALUE + <span class="hljs-number">1</span>;        <br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;        <br>System.out.println(c);   <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png"><img src="/JVM.assets/20200608151317.png" alt="img"></a></p><p><strong>方法字节码载入方法区</strong></p><p>（stack&#x3D;2，locals&#x3D;4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png"><img src="/JVM.assets/20200608151325.png" alt="img"></a></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><p>将一个 byte 压入操作数栈</p><p>（其长度会补齐 4 个字节），类似的指令还有</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png"><img src="/JVM.assets/20200608151336.png" alt="img"></a></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>Copy<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png"><img src="/JVM.assets/20200608151346.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png"><img src="/JVM.assets/20200608151412.png" alt="img"></a></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png"><img src="/JVM.assets/20200608151421.png" alt="img"></a></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png"><img src="/JVM.assets/20200608151432.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png"><img src="/JVM.assets/20200608151441.png" alt="img"></a></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png"><img src="/JVM.assets/20200608151450.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png"><img src="/JVM.assets/20200608151459.png" alt="img"></a></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png"><img src="/JVM.assets/20200608151508.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png"><img src="/JVM.assets/20200608151523.png" alt="img"></a></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png"><img src="/JVM.assets/20200608151547.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png"><img src="/JVM.assets/20200608151555.png" alt="img"></a></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png"><img src="/JVM.assets/20200608151605.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png"><img src="/JVM.assets/20200608151613.png" alt="img"></a></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png"><img src="/JVM.assets/20200608151624.png" alt="img"></a></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java&#x2F;io&#x2F;PrintStream.println:(I)V 方法</p><p>生成新的栈帧（分配 locals、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png"><img src="/JVM.assets/20200608151632.png" alt="img"></a></p><p>执行完毕，弹出栈帧</p><p>清除 main 操作数栈内容</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png"><img src="/JVM.assets/20200608151640.png" alt="img"></a></p><p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;<br>x = x++;<br>i++;<br>&#125;<br>System.out.println(x); <span class="hljs-comment">//接过为0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><span class="hljs-comment">//操作数栈分配2个空间，局部变量表分配3个空间</span><br>        <span class="hljs-number">0</span>: iconst_0<span class="hljs-comment">//准备一个常数0</span><br>        <span class="hljs-number">1</span>: istore_1<span class="hljs-comment">//将常数0放入局部变量表的1号槽位 i=0</span><br>        <span class="hljs-number">2</span>: iconst_0<span class="hljs-comment">//准备一个常数0</span><br>        <span class="hljs-number">3</span>: istore_2<span class="hljs-comment">//将常数0放入局部变量的2号槽位 x=0</span><br>        <span class="hljs-number">4</span>: iload_1<span class="hljs-comment">//将局部变量表1号槽位的数放入操作数栈中</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><span class="hljs-comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span><br>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span><span class="hljs-comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span><br>       <span class="hljs-number">10</span>: iload_2<span class="hljs-comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span><br>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span><span class="hljs-comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span><br>       <span class="hljs-number">14</span>: istore_2<span class="hljs-comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span><br>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//1号槽位的值自增1</span><br>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">//跳转到第4条指令</span><br>       <span class="hljs-number">21</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">24</span>: iload_2<br>       <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(i); <span class="hljs-comment">//结果为30</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">stack=1,</span> <span class="hljs-string">locals=0,</span> <span class="hljs-string">args_size=0</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">10</span><br>         <span class="hljs-attr">2:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>         <span class="hljs-attr">5:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">20</span><br>         <span class="hljs-attr">7:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">10:</span> <span class="hljs-string">bipush</span>        <span class="hljs-number">30</span><br>        <span class="hljs-attr">12:</span> <span class="hljs-string">putstatic</span>     <span class="hljs-comment">#3                  // Field i:I</span><br>        <span class="hljs-attr">15:</span> <span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> a = <span class="hljs-string">&quot;s1&quot;</span>;<br><br>&#123;<br>b = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>&#123;<br>a = <span class="hljs-string">&quot;s2&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(<span class="hljs-type">String</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.a = a;<br><span class="hljs-keyword">this</span>.b = b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>Demo4 d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Demo4</span>(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);<br>System.out.<span class="hljs-built_in">println</span>(d.a);<br>System.out.<span class="hljs-built_in">println</span>(d.b);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>        <span class="hljs-number">0</span>: aload_0<br>        <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">4</span>: aload_0<br>        <span class="hljs-number">5</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String s1</span><br>        <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span><br>       <span class="hljs-number">10</span>: aload_0<br>       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">13</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span><br>       <span class="hljs-number">16</span>: aload_0<br>       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span><br>       <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span><br>       <span class="hljs-number">22</span>: aload_0<br>       <span class="hljs-number">23</span>: ldc           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// String s2</span><br>       <span class="hljs-number">25</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span><br>       <span class="hljs-comment">//原始构造方法在最后执行</span><br>       <span class="hljs-number">28</span>: aload_0<br>       <span class="hljs-number">29</span>: aload_1<br>       <span class="hljs-number">30</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span><br>       <span class="hljs-number">33</span>: aload_0<br>       <span class="hljs-number">34</span>: iload_2<br>       <span class="hljs-number">35</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span><br>       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo5</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Demo5</span> <span class="hljs-variable">demo5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo5</span>();<br>demo5.test1();<br>demo5.test2();<br>demo5.test3();<br>Demo5.test4();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/nyima/JVM/day5/Demo5 </span><br>         <span class="hljs-number">3</span>: dup<br>         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">7</span>: astore_1<br>         <span class="hljs-number">8</span>: aload_1<br>         <span class="hljs-number">9</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method test1:()V</span><br>        <span class="hljs-number">12</span>: aload_1<br>        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method test2:()V</span><br>        <span class="hljs-number">16</span>: aload_1<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method test3:()V</span><br>        <span class="hljs-number">20</span>: invokestatic  #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method test4:()V</span><br>        <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span><br>        <span class="hljs-number">8</span>: astore_2<br>        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">11</span>: istore_1<br>       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span><br>     <span class="hljs-comment">//多出来一个异常表</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-number">5</span>: goto          <span class="hljs-number">19</span><br>        <span class="hljs-number">8</span>: astore_2<br>        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">11</span>: istore_1<br>       <span class="hljs-number">12</span>: goto          <span class="hljs-number">19</span><br>       <span class="hljs-number">15</span>: astore_2<br>       <span class="hljs-number">16</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">18</span>: istore_1<br>       <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-comment">//try块</span><br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-comment">//try块执行完后，会执行finally    </span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span><br>        <span class="hljs-number">7</span>: istore_1<br>        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span><br>       <span class="hljs-comment">//catch块     </span><br>       <span class="hljs-number">11</span>: astore_2 <span class="hljs-comment">//异常信息放入局部变量表的2号槽位</span><br>       <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">14</span>: istore_1<br>       <span class="hljs-comment">//catch块执行完后，会执行finally        </span><br>       <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">17</span>: istore_1<br>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span><br>       <span class="hljs-comment">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span><br>       <span class="hljs-number">21</span>: astore_3<br>       <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">24</span>: istore_1<br>       <span class="hljs-number">25</span>: aload_3<br>       <span class="hljs-number">26</span>: athrow  <span class="hljs-comment">//抛出异常</span><br>       <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">11</span>   Class java/lang/Exception<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">21</span>   any<br>           <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>   any<br></code></pre></td></tr></table></figure><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Demo3.test();<br>        <span class="hljs-comment">//结果为20</span><br>System.out.println(i);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">try</span> &#123;<br>i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_0<br>        <span class="hljs-number">3</span>: iload_0<br>        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">//暂存返回值</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-number">7</span>: istore_0<br>        <span class="hljs-number">8</span>: iload_0<br>        <span class="hljs-number">9</span>: ireturn<span class="hljs-comment">//ireturn会返回操作数栈顶的整型值20</span><br>       <span class="hljs-comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span><br>       <span class="hljs-number">10</span>: astore_2<br>       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">13</span>: istore_0<br>       <span class="hljs-number">14</span>: iload_0<br>       <span class="hljs-number">15</span>: ireturn<span class="hljs-comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any<br></code></pre></td></tr></table></figure><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Demo3.test();<br>      <span class="hljs-comment">//最终结果为20</span><br>      System.out.println(i);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> i;<br>      <span class="hljs-keyword">try</span> &#123;<br>         i = <span class="hljs-number">10</span>;<br>         <span class="hljs-comment">//这里应该会抛出异常</span><br>         i = i/<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         i = <span class="hljs-number">20</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Demo4.test();<br>System.out.println(i);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_0 <span class="hljs-regexp">//</span>赋值给i <span class="hljs-number">10</span><br>        <span class="hljs-number">3</span>: iload_0<span class="hljs-regexp">//</span>加载到操作数栈顶<br>        <span class="hljs-number">4</span>: istore_1 <span class="hljs-regexp">//</span>加载到局部变量表的<span class="hljs-number">1</span>号位置<br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-number">7</span>: istore_0 <span class="hljs-regexp">//</span>赋值给i <span class="hljs-number">20</span><br>        <span class="hljs-number">8</span>: iload_1 <span class="hljs-regexp">//</span>加载局部变量表<span class="hljs-number">1</span>号位置的数<span class="hljs-number">10</span>到操作数栈<br>        <span class="hljs-number">9</span>: ireturn <span class="hljs-regexp">//</span>返回操作数栈顶元素 <span class="hljs-number">10</span><br>       <span class="hljs-number">10</span>: astore_2<br>       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">13</span>: istore_0<br>       <span class="hljs-number">14</span>: aload_2 <span class="hljs-regexp">//</span>加载异常<br>       <span class="hljs-number">15</span>: athrow <span class="hljs-regexp">//</span>抛出异常<br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any<br></code></pre></td></tr></table></figure><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lock</span>();<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>System.out.println(i);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_1<br>        <span class="hljs-number">3</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/nyima/JVM/day06/Lock</span><br>        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span><br>        <span class="hljs-number">7</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span><br>       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span><br>       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span><br>       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span><br>       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span><br>       <span class="hljs-comment">//锁住后代码块中的操作    </span><br>       <span class="hljs-number">15</span>: getstatic     #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">18</span>: iload_1<br>       <span class="hljs-number">19</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span><br>       <span class="hljs-number">22</span>: aload_3    <br>       <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span><br>       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span><br>       <span class="hljs-comment">//异常操作    </span><br>       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>       <span class="hljs-number">29</span>: aload_3<br>       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span><br>       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span><br>       <span class="hljs-number">33</span>: athrow<br>       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span><br>     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span><br>     Exception table:<br>        from    to  target type<br>           <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any<br>           <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any<br></code></pre></td></tr></table></figure><h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy1</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>经过编译期优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy1</span> &#123;<br>   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy1</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br>      <span class="hljs-built_in">super</span>();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换过程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span><br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x.intValue();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      list.add(<span class="hljs-number">10</span>);<br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/util/ArrayList</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: aload_1<br>       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span><br>      <span class="hljs-number">11</span>: invokestatic  #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span><br>      <span class="hljs-number">14</span>: invokeinterface #<span class="hljs-number">5</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><br>      <span class="hljs-number">19</span>: pop<br>      <span class="hljs-number">20</span>: aload_1<br>      <span class="hljs-number">21</span>: iconst_0<br>      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span><br>      <span class="hljs-number">22</span>: invokeinterface #<span class="hljs-number">6</span>,  <span class="hljs-number">2</span>            <span class="hljs-comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span><br>      <span class="hljs-number">27</span>: checkcast     #<span class="hljs-number">7</span>                  <span class="hljs-comment">// class java/lang/Integer</span><br>      <span class="hljs-number">30</span>: astore_2<br>      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>所以调用get函数取值时，有一个类型转换的操作</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Integer</span> x = (<span class="hljs-type">Integer</span>) list.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> x = (<span class="hljs-type">Integer</span>) list.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>).intValue();<br></code></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String... args)</span> &#123;<br>      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br>   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;<br><br>    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String[] args)</span> &#123;<br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      foo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : arr) &#123;<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会帮我们转换为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> arr[i];<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果是集合使用foreach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-keyword">for</span> (Integer x : list) &#123;<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<br>    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-comment">//获得该集合的迭代器</span><br>      Iterator&lt;Integer&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> iterator.next();<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo6</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">switch</span> (str) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译器中执行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo6</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo6</span><span class="hljs-params">()</span> &#123;<br>      <br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span><br>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;<br>         <span class="hljs-comment">//hello的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span><br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>               x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">//world的hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;<br>               x = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">//用第二个switch在进行输出判断</span><br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo7</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">SEX</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) &#123;<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SEX</span> &#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器中执行的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo7</span> &#123;<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">$MAP</span> &#123;<br>      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">SEX</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> SEX.MALE;<br>      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SEX</span> &#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SEX</span> &#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span>&lt;Sex&gt; &#123;   <br>   <span class="hljs-comment">//对应枚举类中的元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br>   <br>    <span class="hljs-keyword">static</span> &#123;       <br>    <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span><br>    MALE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sex</span>(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sex</span>(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sex</span>[]&#123;MALE, FEMALE&#125;; <br>   &#125;<br> <br>   <span class="hljs-comment">//调用父类中的方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sex</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> ordinal)</span> &#123;     <br>        <span class="hljs-built_in">super</span>(name, ordinal);    <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title function_">valueOf</span><span class="hljs-params">(String name)</span> &#123; <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    &#125; <br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo8</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo8</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span><br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo8$1</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo8$1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果匿名内部类中引用了<strong>局部变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo8</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转化后代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo8</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(x);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo8$1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>   <span class="hljs-comment">//多创建了一个变量</span><br>   <span class="hljs-type">int</span> val$x;<br>   <span class="hljs-comment">//变为了有参构造器</span><br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>(<span class="hljs-type">int</span> x) &#123;<br>      <span class="hljs-built_in">this</span>.val$x = x;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(val$x);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li><p>将类的字节码载入</p><p>方法区</p><p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png"><img src="/JVM.assets/20200611205050.png" alt="img"></a></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span><br></code></pre></td></tr></table></figure><ul><li>打开HSDB</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java -cp F:\JAVA\JDK8.<span class="hljs-number">0</span>\lib\sa-jdi<span class="hljs-selector-class">.jar</span> sun<span class="hljs-selector-class">.jvm</span><span class="hljs-selector-class">.hotspot</span>.HSDB<br></code></pre></td></tr></table></figure><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png"><img src="/JVM.assets/20200611221703.png" alt="img"></a></p><ul><li>定位需要的进程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png"><img src="/JVM.assets/20200611221857.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png"><img src="/JVM.assets/20200611222029.png" alt="img"></a></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>      <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> Demo1.class.getClassLoader();<br>      <span class="hljs-comment">//只加载不解析</span><br>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">&quot;com.nyima.JVM.day8.C&quot;</span>);<br>      <span class="hljs-comment">//用于阻塞主线程</span><br>      System.in.read();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;<br>   <span class="hljs-type">D</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">D</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png"><img src="/JVM.assets/20200611223153.png" alt="img"></a></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png"><img src="/JVM.assets/20200611230658.png" alt="img"></a></p><ul><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p><ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png"><img src="/JVM.assets/20200611223441.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png"><img src="/JVM.assets/20200613104723.png" alt="img"></a></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png"><img src="/JVM.assets/20201118204542.png" alt="img"></a></p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">//如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//看是否被启动类加载器加载过</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 记录时间</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// to do something  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add4</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> x4)</span> &#123; <br><span class="hljs-comment">//这里调用了add2方法</span><br>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  <br>    &#125;  <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add2</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2)</span> &#123;  <br>        <span class="hljs-keyword">return</span> x1 + x2;  <br>    &#125;<br></code></pre></td></tr></table></figure><p>方法调用被替换后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add4</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> x4)</span> &#123;  <br>    <span class="hljs-comment">//被替换为了方法本身</span><br>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  <br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflect1</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;<br>      <span class="hljs-type">Method</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;<br>         foo.invoke(<span class="hljs-literal">null</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object... args)</span><br>    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,<br>       InvocationTargetException<br>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br>    <span class="hljs-type">MethodAccessor</span> <span class="hljs-variable">ma</span> <span class="hljs-operator">=</span> methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-literal">null</span>) &#123;<br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png"><img src="/JVM.assets/20200614133554.png" alt="img"></a></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodAccessorImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numInvocations;<br><br>    NativeMethodAccessorImpl(Method var1) &#123;<br>        <span class="hljs-built_in">this</span>.method = var1;<br>    &#125;<br><br><span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br><span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException &#123;<br>        <span class="hljs-keyword">if</span> (++<span class="hljs-built_in">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-built_in">this</span>.method.getDeclaringClass())) &#123;<br>            <span class="hljs-type">MethodAccessorImpl</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> (MethodAccessorImpl)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAccessorGenerator</span>()).generateMethod(<span class="hljs-built_in">this</span>.method.getDeclaringClass(), <span class="hljs-built_in">this</span>.method.getName(), <span class="hljs-built_in">this</span>.method.getParameterTypes(), <span class="hljs-built_in">this</span>.method.getReturnType(), <span class="hljs-built_in">this</span>.method.getExceptionTypes(), <span class="hljs-built_in">this</span>.method.getModifiers());<br>            <span class="hljs-built_in">this</span>.parent.setDelegate(var3);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-built_in">this</span>.method, var1, var2);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = var1;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span>;<br>&#125;<br><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">inflationThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png"><img src="/JVM.assets/20200614135011.png" alt="img"></a></p><h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>见JAVA并发</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试攻略</title>
    <link href="/2022/04/18/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/04/18/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、代码篇"><a href="#一、代码篇" class="headerlink" title="一、代码篇"></a>一、代码篇</h2><h3 id="实现hashmap"><a href="#实现hashmap" class="headerlink" title="实现hashmap"></a><strong>实现hashmap</strong></h3><blockquote><p>简单的模拟，无负载因子，无扩容，无红黑树，无收缩。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span>&lt;K,V&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] table;<br><br>    MyHashMap(<span class="hljs-type">int</span> capacity)&#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[capacity];<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;&#123;<br>        K key;<br>        V value;<br>        Node&lt;K,V&gt; next;<br>        Node(K key, V value)&#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(K key)</span>&#123;<br>        <span class="hljs-keyword">return</span> key.hashCode() % (capacity-<span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loc</span> <span class="hljs-operator">=</span> hash(key);<br>        Node&lt;K,V&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(key, value);<br>        <span class="hljs-keyword">if</span> (table[loc] != <span class="hljs-literal">null</span>) &#123;<br>            Node&lt;K,V&gt; head = table[loc];<br>            <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(head.key.equals(key))&#123;<br>                    head.value = value;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                head = head.next;<br>            &#125;<br>            node.next = table[loc];<br>            table[loc] = node;<br>        &#125;<br>        table[loc] = node;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loc</span> <span class="hljs-operator">=</span> hash(key);<br>        <span class="hljs-keyword">if</span>(table[loc] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Node&lt;K,V&gt; head = table[loc];<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.key.equals(key))<br>                <span class="hljs-keyword">return</span> head.value;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        MyHashMap&lt;Integer,Integer&gt; map =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHashMap</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>        map.put(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>        map.put(<span class="hljs-number">100</span>, <span class="hljs-number">110</span>);<br>        System.out.println(map.get(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现LRU"><a href="#实现LRU" class="headerlink" title="实现LRU"></a><strong>实现LRU</strong></h3><blockquote><p>双链表+HashMap</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> key,val;<br>    Node prev,next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer,Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Node head, tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.get(key) != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            node.prev.next = node.next;<br>            node.next.prev = node.prev;<br>            move(node);<br>            <span class="hljs-keyword">return</span> node.val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(get(key) &gt; -<span class="hljs-number">1</span>)&#123;<br>            map.get(key).val = value;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(map.size() == capacity)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">rk</span> <span class="hljs-operator">=</span> tail.prev.key;<br>                tail.prev.prev.next = tail;<br>                tail.prev = tail.prev.prev;<br>                map.remove(rk);<br>            &#125;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value);<br>            map.put(key,node);<br>            move(node);<br>        &#125;<br>            <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>        node.prev = head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、网络篇"><a href="#二、网络篇" class="headerlink" title="二、网络篇"></a>二、网络篇</h2><h3 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a><strong>知识架构</strong></h3><blockquote><p>软件开发类学生，重要关注点在于网络及以上的层次，尤其是<strong>传输层</strong>！</p></blockquote><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418143249901.png" alt="物理层"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418143337575.png" alt="数据链路层"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418143125621.png" alt="网络层"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418143020528.png" alt="传输层"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418143203014.png" alt="应用层"></p><h3 id="1-GET-和-POST有什么区别？"><a href="#1-GET-和-POST有什么区别？" class="headerlink" title="1.GET 和 POST有什么区别？"></a><strong>1.GET 和 POST有什么区别？</strong></h3><table><thead><tr><th align="left">区别</th><th align="center">GET</th><th align="center">POST</th></tr></thead><tbody><tr><td align="left">传输方式</td><td align="center">从服务器获取数据</td><td align="center">向服务器提交数据</td></tr><tr><td align="left">数据长度</td><td align="center">当发送数据时，GET 方法向 URL 添加数据；有长度限制</td><td align="center">无限制</td></tr><tr><td align="left">数据类型</td><td align="center">只允许 ASCII 字符</td><td align="center">无限制</td></tr><tr><td align="left">安全性</td><td align="center">较差，所发送的数据是 URL 的一部分，会显示在网页上</td><td align="center">较好 参数不会被保存在浏览器历史或 WEB 服务器日志中</td></tr><tr><td align="left">可见性</td><td align="center">显示在 URL 上</td><td align="center">不显示</td></tr><tr><td align="left">收藏为书签</td><td align="center">可以</td><td align="center">不可以</td></tr><tr><td align="left">历史记录</td><td align="center">可以被保留在历史记录当中</td><td align="center">不可以被保留</td></tr><tr><td align="left">缓存</td><td align="center">能被缓存</td><td align="center">不可以被缓存</td></tr></tbody></table><h3 id="2-TCP和UDP有什么区别"><a href="#2-TCP和UDP有什么区别" class="headerlink" title="2.TCP和UDP有什么区别?"></a>2.<strong>TCP和UDP有什么区别?</strong></h3><p>UDP是用户数据报协议，是一个简单的面向无连接的协议。UDP不提供可靠的服务。在数据数据前不用建立连接故而传输速度很快。UDP主要用户流媒体传输，IP电话等对数据可靠性要求不是很高的场合。传输方式为整个报文段。</p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418135510214.png" alt="UDP数据报结构"></p><p>TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。通信双方彼此交换数据前，必须先通过三次握手协议建立连接，之后才能传输数据。TCP提供超时重传，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。传输方式采用字节流，大小由MSS字段控制(选项字段中)。</p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418135953339.png" alt="TCP报文段结构"></p><p><strong>TCP的可靠传输</strong></p><p>序号+确认号+重传(超时，冗余确认)</p><p><strong>TCP的流量控制</strong></p><p>滑动窗口协议</p><ul><li>后退N帧协议(GBN)：接收方只允许顺序接收帧</li><li>选择重传协议(SR)：每一个发送缓冲区都需要一个计算器，接收方允许错序接收帧</li></ul><p><strong>TCP的拥塞控制</strong></p><p>慢开始算法(乘法增大)+拥塞避免算法(加法增大)+快重传(三次冗余ack)+快恢复(折半开始)</p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418141601871.png" alt="拥塞控制过程"></p><h3 id="3-TCP三次握手和四次挥手"><a href="#3-TCP三次握手和四次挥手" class="headerlink" title="3.TCP三次握手和四次挥手?"></a>3.<strong>TCP三次握手和四次挥手</strong>?</h3><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418135059540.png" alt="TCP三次握手建立阶段"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418135253642.png" alt="TCP四次挥手释放阶段"></p><h3 id="4-为什么TCP不使用固定的初始序号"><a href="#4-为什么TCP不使用固定的初始序号" class="headerlink" title="4.为什么TCP不使用固定的初始序号?"></a><strong>4.为什么TCP不使用固定的初始序号?</strong></h3><p>1)假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。</p><p>2)假定每次建立连接时，主机A都选择相同的、固定的初始序号，如选择1。</p><p>3)假定主机A发出的某些TCP报文段在网络中会滞留较长时间，以致主机A超时重传这些TCP报文段。</p><p>4)假定有一些在网络中滞留时间较长的TCP报文段最后终于到达主机B,但这时传送该报文段的那个连接早已释放，而在到达主机B时的TCP连接是一条新的TCP连接。</p><p>这样，工作在新的TCP连接的主机B就有可能会接收在旧的连接传送的、已无意义的、过时的TCP报文段(因为这个TCP报文段的序号有可能正好处在当前新连接所用的序号范围之中)，结果产生错误。</p><h3 id="5-为什么不两次握手-建立连接呢"><a href="#5-为什么不两次握手-建立连接呢" class="headerlink" title="5.为什么不两次握手 建立连接呢?"></a><strong>5.为什么不两次握手 建立连接呢?</strong></h3><p>这主要是为了防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错误。考虑下面这种情况。客户A向服务器B发出TCP连接请求，第一个连接请求报文在网络的某个结点长时间滞留，A超时后认为报文丢失，于是再重传一次连接请求，B收到后建立连接。数据传输完毕后双方断开连接。而此时，前一个滞留在网络中的连接请求到达服务器B，而B认为A又发来连接请求，此时若使用“三次握手”，则B向A返回确认报文段，由于是一个失效的请求，因此A不予理睬，建立连接失败。若采用的是“两次握手”，则这种情况下B认为传输连接已经建立，并一直等待A传输数据，而A此时并无连接请求，因此不予理睬，这样就造成了B的资源白白浪费。</p><h3 id="6-为何四次握手释放连接，等待2MSL的时间呢"><a href="#6-为何四次握手释放连接，等待2MSL的时间呢" class="headerlink" title="6.为何四次握手释放连接，等待2MSL的时间呢?"></a><strong>6.为何四次握手释放连接，等待2MSL的时间呢?</strong></h3><p>原因有两个:</p><ul><li>保证A发送的最后-一个确认报文段能够到达B。如果A不等待2MSL，若A返回的最后确认报文段丢失，则B不能进入正常关闭状态，而A此时已经关闭，也不可能再重传。</li><li>防止出现“已失效的连接请求报文段”。A在发送最后一个确认报文段后，再经过2MSL可保证本连接持续的时间内所产生的所有报文段从网络中消失。造成错误的情形与不采用“两次握手”建立连接所述的情形相同。注意:服务器结束TCP连接的时间要比客户机早一些，因为客户机最后要等待2MSL后才可进入CLOSED状态。</li></ul><h3 id="7-浏览器输入URL到得到结果的过程"><a href="#7-浏览器输入URL到得到结果的过程" class="headerlink" title="7.浏览器输入URL到得到结果的过程?"></a><strong>7.浏览器输入URL到得到结果的过程?</strong></h3><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418205337659.png" alt="浏览器URL访问网页"></p><ul><li><strong>解析网址</strong>,生成 HTTP 请求信息</li><li><strong>查IP</strong>，浏览器缓存 &gt; 本机缓存 &gt; hosts⽂件 &gt; 路由器缓存 &gt; ISP DNS缓存 &gt; DNS递归迭代查询</li><li><strong>发送请求</strong>，得到了 IP 以后，向服务器<strong>发送 TCP 连接</strong>，TCP 连接经过三次握手。</li><li><strong>服务器处理</strong>，接受 TCP 报文后，对<strong>连接进行处理</strong>，对 HTTP 协议解析</li><li><strong>服务器返回响应</strong></li><li><strong>展示</strong>浏览器接受响应，显示页面，渲染页面</li></ul><p><strong>状态码1xx-5xx</strong></p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1xx</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2xx</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3xx</td><td align="left">重定向，需要进一步的操作以完成请求<br />302 Found 一般是普通的重定向需求：临时跳转</td></tr><tr><td align="left">4xx</td><td align="left">客户端错误，请求包含语法错误或无法完成请求<br />403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求<br />404 Not Found 服务器无法根据客户端的请求找到资源</td></tr><tr><td align="left">5xx</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误<br />500 Internal Server Error 服务器内部错误，无法完成请求<br />502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应<br />503 Service Unavailabl 由于超载或系统维护，服务器暂时的无法处理客户端的请求。<br />504 Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr></tbody></table><h3 id="8-HTTPS握手过程"><a href="#8-HTTPS握手过程" class="headerlink" title="8.HTTPS握手过程?"></a><strong>8.HTTPS握手过程?</strong></h3><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418113846647.png" alt="https=http+ssl/tsl"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418113711794.png" alt="Https握手"></p><h3 id="9-HTTP版本发展？"><a href="#9-HTTP版本发展？" class="headerlink" title="9.HTTP版本发展？"></a><strong>9.HTTP版本发展？</strong></h3><h4 id="HTTP1-1-和-HTTP1-0-的区别有哪些？"><a href="#HTTP1-1-和-HTTP1-0-的区别有哪些？" class="headerlink" title="HTTP1.1 和 HTTP1.0 的区别有哪些？"></a>HTTP1.1 和 HTTP1.0 的区别有哪些？</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418204555087.png" alt="http1.1"></p><ul><li><strong>长链接</strong>：早期 HTTP1.0 的每一次请求都伴随着一次三次握手的过程，并且是<strong>串行的请求</strong>，增加了不必要的性能开销，HTTP1.1 <strong>新增了长链接</strong>的通讯方式，减少了性能损耗</li><li><strong>管道</strong>：HTTP1.0 只有串行发送，没有管道，HTTP1.1 增加了<strong>管道</strong>的概念，使得在同一个 TCP 链接当中可以同时发出多个请求</li><li><strong>断点续传</strong>：HTTP1.0 <strong>不支持断点续传</strong>，HTTP1.1 新增了 <strong>range</strong> 字段，用来指定数据字节位置，开启了断点续传的时代</li><li><strong>Host头处理</strong>：HTTP1.0 任务主机只有一个节点，所以并<strong>没有传 HOST</strong>，HTTP1.1 时代，虚拟机技术越来越发达，一台机器上也有可能有很多节点，故<strong>增加了 HOST 信息</strong></li><li><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则<strong>引入了更多的缓存控制策略</strong>例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>错误状态响应码</strong>：在HTTP1.1中<strong>新增了24个错误状态响应码</strong>，如410（Gone）表示服务器上的某个资源被永久性的删除等。</li></ul><h4 id="HTTP2-和-HTTP1-1-的区别是什么？"><a href="#HTTP2-和-HTTP1-1-的区别是什么？" class="headerlink" title="HTTP2 和 HTTP1.1 的区别是什么？"></a>HTTP2 和 HTTP1.1 的区别是什么？</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418204637544.png" alt="http2"></p><ul><li><strong>头部压缩</strong>：在 HTTP2 当中，如果你发出了<strong>多个请求</strong>，并且它们的<strong>头部(header)是相同的</strong>，那么 HTTP2 协议会帮你<strong>消除同样的部分</strong>。(其实就是在客户端和服务端维护一张索引表来实现)</li><li><strong>二进制格式</strong>：HTTP1.1 采用<strong>明文</strong>的形式，HTTP&#x2F;2 全⾯采⽤了<strong>⼆进制格式</strong>，头信息和数据体都是⼆进制</li><li><strong>数据流</strong>：HTTP&#x2F;2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。(对数据包做了标记，标志其属于哪一个请求，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。<strong>客户端还可以指定数据流的优先级</strong>，优先级⾼的请求，服务器就先响应该请求)</li><li><strong>IO多路复用</strong>：如:在⼀个连接中，服务器收到了客户端 A 和 B 的两个请求，但是发现在处理 A 的过程中⾮常耗时，索性就先回应 A 已经处理好的部分，再接着回应 B 请求，最后再回应 A 请求剩下的部分。HTTP&#x2F;2 可以<strong>在⼀个连接中并发多个请求或回应</strong>。</li><li><strong>服务器推送</strong>：服务器可以主动向客户端发送请求</li></ul><h4 id="HTTP3-和-HTTP2-的区别是什么？"><a href="#HTTP3-和-HTTP2-的区别是什么？" class="headerlink" title="HTTP3 和 HTTP2 的区别是什么？"></a>HTTP3 和 HTTP2 的区别是什么？</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418204746930.png" alt="http3"></p><ul><li><strong>协议不同</strong>：HTTP2 是基于 <strong>TCP</strong> 协议实现的，HTTP3 是基于 <strong>UDP</strong> 协议实现的</li><li><strong>QUIC</strong>：<strong>HTTP3 新增了 QUIC 协议</strong>来实现可靠性的传输</li><li><strong>握手次数</strong>：HTTP2 是基于 HTTPS 实现的，建立连接需要先进行 TCP 3次握手，然后再进行 TLS 3次握手，<strong>总共6次握手</strong>，HTTP3 只需要 QUIC 的<strong>3次握手</strong></li></ul><h3 id="10-DNS解析的两种方式"><a href="#10-DNS解析的两种方式" class="headerlink" title="10.DNS解析的两种方式?"></a><strong>10.DNS解析的两种方式?</strong></h3><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418145028996.png" alt="DNS查询的两种方式"></p><h3 id="11-XSS和-CSRF攻击"><a href="#11-XSS和-CSRF攻击" class="headerlink" title="11.XSS和 CSRF攻击?"></a><strong>11.XSS和 CSRF攻击?</strong></h3><p><strong>XSS</strong>：跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表 CSS 混淆，故将跨站脚本攻击缩写为 XSS)。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。SQL注入也是同理。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">在网页 input 或者 textarea 中输入<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;xss&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>或者其他脚本。<br></code></pre></td></tr></table></figure><p><strong>CSRF</strong>：CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但它们的攻击类型是不同维度上的分 类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">银行网站 A，它以 GET 请求来完成银行转账的操作，如：<br>http:<span class="hljs-comment">//www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</span><br>危险网站 B，它里面有一段 HTML 的代码如下:<br>&lt;img src=http:<span class="hljs-comment">//www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br>首先，你登录了银行网站 A ，然后访问危险网站 B ，噢，这时你会发现你的银行账户少了 <span class="hljs-number">1000</span> 块…<br></code></pre></td></tr></table></figure><h2 id="三、操作系统篇"><a href="#三、操作系统篇" class="headerlink" title="三、操作系统篇"></a>三、操作系统篇</h2><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418154751588.png" alt="概论"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418154901421.png" alt="进程管理"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418155120711.png" alt="内存管理"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418155159890.png" alt="文件管理"></p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418155321943.png" alt="IO管理"></p><h2 id="四、数据库篇"><a href="#四、数据库篇" class="headerlink" title="四、数据库篇"></a>四、数据库篇</h2><p>Mysql基础：<a href="https://oofelix.github.io/2022/03/11/mysql1/">https://oofelix.github.io/2022/03/11/mysql1/</a> </p><p>Mysql高级：<a href="https://oofelix.github.io/2022/03/13/mysql2/">https://oofelix.github.io/2022/03/13/mysql2/</a> </p><p>Redis详解：<a href="https://oofelix.github.io/2022/03/10/redis/">https://oofelix.github.io/2022/03/10/redis/</a> </p><h3 id="MySql篇"><a href="#MySql篇" class="headerlink" title="MySql篇"></a>MySql篇</h3><h4 id="1-说一说三大范式"><a href="#1-说一说三大范式" class="headerlink" title="1.说一说三大范式"></a>1.说一说三大范式</h4><ul><li><strong>「第一范式」</strong>：数据库中的字段具有<strong>「原子性」</strong>，不可再分，并且是单一职责</li><li><strong>「第二范式」</strong>：<strong>「建立在第一范式的基础上」</strong>，第二范式要求数据库表中的每个实例或行必须<strong>「可以被惟一地区分」</strong>。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键</li><li><strong>「第三范式」</strong>：<strong>「建立在第一，第二范式的基础上」</strong>，确保每列都和主键列直接相关，而不是间接相关不存在其他表的非主键信息</li></ul><h4 id="2-MyISAM-与-InnoDB-的区别是什么？"><a href="#2-MyISAM-与-InnoDB-的区别是什么？" class="headerlink" title="2.MyISAM 与 InnoDB 的区别是什么？"></a>2.MyISAM 与 InnoDB 的区别是什么？</h4><table><thead><tr><th>对比项</th><th>MylSAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁（不适合高并发）</td><td>行锁（适合高并发操作）</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引，还缓存真实数据。对内存要求较高</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr></tbody></table><h4 id="3-为什么推荐使用自增-id-作为主键？"><a href="#3-为什么推荐使用自增-id-作为主键？" class="headerlink" title="3.为什么推荐使用自增 id 作为主键？"></a>3.为什么推荐使用自增 id 作为主键？</h4><ul><li>１.普通索引的 B+ 树上存放的是主键索引的值，如果该值较大，会<strong>「导致普通索引的存储空间较大」</strong></li><li>２.使用自增 id 做主键索引新插入数据只要放在该页的最尾端就可以，直接<strong>「按照顺序插入」</strong>，不用刻意维护</li><li>3.页分裂容易维护，当插入数据的当前页快满时，会发生页分裂的现象，如果主键索引不为自增 id，那么数据就可能从页的中间插入，页的数据会频繁的变动，<strong>「导致页分裂维护成本较高」</strong></li></ul><h4 id="4-一条查询语句是怎么执行的"><a href="#4-一条查询语句是怎么执行的" class="headerlink" title="4.一条查询语句是怎么执行的?"></a>4.一条查询语句是怎么执行的?</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/640" alt="SQL语句执行"></p><h4 id="5-使用-Innodb-的情况下，一条更新语句是怎么执行的"><a href="#5-使用-Innodb-的情况下，一条更新语句是怎么执行的" class="headerlink" title="5.使用 Innodb 的情况下，一条更新语句是怎么执行的?"></a>5.使用 Innodb 的情况下，一条更新语句是怎么执行的?</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> xxx <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span>c<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ul><li><p>1.执行器先找引擎取 id&#x3D;2 这一行。id 是主键，引擎直接用树搜索找到这一行</p></li><li><ul><li>如果 id&#x3D;2 这一行所在的数据页本来就<strong>「在内存中」</strong>，就<strong>「直接返回」</strong>给执行器</li><li><strong>「不在内存」</strong>中，需要先从磁盘<strong>「读入内存」</strong>，然后再<strong>「返回」</strong></li></ul></li><li><p>2.执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口<strong>「写入这行新数据」</strong></p></li><li><p>3.引擎将这行新数据更新到内存中，同时将这个更新操作<strong>「记录到 redo log 里面」</strong>，此时 redo log 处于 <strong>「prepare」</strong> 状态。然后告知执行器执行完成了，随时可以提交事务</p></li><li><p>4.执行器<strong>「生成这个操作的 binlog」</strong>，并把 binlog <strong>「写入磁盘」</strong></p></li><li><p>5.执行器调用引擎的<strong>「提交事务」</strong>接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，<strong>「更新完成」</strong></p></li></ul><h4 id="6-Innodb-事务为什么要两阶段提交"><a href="#6-Innodb-事务为什么要两阶段提交" class="headerlink" title="6.Innodb 事务为什么要两阶段提交?"></a>6.Innodb 事务为什么要两阶段提交?</h4><p><strong>「主要目的是保证redolog和binlog数据一致性」</strong></p><ul><li>先写 redolog 后写binlog。假设在 redolog 写完，binlog 还没有写完的时候，MySQL 进程异常重启，这时候 binlog 里面就没有记录这个语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 <strong>「binlog 丢失」</strong>，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li><li>先写 binlog 后写 redolog。如果在 binlog 写完之后 crash，由于 redolog 还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是 binlog 里面已经记录了“把c从0改成1”这个日志。所以，在之后用 binlog 来恢复的时候就<strong>「多了一个事务出来」</strong>，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ul><h4 id="7-什么是索引"><a href="#7-什么是索引" class="headerlink" title="7.什么是索引?"></a>7.什么是索引?</h4><p>相信大家小时候学习汉字的时候都会查字典，想想你查字典的步骤，我们是通过汉字的首字母 a～z 一个一个在字典目录中查找，最终找到该字的页数。想想，如果没有目录会怎么样，最差的结果是你有可能翻到字典的最后一页才找到你想要找的字。索引就<strong>「相当于我们字典中的目录」</strong>，可以极大的提高我们在数据库的查询效率。</p><h4 id="8-索引失效的场景有哪些"><a href="#8-索引失效的场景有哪些" class="headerlink" title="8.索引失效的场景有哪些?"></a>8.索引失效的场景有哪些?</h4><ol><li>最左前缀法则（带头索引不能死，中间索引不能断</li><li>不要在索引上做任何操作（计算、函数、自动&#x2F;手动类型转换），不然会导致索引失效而转向全表扫描</li><li>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）</li><li>索引字段上使用（！&#x3D; 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</li><li>索引字段上使用 is null &#x2F; is not null 判断时，会导致索引失效而转向全表扫描。</li><li>索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描，也是最左前缀原则。</li><li>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</li><li>索引字段使用 or 时，会导致索引失效而转向全表扫描</li></ol><h4 id="9-为什么采用-B-树-而不是-B树"><a href="#9-为什么采用-B-树-而不是-B树" class="headerlink" title="9.为什么采用 B+ 树,而不是 B树"></a>9.为什么采用 B+ 树,而不是 B树</h4><p>B+ 树只在叶子结点储存数据，非叶子结点不存具体数据，只存 key，查询更稳定，增大了广度，而一个节点就是磁盘一个内存页，内存页大小固定，那么相比 B 树，B+树这些<strong>「可以存更多的索引结点」</strong>，宽度更大，树高矮，节点小，拉取一次数据的磁盘 IO 次数少，并且 B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，效率更高。</p><h4 id="10-WAl-是什么-有什么好处"><a href="#10-WAl-是什么-有什么好处" class="headerlink" title="10.WAl 是什么?有什么好处?"></a>10.WAl 是什么?有什么好处?</h4><p>WAL 就是 Write-Ahead Logging，其实就是<strong>「所有的修改都先被写入到日志中，然后再写磁盘」</strong>，用于保证数据操作的原子性和持久性。</p><h4 id="11-什么是回表"><a href="#11-什么是回表" class="headerlink" title="11.什么是回表?"></a>11.什么是回表?</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418211302609.png" alt="回表"></p><p>回表就是先通过数据库索引扫描出该索引树中数据所在的行，取到主键 id，再通过主键 id 取出主键索引数中的数据，即基于非主键索引的查询需要多扫描一棵索引树.</p><h4 id="12-什么是索引下推"><a href="#12-什么是索引下推" class="headerlink" title="12.什么是索引下推?"></a>12.什么是索引下推?</h4><ul><li><strong>索引下推</strong>（index condition pushdown ）简称ICP，在<strong>Mysql5.6</strong>的版本上推出，用于优化查询。</li><li>在不使用ICP的情况下，在使用<strong>非主键索引（又叫普通索引或者二级索引）</strong>进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</li><li>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建立联合索引（name，age）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span>  name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;陈%&#x27;</span> <span class="hljs-keyword">and</span> age<span class="hljs-operator">=</span><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418211507725.png" alt="无索引下推"></p><p>无索引下推，会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要<strong>回表两次</strong>。</p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418211539286.png" alt="使用索引下推"></p><p>使用索引下推，innoDB不会忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要<strong>回表一次</strong>。</p><p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数</strong>。</p><h4 id="13-什么是覆盖索引"><a href="#13-什么是覆盖索引" class="headerlink" title="13.什么是覆盖索引?"></a>13.什么是覆盖索引?</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>id 为主键索引，age 为普通索引，age 这个索引树存储的就是主键信息，可以直接返回</p><h4 id="14-什么是最左前缀原则"><a href="#14-什么是最左前缀原则" class="headerlink" title="14.什么是最左前缀原则?"></a>14.什么是最左前缀原则?</h4><p>最左前缀其实说的是，在 where 条件中出现的字段，<strong>「如果只有组合索引中的部分列，则这部分列的触发索引顺序」</strong>，是按照定义索引的时候的顺序从前到后触发，最左面一个列触发不了，之后的所有列索引都无法触发。</p><p>比如<strong>「有一个 (a,b,c) 的组合索引」</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--「有一个 (a,b,c) 的组合索引」</span><br><span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- 走索引</span><br><span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- a走索引，c不走</span><br><span class="hljs-keyword">where</span> b <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- 不走索引</span><br></code></pre></td></tr></table></figure><h4 id="15-普通索引和唯一索引该怎么选择"><a href="#15-普通索引和唯一索引该怎么选择" class="headerlink" title="15.普通索引和唯一索引该怎么选择?"></a>15.普通索引和唯一索引该怎么选择?</h4><ul><li><p>查询</p></li><li><ul><li>当普通索引为条件时查询到数据会一直扫描,直到扫完整张表</li><li>当唯一索引为查询条件时,查到该数据会直接返回,不会继续扫表</li></ul></li><li><p>更新</p></li><li><ul><li>普通索引会直接将操作更新到 change buffer 中,然后结束</li><li>唯一索引需要判断数据是否冲突</li></ul></li></ul><p>所以<strong>「唯一索引更加适合查询的场景,普通索引更适合插入的场景」</strong></p><h4 id="16-什么是事务-其特性是什么"><a href="#16-什么是事务-其特性是什么" class="headerlink" title="16.什么是事务?其特性是什么?"></a>16.什么是事务?其特性是什么?</h4><ul><li><strong>「原子性（Atomicity）」</strong>：要么全部执行成功，要么全部不执行。</li><li><strong>「一致性（Consistency）」</strong>：事务前后数据的完整性必须保持一致。</li><li><strong>「隔离性（Isolation）」</strong>：隔离性是当多个事务同事触发时，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li><li><strong>「持久性（Durability）」</strong>：事务完成之后的改变是永久的。</li></ul><h4 id="17-事务的隔离级别"><a href="#17-事务的隔离级别" class="headerlink" title="17.事务的隔离级别?"></a>17.事务的隔离级别?</h4><ul><li><strong>「读提交」</strong>:即能够<strong>「读取到那些已经提交」</strong>的数据</li><li><strong>「读未提交」</strong>:即能够<strong>「读取到没有被提交」</strong>的数据</li><li><strong>「可重复读」</strong>:可重复读指的是在一个事务内，最开始读到的数据和事务结束前的<strong>「任意时刻读到的同一批数据都是一致的」</strong></li><li><strong>「可串行化」</strong>:最高事务隔离级别，不管多少事务，都是<strong>「依次按序一个一个执行」</strong></li></ul><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418212639863.png" alt="不同隔离级别出现的问题"></p><ul><li><strong>「脏读」</strong>脏读指的是<strong>「读到了其他事务未提交的数据」</strong>，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读</li><li><strong>「不可重复读」</strong>对比可重复读，不可重复读指的是在同一事务内，<strong>「不同的时刻读到的同一批数据可能是不一样的」</strong>。</li><li><strong>「幻读」</strong>幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现<strong>「好像刚刚的更改对于某些数据未起作用」</strong>，但其实是事务B刚插入进来的这就叫幻读</li></ul><h4 id="18-undolog-是做什么的"><a href="#18-undolog-是做什么的" class="headerlink" title="18.undolog 是做什么的?"></a>18.undolog 是做什么的?</h4><p>undolog 是 InnoDB 存储引擎的日志，用于保证数据的原子性，<strong>「保存了事务发生之前的数据的一个版本，也就是说记录的是数据是修改之前的数据，可以用于回滚」</strong>，同时可以提供多版本并发控制下的读（MVCC）。</p><p>主要作用：<strong>事务回滚</strong>，<strong>实现多版本控制(MVCC)</strong></p><h4 id="19-binlog-是做什么的"><a href="#19-binlog-是做什么的" class="headerlink" title="19.binlog 是做什么的?"></a>19.binlog 是做什么的?</h4><p>binlog 是归档日志，属于 Server 层的日志，是一个二进制格式的文件，用于<strong>「记录用户对数据库更新的SQL语句信息」</strong>。</p><p>主要作用：<strong>主从复制</strong>，<strong>数据恢复</strong></p><h4 id="20-relaylog-是做什么的"><a href="#20-relaylog-是做什么的" class="headerlink" title="20.relaylog 是做什么的?"></a>20.relaylog 是做什么的?</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418212904162.png" alt="主从复制"></p><p>master 主节点的 binlog 传到 slave 从节点后，被写入 relay log 里，从节点的 slave sql 线程从 relaylog 里读取日志然后应用到 slave 从节点本地。从服务器 I&#x2F;O 线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后 SQL 线程会读取 relay-log 日志的内容并应用到从服务器，从而<strong>「使从服务器和主服务器的数据保持一致」</strong>。</p><h4 id="21-redolog-是做什么的"><a href="#21-redolog-是做什么的" class="headerlink" title="21.redolog 是做什么的?"></a>21.redolog 是做什么的?</h4><p>redolog 是 <strong>「InnoDB 存储引擎所特有的一种日志」</strong>，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。</p><p>可以做<strong>「数据恢复并且提供 crash-safe 能力」</strong></p><p>当有增删改相关的操作时，会先记录到 Innodb 中，并修改缓存页中的数据，<strong>「等到 mysql 闲下来的时候才会真正的将 redolog 中的数据写入到磁盘当中」</strong>。</p><h4 id="22-redolog-是怎么记录日志的"><a href="#22-redolog-是怎么记录日志的" class="headerlink" title="22.redolog 是怎么记录日志的?"></a>22.redolog 是怎么记录日志的?</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418213027402.png" alt="redolog"></p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作。<strong>「从头开始写，写到末尾就又回到开头循环写」</strong>。</p><p>所以，如果数据写满了但是还没有来得及将数据真正的刷入磁盘当中，那么就会发生<strong>「内存抖动」</strong>现象，从肉眼的角度来观察会发现 mysql 会宕机一会儿，此时就是正在刷盘了。</p><h4 id="23-redolog-和-binlog-的区别是什么"><a href="#23-redolog-和-binlog-的区别是什么" class="headerlink" title="23.redolog 和 binlog 的区别是什么?"></a>23.redolog 和 binlog 的区别是什么?</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418213058505.png" alt="redolog和binlog的区别"></p><ul><li>1.<strong>「redolog」</strong> 是 <strong>「Innodb」</strong> 独有的日志，而 <strong>「binlog」</strong> 是 <strong>「server」</strong> 层的，所有的存储引擎都有使用到</li><li>2.<strong>「redolog」</strong> 记录了<strong>「具体的数值」</strong>，对某个页做了什么修改，<strong>「binlog」</strong> 记录的<strong>「操作内容」</strong></li><li>3.<strong>「binlog」</strong> 大小达到上限或者 flush log <strong>「会生成一个新的文件」</strong>，而 <strong>「redolog」</strong> 有固定大小<strong>「只能循环利用」</strong></li><li>4.<strong>「binlog 日志没有 crash-safe 的能力」</strong>，只能用于归档。而 redo log 有 crash-safe 能力。</li></ul><h4 id="24-说一说-mvcc-吧，有什么作用"><a href="#24-说一说-mvcc-吧，有什么作用" class="headerlink" title="24.说一说 mvcc 吧，有什么作用?"></a>24.说一说 mvcc 吧，有什么作用?</h4><p>MVCC:多版本并发控制，是现代数据库(包括 MySQL、Oracle、PostgreSQL 等)引擎实现中常用的处理读写冲突的手段，目的在于<strong>「提高数据库高并发场景下的吞吐性能」</strong>。</p><p>在 MVCC 协议下，每个读操作会看到一个一致性的快照，<strong>「这个快照是基于整个库的」</strong>，并且可以实现非阻塞的读，用于<strong>「支持读提交和可重复读隔离级别的实现」</strong>。</p><p>MVCC 允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务 ID，在同一个时间点，不同的事务看到的数据是不同的，这个修改的数据是<strong>「记录在 undolog 中」</strong>的。</p><p><strong>undolog</strong> + <strong>readview</strong> + <strong>隐藏字段</strong>（隐藏主键 row_id、事务ID trx_id、<strong>回滚指针</strong> roll_pointer）</p><p><code>m_ids</code>：活跃事务id列表，当前系统中所有活跃的（也就是没提交的）事务的事务id列表。</p><p><code>min_trx_id</code>：m_ids 中最小的事务id。</p><p><code>max_trx_id</code>：生成 ReadView 时，系统应该分配给下一个事务的id（注意不是 m_ids 中最大的事务id），也就是m_ids 中的最大事务id + 1 。</p><p><code>creator_trx_id</code>：生成该 ReadView 的事务的事务id。</p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418214749452.png" alt="数据可见性"></p><p><strong>(RC)在读已提交隔离级别下，每次快照度都生成一次ReadView</strong></p><p><strong>(RR)在可重复读隔离级别下，只在第一次读数据的时候生成一次ReadView，之后都使用这个ReadView</strong></p><h4 id="25-一条-Sql-语句查询一直慢会是什么原因"><a href="#25-一条-Sql-语句查询一直慢会是什么原因" class="headerlink" title="25.一条 Sql 语句查询一直慢会是什么原因?"></a>25.一条 Sql 语句查询一直慢会是什么原因?</h4><ul><li><strong>「没有用到索引」</strong> 比如函数导致的索引失效，或者本身就没有加索引</li><li><strong>「表数据量太大」</strong> 考虑分库分表吧</li><li><strong>「优化器选错了索引」</strong>「考虑使用」force index 强制走索引</li></ul><h4 id="26-一条-Sql-语句查询偶尔慢会是什么原因"><a href="#26-一条-Sql-语句查询偶尔慢会是什么原因" class="headerlink" title="26.一条 Sql 语句查询偶尔慢会是什么原因?"></a>26.一条 Sql 语句查询偶尔慢会是什么原因?</h4><ul><li><strong>「数据库在刷新脏页」</strong> 比如 <strong>「redolog 写满了」</strong>，<strong>「内存不够用了」</strong>释放内存如果是脏页也需要刷，mysql <strong>「正常空闲状态刷脏页」</strong></li><li><strong>「没有拿到锁」</strong></li></ul><h4 id="27-Mysql-主从之间是怎么同步数据的"><a href="#27-Mysql-主从之间是怎么同步数据的" class="headerlink" title="27.Mysql 主从之间是怎么同步数据的?"></a>27.Mysql 主从之间是怎么同步数据的?</h4><ul><li>master 主库将此次更新的事件类型<strong>「写入到主库的 binlog 文件」</strong>中</li><li>master <strong>「创建 log dump 线程通知 slave」</strong> 需要更新数据</li><li><strong>「slave」</strong> 向 master 节点发送请求，<strong>「将该 binlog 文件内容存到本地的 relaylog 中」</strong></li><li><strong>「slave 开启 sql 线程」</strong>读取 relaylog 中的内容，<strong>「将其中的内容在本地重新执行一遍」</strong>，完成主从数据同步</li></ul><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418215339566.png" alt="Mysql主从复制"></p><p><strong>「同步策略」</strong>：</p><ul><li><strong>「全同步复制」</strong>：主库强制同步日志到从库，等全部从库执行完才返回客户端，性能差</li><li><strong>「半同步复制」</strong>：主库收到至少一个从库确认就认为操作成功，从库写入日志成功返回ack确认</li></ul><h4 id="28-删除表数据后表的大小却没有变动-这是为什么"><a href="#28-删除表数据后表的大小却没有变动-这是为什么" class="headerlink" title="28.删除表数据后表的大小却没有变动,这是为什么?"></a>28.删除表数据后表的大小却没有变动,这是为什么?</h4><p>在使用 delete 删除数据时，其实对应的数据行并不是真正的删除，是<strong>「逻辑删除」</strong>，InnoDB 仅仅是将其<strong>「标记成可复用的状态」</strong>，所以表空间不会变小</p><h4 id="29-Mysql-中有哪些锁"><a href="#29-Mysql-中有哪些锁" class="headerlink" title="29.Mysql 中有哪些锁?"></a>29.Mysql 中有哪些锁?</h4><p>以下并不全，主要理解下锁的意义即可</p><ul><li>基于锁的属性分类：共享锁、排他锁</li><li>基于锁的粒度分类：表锁、行锁、记录锁、间隙锁、临键锁</li><li>基于锁的状态分类：意向共享锁、意向排它锁、死锁</li></ul><h4 id="30-buffer-pool-是做什么的"><a href="#30-buffer-pool-是做什么的" class="headerlink" title="30.buffer pool 是做什么的?"></a>30.buffer pool 是做什么的?</h4><p>buffer pool 是一块内存区域，为了<strong>「提高数据库的性能」</strong>，当数据库操作数据的时候，把硬盘上的数据加载到 buffer pool，不直接和硬盘打交道，操作的是 buffer pool 里面的数据，数据库的增删改查都是在 buffer pool 上进行，buffer pool 里面缓存的数据内容也是一个个数据页</p><h4 id="31-说说你的-Sql-调优思路吧"><a href="#31-说说你的-Sql-调优思路吧" class="headerlink" title="31.说说你的 Sql 调优思路吧"></a>31.说说你的 Sql 调优思路吧</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220418215544432.png" alt="sql调优"></p><ul><li><strong>「表结构优化」</strong></li><li><ul><li>拆分字段</li><li>字段类型的选择</li><li>字段类型大小的限制</li><li>合理的增加冗余字段</li><li>新建字段一定要有默认值</li></ul></li><li><strong>「索引方面」</strong></li><li><ul><li>索引字段的选择</li><li>利用好mysql支持的索引下推，覆盖索引等功能</li><li>唯一索引和普通索引的选择</li></ul></li><li><strong>「查询语句方面」</strong></li><li><ul><li>避免索引失效</li><li>合理的书写where条件字段顺序</li><li>小表驱动大表</li><li>可以使用force index()防止优化器选错索引</li></ul></li><li><strong>「分库分表」</strong></li></ul><h4 id="32-EXPLAIN-x2F-DESC使用过吗，需要哪些关注点"><a href="#32-EXPLAIN-x2F-DESC使用过吗，需要哪些关注点" class="headerlink" title="32.EXPLAIN&#x2F;DESC使用过吗，需要哪些关注点"></a>32.EXPLAIN&#x2F;DESC使用过吗，需要哪些关注点</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220419224855673.png" alt="DESC/EXPLAIN"></p><table><thead><tr><th>列名</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置</td></tr><tr><td>select_type</td><td>显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT）</td></tr><tr><td>table</td><td>访问引用哪个表（引用某个查询，如“derived3”）</td></tr><tr><td>type</td><td>数据访问&#x2F;读取操作类型（ALL、index、range、ref、eq_ref、const&#x2F;system、NULL）</td></tr><tr><td>possible_keys</td><td>揭示哪一些索引可能有利于高效的查找</td></tr><tr><td>key</td><td>显示mysql决定采用哪个索引来优化查询</td></tr><tr><td>key_len</td><td>显示mysql在索引里使用的字节数</td></tr><tr><td>ref</td><td>显示了之前的表在key列记录的索引中查找值所用的列或常量</td></tr><tr><td>rows</td><td>为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数</td></tr><tr><td>Extra</td><td>额外信息，如using index、filesort等</td></tr></tbody></table><h3 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h3><h4 id="1-什么是-redis？它能做什么？"><a href="#1-什么是-redis？它能做什么？" class="headerlink" title="1.什么是 redis？它能做什么？"></a>1.什么是 redis？它能做什么？</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220419211718555.png" alt="用法"></p><p>redis: redis 即 Remote Dictionary Server，用中文翻译过来可以理解为<strong>远程数据服务</strong>或远程字典服务。其是使用 C 语言的编写的key-value<strong>存储系统</strong></p><p>应用场景:缓存，数据库，消息队列，分布式锁，点赞列表，排行榜等等</p><h4 id="2-redis-有哪九种数据类型？有哪些应用场景？"><a href="#2-redis-有哪九种数据类型？有哪些应用场景？" class="headerlink" title="2.redis 有哪九种数据类型？有哪些应用场景？"></a>2.redis 有哪九种数据类型？有哪些应用场景？</h4><p>五种基本数据类型:</p><ul><li><strong>string</strong>:字符串类型，常被用来存储计数器，粉丝数等，简单的分布式锁也会用到该类型</li><li><strong>hashmap</strong>:key - value 形式的，value 是一个map</li><li><strong>list</strong>:基本的数据类型，列表。在 Redis 中可以把 list 用作栈、队列、阻塞队列。</li><li><strong>set</strong>:集合，不能有重复元素，可以做点赞，收藏等</li><li><strong>zset</strong>:有序集合，不能有重复元素，有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序。可以做排行榜</li></ul><p>四种特殊数据类型:</p><ul><li><strong>geospatial</strong>: Redis 在 3.2 推出 Geo 类型，该功能<strong>可以推算出地理位置信息，两地之间的距离</strong>。</li><li><strong>hyperloglog</strong>:基数：数学上集合的元素个数，是不能重复的。这个数据结构<strong>常用于统计网站的 UV</strong>。</li><li><strong>bitmap</strong>: bitmap 就是通过最小的单位 bit 来进行0或者1的设置，表示某个元素对应的值或者状态。一个 bit 的值，或者是0，或者是1；也就是说一个 bit 能存储的最多信息是2。bitmap <strong>常用于统计用户信息比如活跃粉丝和不活跃粉丝、登录和未登录、是否打卡等</strong>。</li><li><strong>Stream</strong>：是 Redis 5.0 版本引入的一种新数据类型，同时它也是 Redis 中最为复杂的数据结构，消息队列。</li></ul><h4 id="3-redis为什么这么快？"><a href="#3-redis为什么这么快？" class="headerlink" title="3.redis为什么这么快？"></a>3.redis为什么这么快？</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220419212114885.png" alt="redis为什么这么快"></p><p>官方数据 redis 可以做到每秒近10w的并发，这么快的原因主要总结为以下几点：</p><ul><li>完全<strong>基于内存</strong>操作</li><li>使用单线程模型来处理客户端的请求，避免了上下文的切换</li><li><strong>IO 多路复用</strong>机制(epoll)</li><li>自身使用 C 语言编写，有很多优化机制，比如动态字符串 sds</li></ul><h4 id="4-听说-redis-6-0之后又使用了多线程，不会有线程安全的问题吗？"><a href="#4-听说-redis-6-0之后又使用了多线程，不会有线程安全的问题吗？" class="headerlink" title="4.听说 redis 6.0之后又使用了多线程，不会有线程安全的问题吗？"></a>4.听说 redis 6.0之后又使用了多线程，不会有线程安全的问题吗？</h4><p><strong>不会</strong></p><p>其实 redis <strong>还是使用单线程模型来处理客户端的请求</strong>，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程，所以是不会有线程安全的问题。</p><p>之所以加入了多线程因为 redis 的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p><h4 id="5-redis-的持久化机制有哪些？优缺点说说"><a href="#5-redis-的持久化机制有哪些？优缺点说说" class="headerlink" title="5.redis 的持久化机制有哪些？优缺点说说"></a>5.redis 的持久化机制有哪些？优缺点说说</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220419215125119.png" alt="AOF的appendfsync选项"></p><p><strong>AOF</strong>：redis 每次执行一个命令时,都会把这个「命令原本的语句记录到一个.aof 的文件当中,然后通过<strong>fsync策略</strong>,将命令执行后的数据持久化到磁盘中」(不包括读命令)</p><ul><li><p><strong>AOF 的「优点」</strong>:</p></li><li><ul><li>1.AOF可以「更好的保护数据不丢失」，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，<strong>最多丢失1秒的数据</strong></li><li>2.AOF是将命令直接追加在文件末尾的,<strong>「写入性能非常高」</strong></li><li>3.AOF日志文件的命令通过非常可读的方式进行记录，这个非常「<strong>适合做灾难性的误删除紧急恢复」</strong>，如果某人不小心用 flushall 命令清空了所有数据，只要这个时候还没有执行 rewrite，那么就可以将日志文件中的 flushall 删除，进行恢复</li></ul></li><li><p><strong>AOF 的「缺点」</strong>:</p></li><li><ul><li>1.对于同一份数据源来说,一般情况下<strong>AOF 文件比 RDB 数据快照要大</strong></li><li>2.由于 .aof 的<strong>每次命令都会写入</strong>,那么相对于 RDB 来说「需要消耗的性能也就更多」，当然也会有 <strong>aof 重写</strong>将 aof 文件优化。</li><li>3.<strong>「数据恢复比较慢」</strong>，不适合做冷备。</li></ul></li></ul><p><strong>RDB</strong>：把<strong>某个时间点 redis 内存</strong>中的数据以二进制的形式存储的一个.rdb为后缀的文件当中,也就是「<strong>周期性的备份redis中的整个数据</strong>」,这是redis<strong>默认</strong>的持久化方式,也就是我们说的快照(snapshot)，是采用 fork 子进程的方式来写时同步的。</p><ul><li><p>RDB的优点:</p></li><li><ul><li>1.它是将某一时间点redis内的所有数据保存下来,所以当我们做「大型的数据恢复时,RDB的恢复速度会很快」</li><li>2.由于RDB的FROK子进程这种机制,队友给客户端提供读写服务的影响会非常小</li></ul></li><li><p>RDB的缺点:</p></li><li><ul><li>举个例子假设我们定时5分钟备份一次,在10:00的时候 redis 备份了数据,但是如果在10:04的时候服务挂了,那么我们就会丢失在10:00到10:04的整个数据</li><li>1:「有可能会产生长时间的数据丢失」</li><li>2:可能会有长时间停顿:我们前面讲了,fork 子进程这个过程是和 redis 的数据量有很大关系的,<strong>如果「数据量很大,那么很有可能会使redis暂停几秒」</strong></li></ul></li></ul><h4 id="6-Redis的过期键的删除策略有哪些？"><a href="#6-Redis的过期键的删除策略有哪些？" class="headerlink" title="6. Redis的过期键的删除策略有哪些？"></a>6. Redis的过期键的删除策略有哪些？</h4><ul><li><strong>定时过期</strong>：<strong>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除</strong>。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li><li><strong>惰性过期</strong>：只有当<strong>访问一个key时，才会判断该key是否已过期</strong>，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li><strong>定期过期</strong>：<strong>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key</strong>。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li></ul><h4 id="7-Redis的内存满了怎么办？"><a href="#7-Redis的内存满了怎么办？" class="headerlink" title="7. Redis的内存满了怎么办？"></a>7. Redis的内存满了怎么办？</h4><ul><li>noeviction：直接返回错误，不淘汰任何已经存在的redis键</li><li>volatile-random：随机删除有过期时间的redis键</li><li>volatile-ttl：删除快过期的redis键</li><li>volatile-lfu：根据lfu算法从有过期时间的键删除</li><li>volatile-lru：有过期时间的使用lru算法进行淘汰</li><li>allkeys-random：随机删除redis键</li><li>allkeys-lru：所有的键使用lru算法进行淘汰</li><li>allkeys-lfu：根据lfu算法从所有键删除</li></ul><h4 id="8-Redis-的热-key-问题怎么解决？"><a href="#8-Redis-的热-key-问题怎么解决？" class="headerlink" title="8.Redis 的热 key 问题怎么解决？"></a>8.Redis 的热 key 问题怎么解决？</h4><p>热 key  就是说，在某一时刻，有非常多的请求访问某个 key，流量过大，导致该 redi 服务器宕机</p><p>解决方案:</p><ul><li>可以将结果缓存到本地内存中</li><li>将热 key 分散到不同的服务器中</li><li>设置永不过期</li></ul><h4 id="9-缓存击穿、缓存穿透、缓存雪崩是什么？怎么解决呢？"><a href="#9-缓存击穿、缓存穿透、缓存雪崩是什么？怎么解决呢？" class="headerlink" title="9.缓存击穿、缓存穿透、缓存雪崩是什么？怎么解决呢？"></a>9.缓存击穿、缓存穿透、缓存雪崩是什么？怎么解决呢？</h4><p><strong>缓存穿透</strong>：缓存穿透是指用户请求的数据<strong>在缓存中不存在并且在数据库中也不存在</strong>，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。</p><p>解决方案:</p><ul><li>布隆过滤器</li><li>返回空对象</li></ul><p><strong>缓存击穿</strong>：缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在<strong>失效的瞬间，持续的大并发就穿破缓存</strong>，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>解决方案:</p><ul><li>互斥锁</li><li>永不过期</li></ul><p><strong>缓存雪崩</strong>：缓存雪崩是指缓存中<strong>不同的数据大批量到过期时间</strong>，而查询数据量巨大，请求直接落到数据库上导致宕机。</p><p>解决方案:</p><ul><li>均匀过期</li><li>加互斥锁</li><li>缓存永不过期</li><li>双层缓存策略</li></ul><h4 id="10-Redis-有哪些部署方式？"><a href="#10-Redis-有哪些部署方式？" class="headerlink" title="10.Redis 有哪些部署方式？"></a>10.Redis 有哪些部署方式？</h4><ul><li>单机模式:这也是最基本的部署方式,只需要一台机器,负责读写,一般只用于开发人员自己测试</li><li>哨兵模式:哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。它具备<strong>自动故障转移、集群监控、消息通知</strong>等功能。</li><li>cluster集群模式:在redis3.0版本中支持了cluster集群部署的方式，这种集群部署的方式能<strong>自动将数据进行分片</strong>，每个master上放一部分数据，提供了内置的高可用服务，即使某个master挂了，服务还可以正常地提供。</li><li>主从复制:在主从复制这种集群部署模式中，我们会将数据库分为两类，第一种称为主数据库(master)，另一种称为从数据库(slave)。主数据库会负责我们整个系统中的读写操作，从数据库会负责我们整个数据库中的读操作。其中在职场开发中的真实情况是，我们会让主数据库只负责写操作，让从数据库只负责读操作，就是为了<strong>读写分离</strong>，减轻服务器的压力。</li></ul><h4 id="11-哨兵有哪些作用？"><a href="#11-哨兵有哪些作用？" class="headerlink" title="11.哨兵有哪些作用？"></a>11.哨兵有哪些作用？</h4><ul><li>监控整个主数据库和从数据库，观察它们是否正常运行</li><li>当主数据库发生异常时，自动的将从数据库升级为主数据库，继续保证整个服务的稳定</li></ul><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220419220201907.png" alt="故障转移"></p><p><strong>获取主服务器信息</strong>：哨兵默认会以十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。</p><p><strong>获取从服务器信息</strong>：哨兵默认会以十秒一次的频率，通过命令连接向从服务器发送INFO命令，并通过分析INFO命令的回复来获取从服务器的当前信息。</p><p><strong>向主从服务器发送信息</strong>：哨兵会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送命令，发布自己的信息。</p><p><strong>检测主观下线：</strong>默认情况下，哨兵会以每秒一次的频率向所有与它建立了命令连接的实例发送PING命令来判断实例是否在下，</p><h4 id="12-哨兵选举过程是怎么样的？"><a href="#12-哨兵选举过程是怎么样的？" class="headerlink" title="12.哨兵选举过程是怎么样的？"></a>12.哨兵选举过程是怎么样的？</h4><ul><li>发现master挂了的哨兵，向每个哨兵发送命令，让对方选举自己成为领头哨兵(先到先得)</li><li>其他哨兵如果没有选举过他人，就会将这一票投给第一个发现该master挂了的哨兵</li><li>第一个发现该master挂了的哨兵如果发现由超过一半哨兵投给自己，并且其数量也超过了设定的quoram参数，那么该哨兵就成了领头哨兵</li><li>选出领头哨兵后，就开始了故障修复，会从选出一个从数据库作为新的master，并通知所有的从服务器新选举出的master</li></ul><h4 id="13-cluster集群模式是怎么存放数据的？"><a href="#13-cluster集群模式是怎么存放数据的？" class="headerlink" title="13.cluster集群模式是怎么存放数据的？"></a>13.cluster集群模式是怎么存放数据的？</h4><p>一个cluster集群中总共有16384个节点，集群会<strong>将这16384个节点平均分配给每个节点</strong>，当然，我这里的节点指的是每个主节点，就如同下图：</p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220419213303272.png" alt="Cluster槽"></p><h4 id="14-cluster的故障恢复是怎么做的？"><a href="#14-cluster的故障恢复是怎么做的？" class="headerlink" title="14.cluster的故障恢复是怎么做的？"></a>14.cluster的故障恢复是怎么做的？</h4><p>判断故障的逻辑其实与哨兵模式有点类似，在集群中，每个节点都会<strong>定期的向其他节点发送ping命令</strong>，通过有没有收到回复来判断其他节点是否已经下线。</p><p>如果<strong>长时间没有回复，那么发起ping命令的节点就会认为目标节点疑似下线</strong>，也可以和哨兵一样称作主观下线，当然也需要集群中一定数量的节点都认为该节点下线才可以，我们来说说具体过程：</p><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220419213339008.png" alt="Cluster故障恢复"></p><ul><li>当A节点发现目标节点疑似下线，就会向集群中的其他节点散播消息，其他节点就会向目标节点发送命令，判断目标节点是否下线</li><li>如果集群中半数以上的节点都认为目标节点下线，就会对目标节点标记为下线，从而告诉其他节点，让目标节点在整个集群中都下线</li></ul><h4 id="15-主从同步原理是怎样的？"><a href="#15-主从同步原理是怎样的？" class="headerlink" title="15.主从同步原理是怎样的？"></a>15.主从同步原理是怎样的？</h4><p><img src="/%E9%9D%A2%E7%BB%8F.assets/image-20220419214607955.png" alt="主从复制"></p><ul><li>当一个从数据库启动时，它会向<strong>主数据库发送一个PSYNC命令</strong>，master收到后，在后台保存快照，也就是我们说的RDB持久化，当然保存快照是需要消耗时间的，并且redis是单线程的，在保存快照期间redis收到的命令会缓存起来</li><li>快照完成后会<strong>将RDB文件发送给slave节点</strong>，并使用<strong>部分重同步</strong>，将RDB复制期间的命令发送给从服务器，从而保证主从数据库的一致性。</li><li>从数据库接受到快照以及缓存的命令后会将这部分数据<strong>写入到硬盘上的临时文件当中</strong>，写入完成后会用这份文件去替换掉RDB快照文件，当然，这个操作是不会阻塞的，可以继续接收命令执行，具体原因其实就是fork了一个子进程，用子进程去完成了这些功能。</li></ul><p>因为不会阻塞，所以，这部分初始化完成后，当主数据库执行了改变数据的命令后，会异步的给slave，这也就是我们说的复制同步阶段，这个阶段会贯穿在整个中从同步的过程中，直到主从同步结束后，复制同步才会终止。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2022/04/10/graph/"/>
    <url>/2022/04/10/graph/</url>
    
    <content type="html"><![CDATA[<p><img src="/graph.assets/image-20220411212517663.png" alt="图论中常见算法"></p><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><p>存储图一般有两种方法</p><p><img src="/graph.assets/image-20220411164022891.png" alt="邻接矩阵"></p><p><img src="/graph.assets/image-20220411164053643.png" alt="邻接表"></p><p>邻接矩阵适用于稠密图，而邻接表适用于稀疏图；</p><p>下面介绍使用C++来建立图结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 邻接矩阵</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> g[N][N];<br><br><span class="hljs-comment">// 邻接表</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> h[N],e[N],ne[N],idx=<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 有需要可以定义 in[N],out[N],w[N]; 入读，出度，边权值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    e[idx] = b,ne[idx] = h[a];h[a] = idx++;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Dijkstra算法-（朴素版本）"><a href="#Dijkstra算法-（朴素版本）" class="headerlink" title="Dijkstra算法 （朴素版本）"></a>Dijkstra算法 （朴素版本）</h2><p><strong>Dijkstra算法可以求单源最短路径问题</strong>，算法思想如下：</p><ul><li>初始化一个节点，距离为0，其他节点为无穷</li><li>选取可到达的最近的一个节点标记为以访问，且将该节点的所有邻接节点更新</li><li>循环</li></ul><blockquote><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="language-bash">输入：</span><br>3 3<br><span class="hljs-meta">&gt;</span><span class="language-bash">1 2 2</span><br>2 3 1<br><span class="hljs-meta">&gt;</span><span class="language-bash">1 3 4</span><br>输出：<br><span class="hljs-meta">&gt;</span><span class="language-bash">3</span><br>数据范围：<br><span class="hljs-meta">&gt;</span><span class="language-bash">1≤n≤500,1≤m≤100000,</span><br>图中涉及边长均不超过10000。<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> g[N][N],d[N],st[N]; <span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 用于每次选取最大的节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||d[j] &lt; d[t]))<br>                t = j;<br>        &#125;<br>        st[t] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            d[j] = <span class="hljs-built_in">min</span>(d[j],d[t]+g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(d[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> a,b,c;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>       cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>       g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>软件测试</title>
    <link href="/2022/03/28/softwaretest/"/>
    <url>/2022/03/28/softwaretest/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该博客是根据苏临之老师所授课程&lt;&lt;软件测试&gt;&gt;，学习时所做的笔记。</p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>理解故障、失效、缺陷和错误之间的关系</p><p><img src="/softwaretest.assets/image-20220329020934123.png" alt="故障、失效、错误和缺陷"></p><p>软件缺陷发现得越晚，则维护成本就越高。</p><p>软件测试花费的时间是软件开发生命周期中最高的</p><p><img src="/softwaretest.assets/image-20220329021157443.png" alt="测试时间花费"></p><p><strong>α-测试：</strong>是由一个用户在开发环境下进行的测试，也可以是公 司内部的用户在模拟实际操作环境下进行的受控测试，不 能由程序员或测试员完成。</p><p><strong>β测试：</strong>β测试是软件的多个用户在一个或多个用户的实际使用环境 下进行的测试。开发者通常不在测试现场，不能由程序员 或测试员完成。所以，β测试是在开发者无法控制的环境下 进行的软件现场应用。</p><p><strong>通过性测试</strong>：通过性测试指的是利用最简单最直观的测试用例，确认软件的基本功能，而不会考验其能力。</p><p><strong>失效性测试</strong>：失效性测试指的是纯粹为破坏软件而设计和执行的 测试，用来蓄意攻击软件的薄弱环节。</p><p>满足以下5个规则之一可判定为软件缺陷： </p><ul><li>软件未实现产品说明书要求的功能。 </li><li>软件出现了产品说明书指明不应出现的错误。 </li><li>软件实现了产品说明书未提到的功能。 </li><li>软件未实现产品说明书虽未明确提及但应该实现的目标。 </li><li>软件难以理解、不易使用、运行缓慢或者从测试员的角度看最终用户会认为不好。</li></ul><p>软件开发生命周期常用来描述的四种模型：</p><ul><li>大爆炸模型</li><li>边写边改模型</li><li>瀑布模型</li><li>螺旋模型</li></ul><p>一些软件测试的软件：QTP (Quicktest Professional) 、WinRunner 、Robot 、QACenter</p><p>Forward Compatibility（向前兼容）: Being able to use the versions in the future. </p><p>Backward Compatibility（向后兼容）: Being able to use the versions in the past.</p><h1 id="静态黑盒测试"><a href="#静态黑盒测试" class="headerlink" title="静态黑盒测试"></a>静态黑盒测试</h1><p>主要是审查产品规格说明书</p><h1 id="动态黑盒测试"><a href="#动态黑盒测试" class="headerlink" title="动态黑盒测试"></a>动态黑盒测试</h1><p>动态黑盒测试包括以下五种</p><ul><li>Equivalence Partitioning (等价类划分)</li><li>Boundary Value Analysis (边界值分析)</li><li>Decision Table (判定表&#x2F;决策表）</li><li>Cause-Effect Diagram (因果图)</li><li>Error Guessing (错误猜想)</li></ul><h2 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h2><p>定义：The input domain is divided into several equivalence classes, and we select only a few (maybe only one) representative test cases from each class, reducing the inputs and thus avoiding redundant full testing. This is called the equivalence partitioning.</p><p>操作步骤：</p><ul><li>找出有效等价类</li><li>根据有效等价类划分无效等价类</li><li>画出等价类划分表</li><li>找出有效和无效用例</li></ul><blockquote><p><strong>eg1：</strong> 某企业的报表处理系统要求用户输入处理报表的 日期，日期限制在2003年1月至2008年12月，即 系统只能对该段期间内的报表进行处理，如日期 不在此范围内，则显示输入错误信息。输入信息 要求：系统日期规定由表征年、月的6位数字字 符组成，前4位代表年，后2位代表月。</p><p><strong>划分有效等价类 valid equivalence classes (VECs)：</strong></p><p>①6位数字字符 ②前4位范围2003-2008 ③后2位范围01-12</p><p><strong>划分无效等价类</strong> <strong>invalid equivalence classes (IECs)：</strong></p><p>④有非数字字符；⑤输入少于6位；⑥输入多于6位 ⑦前4位小于2003；⑧前4位大于2008 ⑨后2位小于01⑩ 后2位大于12</p><p><img src="/softwaretest.assets/image-20220328232334081.png" alt="等价类划分表"></p><p><img src="/softwaretest.assets/image-20220328232414899.png" alt="有效测试用例"></p><p><img src="/softwaretest.assets/image-20220328232442002.png" alt="无效测试用例"></p></blockquote><blockquote><p><strong>eg2：</strong>某城市的电话号码由三部分组成。这三部分的名称 和内容分别是：地区码：空白或3位数字；前缀：非“0”或“1”开头的3位数； 后缀：4位数字。</p><p><strong>有效等价类：</strong></p><p>地区码：①空白 ②三位数字；前缀：③200~999之间的三位数；后缀：④四位数字</p><p><strong>无效等价类：</strong></p><p>地区码：⑤ 有非数字字符；⑥ 多于3位；⑦ 少于3位； 前缀：⑧ 有非数字字符；⑨ 多于3位；⑩ 少于3位； ⑪ 起始位是“0” ；⑫ 起始位是“1” ； 后缀：⑬有非数字字符； ⑭多于4位； ⑮少于4位；</p><p><img src="/softwaretest.assets/image-20220328232936743.png" alt="等价类划分表"></p><p><img src="/softwaretest.assets/image-20220328233009771.png" alt="有效用例"></p><p><img src="/softwaretest.assets/image-20220328233030051.png" alt="无效用例"></p></blockquote><p>对于等价类划分，并没有绝对统一的划分方式，只要划分合理即可，以下原则有助于更好的划分有效、无效等价类：</p><ul><li>Value Range (取值范围): one VEC &amp; two IECs</li><li>Value Number (取值个数): one VEC &amp; two IECs </li><li>Multiple Branching (分支不同输入值): one VEC for each branch value &amp; one IEC </li><li>“Must-Be (必须是)”: one VEC &amp; one IEC </li><li>If the elements are thought to be treated unequally for any reason, or if an EC is too general, then we should divide it into some smaller ECs</li><li>As long as the condition contains the OR relationship, whether valid or invalid, we usually establish several independent ECs; provided the relationship is AND, a further consideration is needed. </li><li>“n numeric characters” indicates both “<strong>numerical digit equals n</strong>“ and “<strong>must be numeric characters</strong>“. After the NOT operation, <strong>three</strong> IECs should be established. </li><li>A special requirement for the numerical digit can be translated into the numerical value range. </li><li>Sometimes the De Morgan’s laws will facilitate the analysis.</li></ul><h2 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h2><p>定义：It is considered that the boundary values along with the adjacent values are more sensitive to those which are far away from boundaries. So they should be paid more attention to and therefore selected as test cases so as to find more hidden bugs.</p><p>Boundary conditions consist of general boundary conditions, sub-boundary conditions, destructive boundary conditions and so on. It is necessary to recognize these conditions according to the specific issue</p><p>操作步骤：</p><ul><li>根据程序要求画出图例分析</li><li>找出边界，从用例中心，边界，内边界，外边界进行控制变量分析</li><li>写出测试用例</li></ul><blockquote><p><strong>eg1：</strong>Here is a function of two variables F&#x3D;(x+2)×y where x and y are two integers. x∈[10, 20] and y∈[20,30]. The software has guaranteed the integral inputs.</p><p><img src="/softwaretest.assets/image-20220328234352520.png" alt="控制变量及写出用例"></p></blockquote><blockquote><p><strong>eg2：</strong>设邮寄某大号包裹时，其质量0≤m≤10时对应计算 公式为F(m)，1050时对应计算公式为H(m)（单位均为kg，精确 到0.01kg）。</p><p><img src="/softwaretest.assets/image-20220328234551201.png" alt="图示分析说明"></p></blockquote><p>以下原则有助于进行边界值分析：</p><ul><li>输入条件规定输入值范围：针对范围的边界设计测试用例，针对刚刚越界的情况设计无效测试用例。</li><li>输入条件规定了输入值的数量：针对最小数量、最 大数量、最小数量少1、最大数量多1的情况来设计 测试用例（此处的“1”指的是最小的精度）。 </li><li>如果程序的输入或输出是一个有序序列，则应该特 别注意序列的第1个和最后1个元素。 </li><li>边界值分析是具有创造性的方法，发挥聪明才智找 出其他的边界（临界）条件。</li></ul><h2 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h2><p>定义：A decision table is usually employed to describe the cases where the input variables are logical concerned or the inputs and outputs are limited by causalities <strong>(输入变量之间存在逻辑关系或输入输出之间存在因果关系)</strong></p><p>A decision table consist of two parts. One is the input condition part and the other is the output action part. These two parts involves two kinds of stubs and their corresponding binary logical value.</p><p>操作步骤：</p><ul><li>首先确定各个条件桩和动作桩</li><li>对于可以预见的任意项加以合并，并对不可能并 存的条件桩组合加以删除；</li><li>根据条件桩的组合和题目要求，画出对应输出了 哪些动作桩。</li><li>检查判定表，根据最后的结果再次合并无关项；</li><li>根据判定表的条件桩组合给出测试用例，并看结 果是否和动作桩组合相一致</li></ul><blockquote><p><strong>eg1</strong>：某企业的报表处理系统要求用户输入处理报表的 日期，日期限制在2003年1月至2008年12月，即 系统只能对该段期间内的报表进行处理，如日期 不在此范围内，则显示输入错误信息。输入信息 要求：系统日期规定由表征年、月的6位数字字 符组成，前4位代表年，后2位代表月。 </p><p>Please design test cases to check the function for date input by using the decision table technique.</p><p>The inputs involve three basic elements, which are called the <strong>condition stubs (条件桩)</strong>. C1: 6位数字字符；C2: 前4位范围2003<del>2008； C3: 后2位范围01</del>12。</p><p>The outputs for condition combinations involve two possible results, i.e. the <strong>action stubs (动作桩)</strong>. A1: 对应报表信息；A2: 报错。</p><p><img src="/softwaretest.assets/image-20220328230434501.png" alt="画出决策表"></p><p><img src="/softwaretest.assets/image-20220328230451860.png" alt="找出可合并用例"></p><p><img src="/softwaretest.assets/image-20220328230559157.png" alt="合并用例"></p><p>给出测试用例：①200405 ②200400 ③200905 ④200900 ⑤2004May</p></blockquote><blockquote><p><strong>eg2</strong>:程序从一个输入对话框中读取3个正整数值。这3 个整数值代表了三角形三边的长度。程序显示提 示信息，指出该三角形究竟是不等边三角形、等 腰三角形还是等边三角形</p><p><strong>条件桩：</strong></p><p>C1: 可构成三角形；C2: a&#x3D;b；C3: a&#x3D;c；C4: b&#x3D;c</p><p><strong>动作桩：</strong></p><p>A1: 不是三角形；A2: 不等边三角形；A3: 等腰三角形；A4: 等边三角形</p><p><img src="/softwaretest.assets/image-20220328231305113.png" alt="排除不可能出现的情况"></p><p><img src="/softwaretest.assets/image-20220328231352426.png" alt="最终结果"></p></blockquote><p>以下原则有助于正确画出判断表：</p><ul><li>首先确定各个条件桩和动作桩； </li><li>对于可以预见的任意项加以合并，并对不可能并 存的条件桩组合加以删除； </li><li>根据条件桩的组合和题目要求，画出对应输出了 哪些动作桩。 </li><li>检查判定表，根据最后的结果再次合并无关项； </li><li>根据判定表的条件桩组合给出测试用例，并看结 果是否和动作桩组合相一致</li></ul><h2 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h2><p>定义：The cause-effect diagram (CED), or cause-and-effect diagram in some literature, is used to describe the test issue where multiple inputs are involved. At the same time, the CED is also able to point out the imperfection and ambiguousness in the specification. </p><p>The CED is usually employed before the generation of the decision table. The process from a CED to a decision table can be achieved manually, but when it comes to some complicated issues, it is usually achieved by automatic tools.</p><p>原因和结果之间的四种关系：<strong>Equal (恒等关系)，Not (非关系)， Or (或关系)，&amp; And (与关系)</strong></p><p><img src="/softwaretest.assets/image-20220329000341301.png" alt="四种关系"></p><p>四种原因约束：<strong>Exclusive (异约束, E), Inclusive (或约束, I), Only one (唯一约束, O) &amp; Require (要求约束, R).</strong></p><p>一种结果约束： <strong>Mask (强制 约束&#x2F;屏蔽约束, M).</strong></p><p><img src="/softwaretest.assets/image-20220329000435902.png" alt="五种约束"></p><p>操作步骤：</p><ul><li>找出case（原因）和effect（结果）</li><li>将结果与原因进行关联，写出表达式并化简</li><li>画出CED</li></ul><blockquote><p><strong>eg1：</strong>程序的规格说明要求：输入的第1个字符必须是# 或* ，第2个字符必须是一个数字，此情况下进行 对应文件的修改；如果第一个字符不是#或* ，则 给出报错信息X，如果第二个字符不是数字，则 给出报错信息Y。</p><p><strong>原因和结果：</strong></p><p>原因：c1: 第1字符是#；c2: 第1字符是*；c3: 第2字符是数字</p><p>结果：e1: 报错信息X；e2: 修改文件；e3: 报错信息Y</p><p><strong>写出表达式：</strong></p><p>e1&#x3D;<del>(c1∨c2); e2&#x3D;(c1∨c2)∧c3; e3&#x3D;</del>c3，结合具体情况可创建中间变量如：t1 &#x3D; c1∨c2</p><p><img src="/softwaretest.assets/image-20220329000159291.png" alt="画出因果图"></p></blockquote><blockquote><p><strong>eg2：</strong>某饮料售货机的橙汁和啤酒均售价5元钱。若投入5元纸 币，然后按“橙汁”或“啤酒”按钮，则会出来相应的 饮料；若投入10元纸币，然后按“橙汁”或“啤酒”按 钮，不仅会出来相应的饮料，同时还会退回5元钱。如果 不投币直接按下任一按钮，则会出现错误提示音。设机 器一次只能接受一张5元或10元纸币（仅一个投币口）， 硬件设计使得无法同时按下两个按钮，也不能使得同一 个按钮在一次购买中按两次。</p><p>原因：c1: 投入5元 c2: 投入10元 c3: 按下“橙汁” c4: 按下“啤酒”</p><p>结果： e1: 出来橙汁 e2: 出来啤酒 e3: 退回5元 e4: 错误提示音</p><p>原因结果表达式：</p><p>e1 &#x3D; (c1∨c2)∧c3； e2 &#x3D; (c1∨c2)∧c4； e3 &#x3D; c2∧(c3∨c4)； e4 &#x3D; ((<del>c1)∧(</del>c2))∧(c3∨c4) &#x3D; (~(c1∨c2))∧(c3∨c4)</p><p>构建中间变量：t1 &#x3D; c1∨c2； t2 &#x3D; c3∨c4</p><p>e1 &#x3D; t1∧c3； e2 &#x3D; t1∧c4； e3 &#x3D; c2∧t2； e4 &#x3D; (~t1)∧t2</p><p><img src="/softwaretest.assets/image-20220329001315254.png" alt="因果图"></p></blockquote><p>以下原则有助于你构建因果图：</p><ul><li>1、列出作输入条件的原因和作输出条件的结果；</li><li>2、通过语义分析原因之间的约束，标于图上； </li><li>3、分析每一个结果由哪些原因组合构成的； </li><li>4、通过因果分析构建出恒等关系； </li><li>5、构建中间变量，使一次传播中仅一种基本关系； </li><li>6、完成因果图绘制，并分析结果间的约束； </li><li>7、转换为判定表； </li><li>8、划掉不满足诸约束的组合； </li><li>9、根据判定表给出相应的测试用例。</li></ul><h2 id="错误猜想"><a href="#错误猜想" class="headerlink" title="错误猜想"></a>错误猜想</h2><p>定义：Error guessing is a informal process relying on instinct.</p><p>操作步骤：</p><ul><li>列举出可能犯的错误或错误易发情况的清单，然后依据 清单来编写测试用例。 </li><li>在阅读规格说明时联系程序员可能做的假设来确定测试 用例，如忽略了规格说明中的某些内容。</li></ul><blockquote><p>eg：测试一个排序程序，可能猜测出错的情况 </p><p>输入列表为空 </p><p>输入列表仅包含一项 </p><p>输入列表所有条目的值都相同</p><p>输入列表已经是有序的</p></blockquote><h1 id="静态白盒测试"><a href="#静态白盒测试" class="headerlink" title="静态白盒测试"></a>静态白盒测试</h1><p>静态白盒测试就是审查代码包括：</p><ol><li>Data Reference Errors (数据引用错误) </li><li>Data Declaration Errors (数据声明错误) </li><li>Computation Errors (运算错误) </li><li>Comparison Errors (比较错误) </li><li>Control Flow Errors (流程控制错误) </li><li>Subroutine Parameter Errors (子程序参数接口错误) </li><li>Input &#x2F; Output Errors (输入输出错误) </li><li>Other Checks (其余错误类型)</li></ol><h1 id="动态白盒测试"><a href="#动态白盒测试" class="headerlink" title="动态白盒测试"></a>动态白盒测试</h1><p>定义：动态白盒测试基于程序的源代码，因此通常也称为<strong>基于代码测试(Code-based Testing)或结构性测试</strong>。 </p><p>动态白盒测试技术的基本思想是<strong>把测试对象的每 部分代码在机器里至少要执行一次</strong>。这就需要设计面向控制流的测试用例，分析程序的逻辑，然后执 行测试用例，检查输出结果和理论分析结果是否一 致。</p><h2 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h2><p>语句覆盖(Statement Coverage) 指的是通过 一组测试用例，使得所有的（或尽可能多的） 语句都能执行一次</p><blockquote><p><img src="/softwaretest.assets/image-20220329002829445.png" alt="语句覆盖"></p><p>此处若要让①②③④ 全部执行 ，必须选择 ACE这条路径。</p><p>此处可以设置(2,0,4)这组 用例，使得①②③④这4条语句全执行。又如(2,0,6)也 可以覆盖全部的语句。</p><p>此此处只需要一个测试 用例即可覆盖全部语句。有 的程序则需要多个测试用例来覆盖语句。</p><p>语句覆盖的缺点是显 然的。如③中的||错打成了&amp;&amp;，(2,0,4)这个 测试用例同样会走ACE 路径。因此，语句覆盖 难以发现逻辑错误，它是最弱的覆盖。</p><p><img src="/softwaretest.assets/image-20220329002955160.png" alt="语句覆盖测试用例表"></p></blockquote><h2 id="判定-分支-覆盖"><a href="#判定-分支-覆盖" class="headerlink" title="判定(分支)覆盖"></a>判定(分支)覆盖</h2><p>判定覆盖(Decision Coverage) 也叫分支覆盖，所设计的若干测试 用例使每个判定 的 Y 和 N分支都得以至少执行 一次。</p><blockquote><p><img src="/softwaretest.assets/image-20220329003236995.png" alt="判定覆盖"></p><p>如(2,0,4)使得①和③的判断都选择了 Y， 而(3,1,1)都选择了N,因此用这两个测试用例可以做到判定覆盖 。</p><p>再如，(3,0,3)使①选择Y而③选择N，而(2,1,1)使①选择N而③选择 Y 。这种方式也可以做到判定覆盖,因此也可以选择这两个测试用例 。</p><p>判定覆盖步骤如下：先识别并标识所有输入，再识别并标识所有判定，然后取不同的输入组合构成测试用例，并给出预期结果。</p><p>判定覆盖相比于语句覆盖要强一些，但是仍然偏弱。例如①中的a&gt;1不慎写成了a&gt;&#x3D;1，上述两组测试用例仍然会按照各自的分支去覆盖。</p><p><img src="/softwaretest.assets/image-20220329003626753.png" alt="判定覆盖"></p></blockquote><h2 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h2><p>条件覆盖(Condition Coverage) 指的是测试用例把程序内诸条件取T和F的情况都覆盖的情况 。</p><blockquote><p><img src="/softwaretest.assets/image-20220329004035864.png" alt="条件覆盖"></p><p>本例共有4个条件 ，每个条件均有T和两种取值 ，因此只需要覆盖这8个判断取值就可以了 。</p><p>如 (1,0,3) 可以满足 F1T2F3T4，而(2,1,1)可以满足T1F2T3F4，两种刚好覆盖了所有条件的T和F，因此用这两 个测试用例可以做到条件覆盖。</p><p>条件覆盖步骤如下：先识别并标识所有输入，再识别并标识所有条件，然后取不同的输入组合构成测试用例，并给出预期结果。</p><p><img src="/softwaretest.assets/image-20220329004146256.png" alt="条件覆盖用例表"></p></blockquote><h2 id="判定-x2F-条件覆盖"><a href="#判定-x2F-条件覆盖" class="headerlink" title="判定&#x2F;条件覆盖"></a>判定&#x2F;条件覆盖</h2><p>判定&#x2F;条件覆盖(Decision&#x2F; Condition Coverage) 如果若干测试用例既把每 条判断语句的分支Y和N覆盖，又把程序内诸条件取T和F的情况都覆盖。</p><blockquote><p><img src="/softwaretest.assets/image-20220329004405640.png" alt="判定/条件覆盖"></p><p>如(2,0,4)和(1,1,1)两个测试用例就能够满足上面所有 的条件，使得所有的条件恰好满足。</p><p><img src="/softwaretest.assets/image-20220329004504700.png" alt="判定、条件覆盖测试用例表"></p></blockquote><p>判定覆盖(分支覆盖)、条件覆盖和判定&#x2F;条件覆盖之间的关系</p><p><img src="/softwaretest.assets/image-20220329004633807.png" alt="条件、判定和判定/条件覆盖之间的关系"></p><h2 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a>条件组合覆盖</h2><p>条件组合覆盖(Multiple Condition Coverage)，也叫多重条件覆盖 如果<strong>若干</strong>测试用例使得语句内部的诸条件的T和F组合至少被执行了一次。</p><blockquote><p><img src="/softwaretest.assets/image-20220329005151723.png" alt="条件组合覆盖"></p><p>对 ①来说 ，包含的2个条件T和F组合有4种：T1 T2 、T1 F2 、F1 T2和F1 F2。对于③来讲也有 4种： T3 T4 、T3 F4 、F3 T4和F3 F4。</p><p><img src="/softwaretest.assets/image-20220329005219389.png" alt="条件组合覆盖测试用例表"></p></blockquote><h2 id="决策路径覆盖"><a href="#决策路径覆盖" class="headerlink" title="决策路径覆盖"></a>决策路径覆盖</h2><p>决策路径覆盖(Path Coverage)，也叫做DD路径覆盖：若干测试用例能够覆盖所有可经过的路径。</p><blockquote><p><img src="/softwaretest.assets/image-20220329005411608.png" alt="决策路径覆盖"></p><p>很显然，本例路径包含有 ABD、ABE、ACD和ACE 这4条路径，因此很容易选出测试用例。对于复杂的例子需使用圈复杂度公式。</p><p><img src="/softwaretest.assets/image-20220329005515673.png" alt="决策覆盖测试用例表"></p></blockquote><p><img src="/softwaretest.assets/image-20220329005545571.png" alt="覆盖强度分析"></p><p><strong>tips：条件覆盖和判定覆盖之间没有关系。</strong></p><h2 id="动态白盒测试举例"><a href="#动态白盒测试举例" class="headerlink" title="动态白盒测试举例"></a>动态白盒测试举例</h2><blockquote><p><strong>eg1：</strong>lease design test cases by using the dynamic whitebox testing techniques for this piece of code below.</p><p><img src="/softwaretest.assets/image-20220329005955425.png" alt="程序及流程图"></p></blockquote><blockquote><p><img src="/softwaretest.assets/image-20220329010112047.png" alt="语句、判定覆盖"></p><p><img src="/softwaretest.assets/image-20220329010148775.png" alt="条件、判定/条件覆盖"></p><p><img src="/softwaretest.assets/image-20220329010256515.png" alt="条件组合覆盖"></p></blockquote><blockquote><p><strong>eg2：</strong>右侧程序输入变量是a和b，输出变 量是x。请画出框图和程序控制流 图，然后分别给出语句覆盖、判定覆 盖、条件覆盖、判定&#x2F;条件覆盖和条 件组合覆盖的测试用例及预期结果。 其中判定覆盖、判定&#x2F;条件覆盖要指 出对应用例覆盖的路径，条件覆盖和 判定&#x2F;条件覆盖要指出对应用例覆盖 的条件，条件组合覆盖要指出对应用 例覆盖的条件组合。</p><p><img src="/softwaretest.assets/image-20220329010622859.png" alt="程序及流程图"></p><p><img src="/softwaretest.assets/image-20220329010703251.png" alt="测试用例"></p><p><img src="/softwaretest.assets/image-20220329010726612.png" alt="测试用例"></p></blockquote><h1 id="圈复杂度-amp-独立路径"><a href="#圈复杂度-amp-独立路径" class="headerlink" title="圈复杂度&amp;独立路径"></a>圈复杂度&amp;独立路径</h1><h2 id="１、计算圈复杂度"><a href="#１、计算圈复杂度" class="headerlink" title="１、计算圈复杂度"></a>１、计算圈复杂度</h2><p>计算方法：</p><p>①V &#x3D; E0 - N    其中E0表示所有边(包括入边，出边)，N表示图中的节点</p><p>②V &#x3D; E - N + 2P 其中其中E表示除了入边，出边外的所有边，N表示图中的节点，P表示连通分量</p><p>③V &#x3D; A + 1 其中A表示图中出现的环   （最简单的方法）</p><p>④如果是程序源代码，圈读复杂度对于条件判断语句数量加１，while和for也算一个判断语句。</p><p><img src="/softwaretest.assets/image-20220329011627707.png" alt="圈度图"></p><p>eg：如最右边的图：其中E0 &#x3D; 14，E &#x3D; 12，N &#x3D; 9，P &#x3D; 1，A &#x3D; 4</p><p>①V &#x3D; E0 - N &#x3D; 14 - 9 &#x3D; 5 或 ②V &#x3D; E - N + 2P &#x3D; 5 或 ③V &#x3D; A + 1 &#x3D; 5</p><h2 id="２、独立路径"><a href="#２、独立路径" class="headerlink" title="２、独立路径"></a>２、独立路径</h2><p>独立路径（基本测试路径）的条数等于圈复杂度</p><h1 id="更高别的测试"><a href="#更高别的测试" class="headerlink" title="更高别的测试"></a>更高别的测试</h1><p><img src="/softwaretest.assets/image-20220329013450094.png" alt="软件开发是生命周期"></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Unit testing is also called the module testing, which alleviates the difficulty in the testing process. One can also test several units in parallel. The unit testing is generally a white-box testing, which means that it is essential to know the basic code in the module, including the input and output as well as its function.</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p><img src="/softwaretest.assets/image-20220329013631685.png" alt="基本模型"></p><p><strong>驱动模块：</strong><br>驱动模块是用来模拟被测模块的上一级模块，相当于被测模块的主程序。它接收数据并将相关数据传送给被测模块，启用被测模块并打印出相应结果。驱动模块的目的很单纯，就是访问类库的属性和方法来确定类库是否正确。</p><p><strong>桩模块：</strong><br>桩模块是模拟被测试模块所调用的模块，而不是软件产品的组成部分。主程序作为驱动模块，与之直接相连的模块是桩模块，也称为“替身模块”。桩模块本身不执行任何功能，只在它作为替身被调用时返回静态值。</p><p><img src="/softwaretest.assets/image-20220329014934561.png" alt="两种测试方式"></p><p><img src="/softwaretest.assets/image-20220329014857043.png"></p><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>常见的系统测试主要有：</p><ul><li>Ability Testing (能力测试) </li><li>Load Testing (容量测试) </li><li>Stress Testing (压力测试) </li><li>Performance Testing (性能测试) </li><li>Memory Testing (存储测试)</li></ul><p>具体的系统测试有：</p><ul><li>Configuration Testing (配置测试) </li><li>Compatibility Testing (兼容性测试) </li><li>Foreign Language Testing (外国语言测试)</li><li>Usability Testing (易用性测试) </li><li>Documentation Testing (文档测试) • Safety Testing (安全性测试)</li></ul><h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><h2 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h2><h2 id="独立性测试"><a href="#独立性测试" class="headerlink" title="独立性测试"></a>独立性测试</h2><h1 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h1><h2 id="Brutal-Force-Debugging-暴力调试法"><a href="#Brutal-Force-Debugging-暴力调试法" class="headerlink" title="Brutal Force Debugging (暴力调试法)"></a>Brutal Force Debugging (暴力调试法)</h2><h2 id="Inclusive-Debugging-归纳调试法"><a href="#Inclusive-Debugging-归纳调试法" class="headerlink" title="Inclusive Debugging (归纳调试法)"></a>Inclusive Debugging (归纳调试法)</h2><h2 id="Deductive-Debugging-演绎调试法"><a href="#Deductive-Debugging-演绎调试法" class="headerlink" title="Deductive Debugging (演绎调试法)"></a>Deductive Debugging (演绎调试法)</h2><h2 id="Back-Tracking-Debugging-回溯调试法"><a href="#Back-Tracking-Debugging-回溯调试法" class="headerlink" title="Back-Tracking Debugging (回溯调试法)"></a>Back-Tracking Debugging (回溯调试法)</h2><h2 id="Test-Debugging-测试调试法"><a href="#Test-Debugging-测试调试法" class="headerlink" title="Test Debugging (测试调试法)"></a>Test Debugging (测试调试法)</h2><h1 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h1>]]></content>
    
    
    <categories>
      
      <category>lesson</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/15/leetcode/"/>
    <url>/2022/03/15/leetcode/</url>
    
    <content type="html"><![CDATA[<blockquote><p>可从下面的网站了解到关于算法或者数据结构的知识</p><p><a href="https://oi-wiki.org/">OI Wiki (oi-wiki.org)</a></p></blockquote><p><img src="/leetcode.assets/image-20220323024710432.png" alt="image-20220323024710432"></p><p><img src="/leetcode.assets/sort-intro-1.apng" alt="几种排序算法的比较"></p><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><strong>leetcode</strong></h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h3><blockquote><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure></blockquote><p>题记：可以使用Set，也可以使用并查集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : set)&#123;<br>            <span class="hljs-keyword">if</span>(!set.contains(num - <span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curNum</span> <span class="hljs-operator">=</span> num;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curStreak</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(set.contains(curNum + <span class="hljs-number">1</span>))&#123;<br>                    curStreak++;<br>                    curNum++;<br>                &#125;<br>                max = Math.max(max, curStreak);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(uf.fatherMap.containsKey(nums[i]-<span class="hljs-number">1</span>))&#123;<br>                uf.union(nums[i]-<span class="hljs-number">1</span>, nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.max;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max;<br>    <span class="hljs-keyword">public</span> Map&lt;Integer,Integer&gt; fatherMap;<br>    <span class="hljs-keyword">public</span> Map&lt;Integer,Integer&gt; sizeMap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        max = <span class="hljs-number">1</span>;<br>        fatherMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        sizeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x : nums)&#123;<br>            fatherMap.put(x,x);<br>            sizeMap.put(x,<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">father</span> <span class="hljs-operator">=</span> fatherMap.get(val);<br>        <span class="hljs-keyword">if</span>(val != father)   father = find(father);<br>        fatherMap.put(val,father);<br>        <span class="hljs-keyword">return</span> father;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">aFather</span> <span class="hljs-operator">=</span> find(a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bFather</span> <span class="hljs-operator">=</span>find(b);<br>        <span class="hljs-keyword">if</span>(aFather != bFather)&#123;<br>            sizeMap.put(bFather, sizeMap.get(aFather)+sizeMap.get(bFather));<br>            fatherMap.put(aFather, bFather);<br>            max = Math.max(max, sizeMap.get(bFather));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h3><blockquote><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]</p></blockquote><p>题记：左端排序，判断；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="hljs-number">0</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],ed = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        map.put(st,ed);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] segment : intervals)&#123;<br>            <span class="hljs-keyword">if</span>(segment[<span class="hljs-number">0</span>] &lt;= ed) &#123;<br>                ed = Math.max(ed, segment[<span class="hljs-number">1</span>]);<br>                map.put(st,ed);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                map.put(segment[<span class="hljs-number">0</span>],segment[<span class="hljs-number">1</span>]);<br>                st = segment[<span class="hljs-number">0</span>];<br>                ed = segment[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[map.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x : map.keySet())&#123;<br>            res[i][<span class="hljs-number">0</span>] = x;<br>            res[i][<span class="hljs-number">1</span>] = map.get(x);<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h3><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><img src="/leetcode.assets/swap_ex1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">myHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> head, p = head.next;<br>        myHead.next = head;<br>        head = myHead;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>            q.next = p.next;<br>            head.next = p;<br>            p.next = q;<br>            q = q.next;<br>            head = p.next;<br>            <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>            p = q.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> myHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-II-024-反转链表"><a href="#剑指-Offer-II-024-反转链表" class="headerlink" title="剑指 Offer II 024. 反转链表"></a><a href="https://leetcode-cn.com/problems/UHnkqh/">剑指 Offer II 024. 反转链表</a></h3><blockquote><h4 id="剑指-Offer-II-024-反转链表-1"><a href="#剑指-Offer-II-024-反转链表-1" class="headerlink" title="剑指 Offer II 024. 反转链表"></a><a href="https://leetcode-cn.com/problems/UHnkqh/">剑指 Offer II 024. 反转链表</a></h4><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p><p><img src="/leetcode.assets/rev1ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">new_head</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> new_head;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 头插</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">myHead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">toUse</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = myHead;<br>            myHead = head;<br>            head = toUse;<br>        &#125;<br>        <span class="hljs-keyword">return</span> myHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><img src="/leetcode.assets/reverse_ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">myHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        myHead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> myHead,q = head;<br>        head = myHead;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> myHead.next;<br>            &#125;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> p.next;<br>            reverse(q,p);<br>            head.next = p;<br>            p = q;<br>            head = q;<br>            q.next = temp;<br>            q = p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> myHead.next;<br>    &#125;<br><br>    ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode q,ListNode p)</span>&#123;<br>        <span class="hljs-keyword">if</span>(q == p)&#123;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverse(q.next,p);<br>        q.next.next = q;<br>        q.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h3><blockquote><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><img src="/leetcode.assets/circularlinkedlist.png" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">4</span>], <span class="hljs-attr">pos</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure></blockquote><p>题记：①使用hash表，②使用快慢指针，hash表需要O(n)空间复杂度，而快慢指针不消耗额外空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 先快指针先走两个位置</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> head.next.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">back</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span>(back != front)&#123;<br>            <span class="hljs-comment">// 一次走两步需要判next指针是否为空</span><br>            <span class="hljs-keyword">if</span>(front == <span class="hljs-literal">null</span> || front.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            front = front.next.next;<br>            back = back.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="/leetcode.assets/160_statement.png" alt="img"></p><p><strong>题目数据 保证 整个链式结构中不存在环。</strong></p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p></blockquote><p>题记：题目给出两个链表不存在环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span>(headB == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> headA, cur2 = headB;<br>        <span class="hljs-keyword">while</span>(cur1 != cur2)&#123;<br>            cur2 = cur2 == <span class="hljs-literal">null</span>? headA:cur2.next;<br>            cur1 = cur1 == <span class="hljs-literal">null</span>? headB:cur1.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h3><blockquote><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [10,2]</span><br><span class="hljs-section">输出: &quot;102&quot;</span><br><span class="hljs-section">输入: [3,30,34,5,9]</span><br><span class="hljs-section">输出: &quot;3033459&quot;</span><br></code></pre></td></tr></table></figure></blockquote><p>题记：排序+自定义比较规则即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[nums.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; nums.length; i++) strs[i] = String.valueOf(nums[i]);<br>        Arrays.sort(strs,(x,y) -&gt; (x+y).compareTo(y+x));<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(String sr : strs)&#123;<br>            res.append(sr);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h3><blockquote><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p></blockquote><p>题记：将所有的String排序作为key 放入 HashMap 或者 使用一个Character数组记录每个单词出现的次数作为key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x : strs)&#123;<br>            <span class="hljs-type">char</span>[] chars = x.toCharArray();<br>            Arrays.sort(chars);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>            <span class="hljs-keyword">if</span>(map.get(str) == <span class="hljs-literal">null</span>)&#123;<br>                map.put(str,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;()&#123;&#123;add(x);&#125;&#125;);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                map.get(str).add(x);<br>            &#125;<br>        &#125;<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> y : map.values())&#123;<br>                res.add(y);<br>            &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆-amp-栈"><a href="#堆-amp-栈" class="headerlink" title="堆&amp;栈"></a>堆&amp;栈</h2><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h3><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure></blockquote><p>思路：①使用递归 ② 使用栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        dfs(head);<br>        <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.size(); i++)&#123;<br>            ret[i] = res.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(head.next);<br>        res.add(head.val);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 栈</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            stack.push(head.val);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> stack.size();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size; i++)&#123;<br>            res[i] = stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h3><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p></blockquote><p>思路：设栈1，栈2，栈1只用于压栈，栈2只用于出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">while</span>(!stack2.isEmpty())&#123;<br>            stack1.push(stack2.poll());<br>        &#125;<br>        stack1.push(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;<br>            stack2.push(stack1.poll());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (stack2.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> stack2.poll();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue obj = new CQueue();</span><br><span class="hljs-comment"> * obj.appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h3><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], popped = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：我们可以按以下顺序执行：<br>push<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>, <span class="hljs-title">pop</span><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">4</span>,<br>push<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">pop</span><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">5</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">3</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">2</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">1</span><br><br>输入：pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], popped = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-number">1</span> 不能在 <span class="hljs-number">2</span> 之前弹出。<br></code></pre></td></tr></table></figure></blockquote><p>思路：根据压栈序列，与出栈序列，使用一个栈来模拟压栈出栈，若最后栈为空则说明符合题意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validateStackSequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] pushed, <span class="hljs-type">int</span>[] popped)</span> &#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : pushed)&#123;<br>            stack.push(x);<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popped[j])&#123;<br>                stack.pop();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h3><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p></blockquote><p>思路：使用一个辅助栈，为递减单调栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Stack&lt;Integer&gt; A, B;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        A.add(x);<br>        <span class="hljs-keyword">if</span>(B.empty() || B.peek() &gt;= x)<br>            B.add(x);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(A.pop().equals(B.peek()))<br>            B.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> A.peek();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> B.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h2 id="二叉树🎄🎄🎄"><a href="#二叉树🎄🎄🎄" class="headerlink" title="二叉树🎄🎄🎄"></a>二叉树🎄🎄🎄</h2><h3 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a><strong>BM32</strong> <strong>合并二叉树</strong></h3><blockquote><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：</p><p><img src="/leetcode.assets/image-20220330150833314.png" alt="tree1"></p><p><img src="/leetcode.assets/image-20220330150852627.png" alt="tree2"></p><p><img src="/leetcode.assets/image-20220330150918464.png" alt="merge"></p><p>输入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,#,<span class="hljs-number">4</span>,#,<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-meta">#,7&#125;</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *   int val = 0;</span><br><span class="hljs-comment"> *   TreeNode left = null;</span><br><span class="hljs-comment"> *   TreeNode right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t1 TreeNode类 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t2 TreeNode类 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span> <span class="hljs-params">(TreeNode t1, TreeNode t2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span> &amp;&amp; t2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span> || t2 == <span class="hljs-literal">null</span>) <span class="hljs-type">return</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? t2 : t1;<br>        <span class="hljs-comment">// 此时 t1、t2 均不为 null</span><br>        <span class="hljs-comment">// 合并节点的值</span><br>        t1.val = t1.val + t2.val;<br>        <span class="hljs-comment">// 合并左子树</span><br>        t1.left = mergeTrees(t1.left, t2.left);<br>        <span class="hljs-comment">// 合并右子树</span><br>        t1.right = mergeTrees(t1.right, t2.right);<br>        <span class="hljs-keyword">return</span> t1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a><strong>BM34</strong> <strong>判断是不是二叉搜索树</strong></h3><blockquote><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。</p><p>二叉搜索树满足每个节点的左子树上的所有节点均小于当前节点且右子树上的所有节点均大于当前节点。</p><p>例：</p><p><img src="/leetcode.assets/9C31F319601A5B78D34F62FF77A02A11" alt="img"></p><p>图1</p><p><img src="/leetcode.assets/5E5B576E11CB2C96724680C94755ABCB" alt="img"></p><p>图2</p><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1,2,3&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *   int val = 0;</span><br><span class="hljs-comment"> *   TreeNode left = null;</span><br><span class="hljs-comment"> *   TreeNode right = null;</span><br><span class="hljs-comment"> *   public TreeNode(int val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root TreeNode类 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span> <span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> solve(root);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> solve(root.left);<br>        <span class="hljs-keyword">if</span>(root.val &lt; pre) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root.val;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> solve(root.right);<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a><strong>BM35</strong> <strong>判断是不是完全二叉树</strong></h3><blockquote><p>给定一个二叉树，确定他是否是一个完全二叉树。</p><p>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）</p></blockquote><p>题记：遇到第一个结点为空那么后续所有的结点都要为空，否则不是完全二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCompleteTree</span> <span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;()&#123;&#123;offer(root);&#125;&#125;;<br>        TreeNode cur;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            cur = queue.poll();<br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>)&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            queue.offer(cur.left);<br>            queue.offer(cur.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h3><blockquote><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> <span class="hljs-number">3</span><br>/ <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br> /  <span class="hljs-string">\</span><br><span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>     <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h3><blockquote><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。思路：可以自顶向下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> Math.abs(maxDepth(root.left)-maxDepth(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自底向上，后续遍历，先子后父亲</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> post(root) &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">post</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> post(root.left);<br>        <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 可以剪枝</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> post(root.right);<br>        <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>||right == -<span class="hljs-number">1</span> || Math.abs(left-right) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><blockquote><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p><ul><li>1 ≤ k ≤ 二叉搜索树元素个数</li></ul></blockquote><p>思路：① 直接中序遍历即可，②镜像先序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> res, k;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(root.right);<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(--k == <span class="hljs-number">0</span>) res = root.val;<br>        dfs(root.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h3><blockquote><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,7,1,3,6,9]</span><br>输出：<span class="hljs-string">[4,7,2,9,6,3,1]</span><br><span class="hljs-number">0</span> &lt;= 节点个数 &lt;= <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></blockquote><p>思路：前序遍历，左右子树交换即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left;<br>            root.left = root.right;<br>            root.right = temp;<br>            mirrorTree(root.left);<br>            mirrorTree(root.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-33-二叉搜索树的后序遍"><a href="#剑指-Offer-33-二叉搜索树的后序遍" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍</a></h3><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">5</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">2</span>   <span class="hljs-number">6</span><br>/ <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span><br><br>输入: [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出: <span class="hljs-literal">false</span><br>输入: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>]<br>输出: <span class="hljs-literal">true</span><br>数组长度 &lt;= <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></blockquote><p>思路：根据二叉搜索树的特点，结合后续遍历，以后序遍历的方式构造二叉树，如果能构造成功，则符合题意。</p><p>后续遍历序列中，最后一个节点为根节点，第一个大于根节点到最后一个节点的的序列为右子树，其他为左子树即：</p><p>[左子树，右子树，根节点]，利用这个规律，我们来递归建树即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> solve(postorder,<span class="hljs-number">0</span>,postorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> postorder[r];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> r;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; r; i++)&#123;<br>            <span class="hljs-keyword">if</span>(postorder[i] &gt; root)&#123;<br>                right = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> right;<br>        <span class="hljs-keyword">for</span>(;k &lt; r; k++)&#123;<br>            <span class="hljs-keyword">if</span>(postorder[k] &lt; root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k != r) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> solve(postorder,l,right-<span class="hljs-number">1</span>) &amp;&amp; solve(postorder,right,r-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-34-二叉树中和为某一值的路"><a href="#剑指-Offer-34-二叉树中和为某一值的路" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路</a></h3><blockquote><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><img src="/leetcode.assets/image-20220315150612677.png" alt="image-20220315150612677"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：root</span> <span class="hljs-string">=</span> [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<span class="hljs-string">,</span> <span class="hljs-string">targetSum</span> <span class="hljs-string">=</span> <span class="hljs-number">22</span><br><span class="hljs-string">输出：[[5,4,11,2],[5,8,4,5]]</span><br><span class="hljs-string">树中节点总数在范围</span> [<span class="hljs-number">0</span>, <span class="hljs-number">5000</span>] <span class="hljs-string">内</span><br><span class="hljs-number">-1000</span> <span class="hljs-string">&lt;=</span> <span class="hljs-string">Node.val</span> <span class="hljs-string">&lt;=</span> <span class="hljs-number">1000</span><br><span class="hljs-number">-1000</span> <span class="hljs-string">&lt;=</span> <span class="hljs-string">targetSum</span> <span class="hljs-string">&lt;=</span> <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></blockquote><p>思路：DFS+回溯 使用一个栈来储存当前路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        dfs(root,targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        targetSum -= root.val;<br>        path.offerLast(root.val);<br>        <span class="hljs-keyword">if</span>(targetSum == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(path));<br>        &#125;<br>        dfs(root.left,targetSum);<br>        dfs(root.right,targetSum);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h3><blockquote><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>/ <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">4 <br>/<br>1<br></code></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br>输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br><span class="hljs-number">0</span> &lt;= 节点个数 &lt;= <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure></blockquote><p>思路：递归与左右子树对比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">return</span> (A != <span class="hljs-literal">null</span> &amp;&amp; B != <span class="hljs-literal">null</span>) &amp;&amp; (recur(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || A.val != B.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> recur(A.left,B.left) &amp;&amp; recur(A.right,B.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h3><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>​        1<br>​      &#x2F;     <br>​    2       2<br>&#x2F;    \    &#x2F;   <br>3     4  4     3</p><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p>1<br>&#x2F;  <br>2  2<br>\    <br>3    3</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br>输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br><span class="hljs-number">0</span> &lt;= 节点个数 &lt;= <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></blockquote><p>思路：先判断根节点，之后递归判断左右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> solve(root.left,root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(TreeNode left, TreeNode right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span> || left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> solve(left.right,right.left) &amp;&amp; solve(left.left,right.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-68-I-二叉搜索树的最近公"><a href="#剑指-Offer-68-I-二叉搜索树的最近公" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公</a></h3><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="/leetcode.assets/binarysearchtree_improved.png" alt="img"></p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p></blockquote><p>思路：二叉搜索树左子树小于根，右子树，大于根，子树亦然。可以利用这个性质进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val) <br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right,p,q);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left,p,q);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-68-II-二叉树的最近公共祖"><a href="#剑指-Offer-68-II-二叉树的最近公共祖" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖</a></h3><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="/leetcode.assets/binarytree.png" alt="img"></p><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p></blockquote><p>思路：分三种情况，① 两个节点分别在左右子树，那么公共祖先为根    ②都在左子树    ③都在右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left,p,q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right,p,q);<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span>? right:left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h3><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Input:</span> <span class="hljs-string">preorder</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<span class="hljs-string">,</span> <span class="hljs-string">inorder</span> <span class="hljs-string">=</span> [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]<br><span class="hljs-attr">Output:</span> [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br><br><span class="hljs-attr">Input:</span> <span class="hljs-string">preorder</span> <span class="hljs-string">=</span> [<span class="hljs-number">-1</span>]<span class="hljs-string">,</span> <span class="hljs-string">inorder</span> <span class="hljs-string">=</span> [<span class="hljs-number">-1</span>]<br><span class="hljs-attr">Output:</span> [<span class="hljs-number">-1</span>]<br><br><span class="hljs-number">0</span> <span class="hljs-string">&lt;=</span> <span class="hljs-string">节点个数</span> <span class="hljs-string">&lt;=</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure></blockquote><p>思路：根据先序遍历，每次取第一个原始，找到该元素在中序遍历中的位置，将中序序列以该元素分两部分，递归构建左右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">return</span> solve(preorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>,inorder,<span class="hljs-number">0</span>,preorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> ll, <span class="hljs-type">int</span> rr)</span>&#123;<br><span class="hljs-comment">// 序列不可分，结束</span><br>        <span class="hljs-keyword">if</span>(ll &gt; rr) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[l]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ll; i &lt;= rr; i++) &#123;<br>            <span class="hljs-comment">// 递归左右子树</span><br>            <span class="hljs-keyword">if</span>(preorder[l] == inorder[i])&#123;<br>                root.left = solve(preorder,l+<span class="hljs-number">1</span>,l+i-ll,inorder,ll,i-<span class="hljs-number">1</span>);<br>                root.right = solve(preorder,l+i-ll+<span class="hljs-number">1</span>,r,inorder,i+<span class="hljs-number">1</span>,rr);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM41-输出二叉树的右视图"><a href="#BM41-输出二叉树的右视图" class="headerlink" title="BM41 输出二叉树的右视图"></a><strong>BM41</strong> <strong>输出二叉树的右视图</strong></h3><blockquote><p>如输入[1,2,4,5,3],[4,2,5,1,3]时，通过前序遍历的结果[1,2,4,5,3]和中序遍历的结果[4,2,5,1,3]可重建出以下二叉树：<img src="/leetcode.assets/image-20220330182418903.png"></p><p>所以对应的输出为[1,3,5]。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,4,5,3]</span>,<span class="hljs-selector-attr">[4,2,5,1,3]</span><br>输出：<span class="hljs-selector-attr">[1,3,5]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] solve (<span class="hljs-type">int</span>[] xianxu, <span class="hljs-type">int</span>[] zhongxu) &#123;<br>        createTree(xianxu,<span class="hljs-number">0</span>,xianxu.length-<span class="hljs-number">1</span>,zhongxu,<span class="hljs-number">0</span>,zhongxu.length-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : res) ret[i++] = x;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] xianxu, <span class="hljs-type">int</span> xl, <span class="hljs-type">int</span> xr,<span class="hljs-type">int</span>[] zhongxu, <span class="hljs-type">int</span> zl, <span class="hljs-type">int</span> zr, <span class="hljs-type">int</span> level)</span>&#123;<br>        <span class="hljs-keyword">if</span>(zl &gt; zr) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(res.size() &lt;= level) res.add(xianxu[xl]);<br>        <span class="hljs-keyword">else</span>&#123;<br>            res.set(level,xianxu[xl]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> zl; i &lt;= zr; i++)&#123;<br>            <span class="hljs-keyword">if</span>(zhongxu[i] == xianxu[xl])&#123;<br>                createTree(xianxu,xl+<span class="hljs-number">1</span>,xl+i-zl,zhongxu,zl,i-<span class="hljs-number">1</span>,level+<span class="hljs-number">1</span>);<br>                createTree(xianxu,xl+(i-zl)+<span class="hljs-number">1</span>,xr,zhongxu,i+<span class="hljs-number">1</span>,zr,level+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h3><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p><img src="/leetcode.assets/bstdlloriginalbst.png" alt="img"></p><p><img src="/leetcode.assets/bstdllreturndll.png" alt="img"></p></blockquote><p>思路：二叉搜索树的中序遍历是非递减序列，中序遍历，pre指针，head指针，最后首位连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Node pre,head;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">treeToDoublyList</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        dfs(root);<br>        head.left = pre;<br>        pre.right = head;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node cur)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(cur.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span>) pre.right = cur;<br>        <span class="hljs-type">else</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> cur;<br>        cur.left = pre;<br>        pre = cur;<br>        dfs(cur.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h3><blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><img src="/leetcode.assets/serdeser.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) sb.append(<span class="hljs-string">&quot;@,&quot;</span>);<br>            <span class="hljs-keyword">else</span>&#123;<br>                sb.append(node.val).append(<span class="hljs-string">&quot;,&quot;</span>);<br>                queue.offer(node.left);<br>                queue.offer(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span>(data.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        String[] strs = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(strs[index++]));<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;@&quot;</span>.equals(strs[index]))&#123;<br>                node.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(strs[index]));<br>                queue.offer(node.left);<br>            &#125;<br>            index ++;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;@&quot;</span>.equals(strs[index]))&#123;<br>                node.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(strs[index]));<br>                queue.offer(node.right);<br>            &#125;<br>            index ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec codec = new Codec();</span><br><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span><br></code></pre></td></tr></table></figure></blockquote><p>先序遍历DFS版本：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><br><span class="hljs-comment">// Encodes a tree to a single string.</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>  <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>  <span class="hljs-keyword">return</span> serialize2(root,sb);<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize2</span><span class="hljs-params">(TreeNode root,StringBuilder sb)</span>&#123;<br>  <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>      sb.append(<span class="hljs-string">&quot;@,&quot;</span>);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>      sb.append(root.val).append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>      serialize2(root.left,sb);<br>      serialize2(root.right,sb);<br>  &#125;<br>  <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br><span class="hljs-comment">// Decodes your encoded data to tree.</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>  String[] strs = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>  <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span> || strs[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;@&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  List&lt;String&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(Arrays.asList(strs));<br>  <span class="hljs-keyword">return</span> deserialize2(arr);<br>&#125;<br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize2</span><span class="hljs-params">(List&lt;String&gt; arr)</span>&#123;<br>  <span class="hljs-keyword">if</span>(arr.get(<span class="hljs-number">0</span>).equals(<span class="hljs-string">&quot;@&quot;</span>))&#123;<br>      arr.remove(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.parseInt(arr.get(<span class="hljs-number">0</span>)));<br>  arr.remove(<span class="hljs-number">0</span>);<br>  root.left = deserialize2(arr);<br>  root.right = deserialize2(arr);<br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br>&#125;<br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec codec = new Codec();</span><br><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="面试题32-I-从上到下打印二叉树"><a href="#面试题32-I-从上到下打印二叉树" class="headerlink" title="面试题32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">面试题32 - I. 从上到下打印二叉树</a></h3><blockquote><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> <span class="hljs-number">3</span><br>/ <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br> /  <span class="hljs-string">\</span><br><span class="hljs-number">15</span>   <span class="hljs-number">7</span><br>返回：[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            res.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; res.size(); i++)&#123;<br>            ret[i] = res.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-32-II-从上到下打印二叉树"><a href="#剑指-Offer-32-II-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树</a></h3><blockquote><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs inform7"> 3<br>/ \<br>9  20<br> /  \<br>15   7<br>输出：<span class="hljs-comment">[</span><br><span class="hljs-comment">    <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">    <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">    <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">   ]</span><br>节点总数 &lt;= 1000<br></code></pre></td></tr></table></figure></blockquote><p>思路：先取每一层的节点个数，再一次提出队列，注意root可能是空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                temp.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>            &#125;<br>            res.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-32-III-从上到下打印二叉树"><a href="#剑指-Offer-32-III-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树</a></h3><blockquote><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p></blockquote><p>思路：在<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树</a>的基础上，对偶数行的元素反转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 1表示需要反转</span><br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; size; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                temp.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>            &#125;<br>            flag ++;<br>            <span class="hljs-keyword">if</span>(flag %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) Collections.reverse(temp);<br>            res.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal">429. N 叉树的层序遍历</a></h3><blockquote><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public List&lt;Node&gt; children;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        children = _children;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;()&#123;&#123;<br>            add(root);<br>        &#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            ArrayList&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.poll();<br>                temp.add(t.val);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; t.children.size(); j++)&#123;<br>                    <span class="hljs-keyword">if</span>(t.children.get(j) != <span class="hljs-literal">null</span>) queue.offer(t.children.get(j));<br>                &#125;<br>            &#125;<br>            res.add(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1306-跳跃游戏-III"><a href="#1306-跳跃游戏-III" class="headerlink" title="1306. 跳跃游戏 III"></a><a href="https://leetcode-cn.com/problems/jump-game-iii/">1306. 跳跃游戏 III</a></h3><blockquote><p>这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。</p><p>请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。</p><p>注意，不管是什么情况下，你都无法跳到数组之外。</p><p>输入：arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5<br>输出：true<br>解释：<br>到达值为 0 的下标 3 有以下可能方案：<br>下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3<br>下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 </p><ul><li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li><li><code>0 &lt;= arr[i] &lt; arr.length</code></li><li><code>0 &lt;= start &lt; arr.length</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canReach</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start)</span> &#123;<br>        Queue&lt;Integer&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">if</span>(arr[start] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(start + arr[start] &lt; len) que.offer(start+arr[start]);<br>        <span class="hljs-keyword">if</span>(start - arr[start] &gt;= <span class="hljs-number">0</span>) que.offer(start-arr[start]);<br>        arr[start] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            start = que.poll();<br>            <span class="hljs-keyword">if</span>(arr[start] == -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(arr[start] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(start + arr[start] &lt; len) que.offer(start+arr[start]);<br>            <span class="hljs-keyword">if</span>(start - arr[start] &gt;= <span class="hljs-number">0</span>) que.offer(start-arr[start]);<br>            arr[start] = -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS-amp-回溯"><a href="#DFS-amp-回溯" class="headerlink" title="DFS&amp;回溯"></a>DFS&amp;回溯</h2><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><blockquote><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] status = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        dfs(nums,<span class="hljs-number">0</span>,status);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> deep,<span class="hljs-type">boolean</span>[] status)</span>&#123;<br>        <span class="hljs-keyword">if</span>(deep == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!status[i])&#123;<br>                status[i] = <span class="hljs-literal">true</span>;<br>                path.add(nums[i]);<br>                dfs(nums,deep+<span class="hljs-number">1</span>,status);<br>                path.remove(deep);<br>                status[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h3><blockquote><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br> <br>输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] status = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dfs(nums,<span class="hljs-number">0</span>,status);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(res);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> deep,<span class="hljs-type">int</span>[] status)</span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length == deep)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            在全局对num排序，可以使用自定义的规则完成去重</span><br><span class="hljs-comment">            Arrays.sort(num);</span><br><span class="hljs-comment">            可以简化去重</span><br><span class="hljs-comment">            if (status[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; status[i - 1] == 0)) &#123;</span><br><span class="hljs-comment">                continue;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        */</span><br>            <span class="hljs-keyword">if</span>(status[i] == <span class="hljs-number">0</span>)&#123;<br>                status[i] = <span class="hljs-number">1</span>;<br>                path.add(nums[i]);<br>                dfs(nums,deep+<span class="hljs-number">1</span>,status);<br>                path.remove(deep);<br>                status[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><blockquote><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/leetcode.assets/200px-telephone-keypad2svg.png" alt="img"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure></blockquote><p>题记：使用map将数字与可能出现的字母形成映射DFS即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Map&lt;Character,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;()&#123;&#123;<br>            put(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>);<br>            put(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;edf&quot;</span>);<br>            put(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>);<br>            put(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>);<br>            put(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>);<br>            put(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>);<br>            put(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>);<br>            put(<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>);<br>        &#125;&#125;;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span>(digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        dfs(path,<span class="hljs-number">0</span>,digits.length(),digits);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(StringBuilder path, <span class="hljs-type">int</span>  x, <span class="hljs-type">int</span> u,String digits)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x &gt;= u)&#123;<br>            list.add(path.toString());<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> digits.charAt(x);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> map.get(ch);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> letters.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            path.append(letters.charAt(i));<br>            dfs(path,x+<span class="hljs-number">1</span>,u,digits);<br>            path.deleteCharAt(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h3><blockquote><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure></blockquote><p>题记：回溯，能加左括号就加左括号，不能加左括号就加右括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        dfs(path,<span class="hljs-number">0</span>,n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(StringBuilder path,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> max, <span class="hljs-type">int</span> open,<span class="hljs-type">int</span> close)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">2</span>*max)&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(open &lt; max)&#123;<br>            path.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            dfs(path,x+<span class="hljs-number">1</span>,max,open+<span class="hljs-number">1</span>,close);<br>            path.deleteCharAt(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(close &lt; open)&#123;<br>            path.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            dfs(path,x+<span class="hljs-number">1</span>,max,open,close+<span class="hljs-number">1</span>);<br>            path.deleteCharAt(x); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h3><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><blockquote><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br><span class="hljs-number">1</span> &lt;= s 的长度 &lt;=<span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure></blockquote><p>题记：全排列问题，dfs+回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;String&gt; con = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>        <span class="hljs-type">char</span>[] path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[s.length()];<br>        dfs(s,path,<span class="hljs-number">0</span>,s.length());<br>        String[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[con.size()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x: con) res[i++] = x;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s,<span class="hljs-type">char</span>[] path,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> u)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x == u)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(path);<br>            <span class="hljs-keyword">if</span>(!con.contains(st)) <br>                con.add(st);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; u; i++)&#123;<br>            <span class="hljs-keyword">if</span>(flag[i] == <span class="hljs-number">0</span>)&#123;<br>                flag[i] = <span class="hljs-number">1</span>;<br>                path[x] = s.charAt(i);<br>                dfs(s,path,x+<span class="hljs-number">1</span>,u);<br>                flag[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h3><blockquote><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p><p>1 &lt;&#x3D; candidates.length &lt;&#x3D; 30<br>1 &lt;&#x3D; candidates[i] &lt;&#x3D; 200<br>candidate 中的每个元素都 互不相同<br>1 &lt;&#x3D; target &lt;&#x3D; 500</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        dfs(candidates,path,<span class="hljs-number">0</span>,target);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates,List&lt;Integer&gt; path, <span class="hljs-type">int</span> deep, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (deep == candidates.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 直接跳过</span><br>        dfs(candidates,path,deep+<span class="hljs-number">1</span>,target);<br>        <span class="hljs-comment">// 选择当前数</span><br>        <span class="hljs-keyword">if</span> (target - candidates[deep] &gt;= <span class="hljs-number">0</span>) &#123;<br>            path.add(candidates[deep]);<br>            dfs(candidates,path,deep,target-candidates[deep]);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><blockquote><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(nums,path,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;Integer&gt; path, <span class="hljs-type">int</span> deep)</span>&#123;<br>        <span class="hljs-keyword">if</span>(deep == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(nums,path,deep+<span class="hljs-number">1</span>);<br>        path.add(nums[deep]);<br>        dfs(nums,path,deep+<span class="hljs-number">1</span>);<br>        path.remove(path.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><blockquote><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><img src="/leetcode.assets/word2.jpg" alt="img"></p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length, n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == word.charAt(<span class="hljs-number">0</span>))&#123;<br>                    <span class="hljs-keyword">if</span>(dfs(board,word,<span class="hljs-number">0</span>,i,j) == <span class="hljs-literal">true</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> deep,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(word.length() == deep) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length, n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n || board[i][j] != word.charAt(deep)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">loc</span> <span class="hljs-operator">=</span> board[i][j];<br>        board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(board,word,deep+<span class="hljs-number">1</span>,i-<span class="hljs-number">1</span>,j) || dfs(board,word,deep+<span class="hljs-number">1</span>,i,j+<span class="hljs-number">1</span>)<br>                    || dfs(board,word,deep+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>,j) || dfs(board,word,deep+<span class="hljs-number">1</span>,i,j-<span class="hljs-number">1</span>);<br>        board[i][j] = loc;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1123-最深叶节点的最近公共祖先"><a href="#1123-最深叶节点的最近公共祖先" class="headerlink" title="1123. 最深叶节点的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves">1123. 最深叶节点的最近公共祖先</a></h3><blockquote><p>给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer,List&lt;TreeNode&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        preorder(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ancesstor(root,map.get(max).get(<span class="hljs-number">0</span>),map.get(max).get(map.get(max).size()-<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(map.get(n) == <span class="hljs-literal">null</span>)&#123;<br>            map.put(n,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()&#123;&#123;add(node);&#125;&#125;);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            map.get(n).add(node);<br>        &#125;<br>        max = Math.max(max,n);<br>        preorder(node.left,n+<span class="hljs-number">1</span>);<br>        preorder(node.right,n+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">ancesstor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> ancesstor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> ancesstor(root.right,p,q);<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span>? right:left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h3><blockquote><p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, fast = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; n) &#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != nums[fast-<span class="hljs-number">1</span>])&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h3><blockquote><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != val)&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h3><blockquote><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p><p>输入：nums &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3<br>输出：10<br>解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 10。</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>nums[i] 不是 0 就是 1<br>0 &lt;&#x3D; k &lt;&#x3D; nums.length</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; n)&#123;<br>            cnt += nums[r] == <span class="hljs-number">1</span>? <span class="hljs-number">0</span>: <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(cnt &gt; k)&#123;<br>                cnt -= nums[l] == <span class="hljs-number">1</span>? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>                l++;<br>            &#125;<br>            max = Math.max(r-l+<span class="hljs-number">1</span>,max);<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208. 尽可能使字符串相等"></a><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></h3><blockquote><p>给你两个长度相同的字符串，s 和 t。</p><p>将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p><p>示例 1：</p><p>输入：s &#x3D; “abcd”, t &#x3D; “bcdf”, maxCost &#x3D; 3<br>输出：3<br>解释：s 中的 “abc” 可以变为 “bcd”。开销为 3，所以最大长度为 3。<br>示例 2：</p><p>输入：s &#x3D; “abcd”, t &#x3D; “cdef”, maxCost &#x3D; 3<br>输出：1<br>解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。<br>示例 3：</p><p>输入：s &#x3D; “abcd”, t &#x3D; “acde”, maxCost &#x3D; 0<br>输出：1<br>解释：a -&gt; a, cost &#x3D; 0，字符串未发生变化，所以最大长度为 1。</p><p>提示：</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 10^5<br>0 &lt;&#x3D; maxCost &lt;&#x3D; 10^6<br>s 和 t 都只含小写英文字母。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> maxCost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(),n = t.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; m &amp;&amp; r &lt; n)&#123;<br>            maxCost -= Math.abs(s.charAt(r) - t.charAt(r));<br>            <span class="hljs-keyword">while</span>(maxCost &lt; <span class="hljs-number">0</span>)&#123;<br>                maxCost += Math.abs(s.charAt(l) - t.charAt(l));<br>                l++;<br>            &#125;<br>            max = Math.max(max,r-l+<span class="hljs-number">1</span>);<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h3><blockquote><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p><p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ABAB&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;AABABBA&quot;</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">4</span><br>解释：<br>将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 <span class="hljs-string">&quot;AABBBBA&quot;</span>。<br>子串 <span class="hljs-string">&quot;BBBB&quot;</span> 有最长重复字母, 答案为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 仅由大写英文字母组成</li><li><code>0 &lt;= k &lt;= s.length</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; n)&#123;<br>            nums[s.charAt(r)-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            max = Math.max(max,nums[s.charAt(r)-<span class="hljs-string">&#x27;A&#x27;</span>]);<br>            <span class="hljs-keyword">if</span>(r - l + <span class="hljs-number">1</span> - max &gt; k) &#123;<br>                nums[s.charAt(l)-<span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                l++;<br>            &#125;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r - l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2024-考试的最大困扰度"><a href="#2024-考试的最大困扰度" class="headerlink" title="2024. 考试的最大困扰度"></a><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">2024. 考试的最大困扰度</a></h3><blockquote><p>一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 ‘T’ 表示）或者 false （用 ‘F’ 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p><p>给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：</p><p>每次操作中，将问题的正确答案改为 ‘T’ 或者 ‘F’ （也就是将 answerKey[i] 改为 ‘T’ 或者 ‘F’ ）。<br>请你返回在不超过 k 次操作的情况下，最大 连续 ‘T’ 或者 ‘F’ 的数目。</p><p>输入：answerKey &#x3D; “TTFF”, k &#x3D; 2<br>输出：4<br>解释：我们可以将两个 ‘F’ 都变为 ‘T’ ，得到 answerKey &#x3D; “TTTT” 。<br>总共有四个连续的 ‘T’ 。</p><p>n &#x3D;&#x3D; answerKey.length<br>1 &lt;&#x3D; n &lt;&#x3D; 5 * 104<br>answerKey[i] 要么是 ‘T’ ，要么是 ‘F’<br>1 &lt;&#x3D; k &lt;&#x3D; n</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxConsecutiveAnswers</span><span class="hljs-params">(String answerKey, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.max(solve(answerKey,<span class="hljs-string">&#x27;T&#x27;</span>,k),solve(answerKey,<span class="hljs-string">&#x27;F&#x27;</span>,k));<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(String answerKey,<span class="hljs-type">char</span> ch,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> answerKey.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>; r &lt; n; r++)&#123;<br>            sum += answerKey.charAt(r) == ch?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(sum &gt; k)&#123;<br>                sum -= answerKey.charAt(l++) == ch? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>            &#125;<br>            ans = Math.max(r-l+<span class="hljs-number">1</span>,ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water">42. 接雨水</a></h3><blockquote><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="/leetcode.assets/rainwatertrap.png" alt="img"></p><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> height[<span class="hljs-number">0</span>],right = height[height.length-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>            <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<br>                <span class="hljs-keyword">if</span>(height[i] &lt; left) &#123;<br>                    res += left -height[i];<br>                &#125;<br>                <span class="hljs-type">else</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> height[i];<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(height[j] &lt; right) &#123;<br>                    res += right -height[j];<br>                &#125;<br>                <span class="hljs-type">else</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> height[j];<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h3><blockquote><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br>输入：nums = <span class="hljs-comment">[3,2,1]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br>输入：nums = <span class="hljs-comment">[1,1,5]</span><br>输出：<span class="hljs-comment">[1,5,1]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[r-<span class="hljs-number">1</span>] &lt; nums[r]) <span class="hljs-keyword">break</span>;<br>            r--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r == <span class="hljs-number">0</span>)&#123;<br>            reverse(<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>,nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[r-<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rr</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(nums[rr] &lt;= x) rr--;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[rr];<br>            nums[rr] = nums[r-<span class="hljs-number">1</span>];<br>            nums[r-<span class="hljs-number">1</span>] = t;<br>            reverse(r,nums.length-<span class="hljs-number">1</span>,nums);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[l];<br>            nums[l] = nums[r];<br>            nums[r] = t;<br>            l ++;<br>            r --;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分治-amp-递归"><a href="#分治-amp-递归" class="headerlink" title="分治&amp;递归"></a>分治&amp;递归</h2><h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h3><blockquote><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。<img src="/leetcode.assets/uniquebstn3.jpg" alt="img"></p><p>输入：n &#x3D; 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</p></blockquote><p>思路：当确定根节点后，就能确定左右子树了，子树同理，可以枚举每次的根节点，难点在于怎么将子树合并，可以先利用一个容器，存储所有的子树节点，最后再合并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> solve(<span class="hljs-number">1</span>,n);<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            list.add(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end ; i++)&#123;<br>            List&lt;TreeNode&gt; left = solve(start,i-<span class="hljs-number">1</span>);<br>            List&lt;TreeNode&gt; right = solve(i+<span class="hljs-number">1</span>,end);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x : left)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> y: right)&#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);<br>                    root.left = x;<br>                    root.right = y;<br>                    list.add(root);<br>                &#125;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> list; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><blockquote><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p><img src="/leetcode.assets/tree1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><p>题记：使用递归 或者 中续遍历</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h3><blockquote><p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-number">5</span> 的二进制表示是：<span class="hljs-number">101</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br>        <span class="hljs-keyword">while</span>(((n &amp; (<span class="hljs-number">1</span>&lt;&lt;idx)) == <span class="hljs-number">0</span>))&#123;<br>            idx --;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> n &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= idx; i++)&#123;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(((n&amp;<span class="hljs-number">1</span>) ^ temp) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            temp ^= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3><blockquote><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[4,1,4,6]</span><br>输出：<span class="hljs-selector-attr">[1,6]</span> 或 <span class="hljs-selector-attr">[6,1]</span><br><span class="hljs-number">2</span> &lt;= nums<span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure></blockquote><p>题记：两个相等整数亦或为0，任意整数与0亦或都为本身，由此可知，从集合中分离出一个只存在一次或奇数次的元素(其他元素出现偶数次)，只需要将全部相亦或即可，这里需要分离两次，那么可以使用分组亦或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 挑选出这两个数的亦或值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">eh</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums)&#123;<br>            eh ^= x;<br>        &#125;<br>        <span class="hljs-comment">// 找到他们第一个位不同的位置，之后我们就利用这个位置来对序列进行分组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>((eh &amp; index) == <span class="hljs-number">0</span>)&#123;<br>            index &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums)&#123;<br>            <span class="hljs-comment">// 利用区别定位，分组亦或</span><br>            <span class="hljs-keyword">if</span>((a&amp;index) == <span class="hljs-number">0</span>)&#123;<br>                x ^= a;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                y ^= a;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x,y&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h3><blockquote><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">3,4,3,3</span>]<br>输出：<span class="hljs-number">4</span><br>输入：nums = [<span class="hljs-number">9,1,7,9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">32</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span> ; i++)&#123;<br>                <span class="hljs-keyword">if</span>((x&amp;index) != <span class="hljs-number">0</span>) count[i]++;<br>                index &lt;&lt;= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(count[i] % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)&#123;<br>                res += <span class="hljs-number">1</span>&lt;&lt;i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h3><blockquote><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure></blockquote><p>题记：递推</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; len &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++)&#123;<br>            nums[i] = Math.max(nums[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>,nums[i]);<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span> &amp;&amp; i &lt; len - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></h3><blockquote><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p>输入: nums &#x3D; [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            count ++;<br>            <span class="hljs-keyword">if</span>(fast &gt;= len - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[fast];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> slow; i &lt;= fast; i++)&#123;<br>                temp = Math.max(temp,i - fast + nums[i]);<br>            &#125;<br>            slow = fast;<br>            fast += temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2028-找出缺失的观测数据"><a href="#2028-找出缺失的观测数据" class="headerlink" title="2028. 找出缺失的观测数据"></a><a href="https://leetcode-cn.com/problems/find-missing-observations/">2028. 找出缺失的观测数据</a></h3><blockquote><p>现有一份 n + m 次投掷单个 六面 骰子的观测数据，骰子的每个面从 1 到 6 编号。观测数据中缺失了 n 份，你手上只拿到剩余 m 次投掷的数据。幸好你有之前计算过的这 n + m 次投掷数据的 平均值 。</p><p>给你一个长度为 m 的整数数组 rolls ，其中 rolls[i] 是第 i 次观测的值。同时给你两个整数 mean 和 n 。</p><p>返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p><p>k 个数字的 平均值 为这些数字求和后再除以 k 。</p><p>注意 mean 是一个整数，所以 n + m 次投掷的总和需要被 n + m 整除。</p><p>输入：rolls &#x3D; [3,2,4,3], mean &#x3D; 4, n &#x3D; 2<br>输出：[6,6]<br>解释：所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) &#x2F; 6 &#x3D; 4 。</p><p>输入：rolls &#x3D; [1,5,6], mean &#x3D; 3, n &#x3D; 4<br>输出：[2,3,2,2]<br>解释：所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) &#x2F; 7 &#x3D; 3 。</p><ul><li><code>m == rolls.length</code></li><li><code>1 &lt;= n, m &lt;= 105</code></li><li><code>1 &lt;= rolls[i], mean &lt;= 6</code></li></ul></blockquote><p>题记：数据量小的话可以用dfs，数据量大用贪心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] missingRolls(<span class="hljs-type">int</span>[] rolls, <span class="hljs-type">int</span> mean, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">part</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x : rolls) part += x;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">missSum</span> <span class="hljs-operator">=</span> mean*(n+rolls.length) - part;<br>        <span class="hljs-keyword">if</span>(missSum &gt; <span class="hljs-number">6</span>*n || missSum &lt; n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> missSum % n;<br>        Arrays.fill(res,missSum/n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res[i] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><blockquote><p>给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。</p><p>如果无解，请返回-1.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[5,2,3]</span>,<span class="hljs-number">20</span><br>返回值：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><p><img src="/leetcode.assets/image-20220330234824924.png" alt="思路"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMoney</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> aim)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> aim + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max];<br>        <span class="hljs-comment">// 假设需要aim+1次 除了dp[0]很关键。</span><br>        Arrays.fill(dp,max);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; aim + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(arr[j] &lt;= i)&#123;<br>                    dp[i] = Math.min(dp[i],dp[i-arr[j]]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[aim] &gt; aim ? -<span class="hljs-number">1</span>:dp[aim];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单串"><a href="#单串" class="headerlink" title="单串"></a>单串</h3><p><strong>1. 依赖比 i 小的 O(1) 个子问题</strong></p><p><strong>2. 依赖比 i 小的 O(n) 个子问题</strong></p><h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><strong>最长上升子序列</strong></h4><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br><br></code></pre></td></tr></table></figure></blockquote><p>题记：依赖比i小的O(n)个子问题型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            dp[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            max = Math.max(max,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最长递增子序列的个数"><a href="#最长递增子序列的个数" class="headerlink" title="最长递增子序列的个数"></a><strong>最长递增子序列的个数</strong></h4><blockquote><p>给定一个未排序的整数数组 <code>nums</code> ， <em>返回最长递增子序列的个数</em> 。</p><p><strong>注意</strong> 这个数列必须是 <strong>严格</strong> 递增的。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,4,7]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br><span class="hljs-section">输入: [2,2,2,2,2]</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</span><br></code></pre></td></tr></table></figure></blockquote><p>题记：依赖比i小的O(n)个子问题型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNumberOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        Arrays.fill(count,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            dp[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i ;j++)&#123; <br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) &#123;<br>                    <span class="hljs-keyword">if</span>(dp[i] &lt;= dp[j])&#123;<br>                        dp[i] = dp[j] + <span class="hljs-number">1</span>;<br>                        count[i] = count[j];<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i] == dp[j]+<span class="hljs-number">1</span>)&#123;<br>                        count[i] += count[j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            maxLen = Math.max(maxLen,dp[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i] == maxLen) &#123;<br>                ans += count[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="55-跳跃游戏-1"><a href="#55-跳跃游戏-1" class="headerlink" title="55. 跳跃游戏"></a><strong><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></strong></h4><blockquote><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure></blockquote><p>题记：依赖比i小O(1)的子问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; len &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++)&#123;<br>            nums[i] = Math.max(nums[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>,nums[i]);<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span> &amp;&amp; i &lt; len - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><strong><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></strong></h4><blockquote><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-number">12258</span><br>输出: <span class="hljs-number">5</span><br>解释: <span class="hljs-number">12258</span>有<span class="hljs-number">5</span>种不同的翻译，分别是<span class="hljs-string">&quot;bccfi&quot;</span>, <span class="hljs-string">&quot;bwfi&quot;</span>, <span class="hljs-string">&quot;bczi&quot;</span>, <span class="hljs-string">&quot;mcfi&quot;</span>和<span class="hljs-string">&quot;mzi&quot;</span><br></code></pre></td></tr></table></figure></blockquote><p>题记：依赖比i小O(1)的子问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// dp[n] = dp[n-1] + dp[n-2]</span><br>    <span class="hljs-comment">// 能不能从n-2跳过来需要判断是否合法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">char</span>[] ch = String.valueOf(num).toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> ch.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= len; i++)&#123;<br>            <span class="hljs-comment">// 为什么不取ch[i-2]&lt;=&#x27;0&#x27;呢，因为 &#x27;01&#x27; 和&#x27;1&#x27; 是同一种方案</span><br>            <span class="hljs-keyword">if</span>(ch[i-<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span> || ch[i-<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; ch[i-<span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;5&#x27;</span>)&#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BM69-把数字翻译成字符串"><a href="#BM69-把数字翻译成字符串" class="headerlink" title="BM69 把数字翻译成字符串"></a><strong>BM69</strong> <strong>把数字翻译成字符串</strong></h4><blockquote><p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p><p>现在给一串数字，返回有多少种可能的译码结果</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">输入：<span class="hljs-string">&quot;12&quot;</span><br>返回值：<span class="hljs-number">2</span><br><span class="hljs-number">2</span>种可能的译码结果（”<span class="hljs-keyword">ab</span>” 或”<span class="hljs-keyword">l</span>”）  <br></code></pre></td></tr></table></figure></blockquote><p>题记：这道题目很像爬楼梯，一次能爬一层和爬两层，只是爬的过程中增加了一些限定条件，只要将这些限定条件屡清楚则可以完全搞懂这类题目~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">solve</span> <span class="hljs-params">(String nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length() == <span class="hljs-number">0</span> || nums.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length()];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++)&#123;<br>            <span class="hljs-comment">// 当前位如果不是0的话那就可以单独译码</span><br>            <span class="hljs-keyword">if</span>(nums.charAt(i) != <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                dp[i] = dp[i-<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 判断是否可以两位共同译码</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (nums.charAt(i-<span class="hljs-number">1</span>)-<span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span> + (nums.charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">10</span> &amp;&amp; num &lt;= <span class="hljs-number">26</span>)&#123;<br>                <span class="hljs-comment">// 特殊判断</span><br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>                    dp[i] += <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i] += dp[i-<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length()-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双串"><a href="#双串" class="headerlink" title="双串"></a>双串</h3><h4 id="BM66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66 最长公共子串"></a><strong>BM66</strong> <strong>最长公共子串</strong></h4><blockquote><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串</p><p>题目保证str1和str2的最长公共子串存在且唯一。 </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;1AB2345CD&quot;</span>,<span class="hljs-string">&quot;12345EF&quot;</span><br>返回值：<span class="hljs-string">&quot;2345&quot;</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">LCS</span> <span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> str1.length(), n = str2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(str1.charAt(i) == str2.charAt(j))&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] &gt; maxLen) &#123;<br>                        maxLen = dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];<br>                        index = i;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str1.substring(index-maxLen+<span class="hljs-number">1</span>,index+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BM65-最长公共子序列-二"><a href="#BM65-最长公共子序列-二" class="headerlink" title="BM65 最长公共子序列(二)"></a><strong>BM65</strong> <strong>最长公共子序列(二)</strong></h4><blockquote><p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;1A2C3D4B56&quot;</span>,<span class="hljs-string">&quot;B1D23A456A&quot;</span><br>返回值：<span class="hljs-string">&quot;123456&quot;</span><br></code></pre></td></tr></table></figure></blockquote><p><img src="/leetcode.assets/image-20220330212240015.png" alt="最长公共子序列"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">LCS</span> <span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s1.charAt(i-<span class="hljs-number">1</span>) == s2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>       <span class="hljs-keyword">if</span>(dp[m][n]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>       <span class="hljs-type">char</span>[] lcs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[dp[m][n]];<br>       <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> lcs.length - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>           <span class="hljs-keyword">if</span> (s1.charAt(m - <span class="hljs-number">1</span>) == s2.charAt(n - <span class="hljs-number">1</span>)) &#123;<br>               lcs[cur--] = s1.charAt(m - <span class="hljs-number">1</span>);<br>               <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(lcs);<br>               m--;<br>               n--;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">if</span> (dp[m - <span class="hljs-number">1</span>][n] &gt; dp[m][n - <span class="hljs-number">1</span>]) &#123;<br>                   m--;<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   n--;<br>               &#125;<br>           &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><strong><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></strong></h4><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><img src="/leetcode.assets/robot_maze.png" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure></blockquote><p>题记：经典dp，写出状态转移方程，处理初始值即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><strong><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></strong></h4><blockquote><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><img src="/leetcode.assets/minpath.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure></blockquote><p>题记：矩阵dp考虑四个方向即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            grid[i][<span class="hljs-number">0</span>] += grid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; grid.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;<br>                grid[i][j] += Math.min(grid[i-<span class="hljs-number">1</span>][j],grid[i][j-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="等式方程的可满足性"><a href="#等式方程的可满足性" class="headerlink" title="等式方程的可满足性"></a>等式方程的可满足性</h3><blockquote><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a&#x3D;&#x3D;b” 或 “a!&#x3D;b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：[<span class="hljs-string">&quot;b==a&quot;</span>,<span class="hljs-string">&quot;a==b&quot;</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：我们可以指定 <span class="hljs-attr">a</span> = <span class="hljs-number">1</span> 且 <span class="hljs-attr">b</span> = <span class="hljs-number">1</span> 以满足满足这两个方程。<br><br>输入：[<span class="hljs-string">&quot;a==b&quot;</span>,<span class="hljs-string">&quot;b!=a&quot;</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：如果我们指定，<span class="hljs-attr">a</span> = <span class="hljs-number">1</span> 且 <span class="hljs-attr">b</span> = <span class="hljs-number">1</span>，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。<br></code></pre></td></tr></table></figure></blockquote><h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h3><blockquote><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p><img src="/leetcode.assets/graph1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：isConnected = <span class="hljs-string">[[1,1,0],[1,1,0],[0,0,1]]</span><br>输出：<span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><p><img src="/leetcode.assets/graph2.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：isConnected = <span class="hljs-selector-attr">[[1,0,0]</span>,<span class="hljs-selector-attr">[0,1,0]</span>,<span class="hljs-selector-attr">[0,0,1]</span>]<br>输出：<span class="hljs-number">3</span><br><br><span class="hljs-number">1</span> &lt;= n &lt;= <span class="hljs-number">200</span><br>n == isConnected<span class="hljs-selector-class">.length</span><br>n == isConnected<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.length</span><br>isConnected<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 为 <span class="hljs-number">1</span> 或 <span class="hljs-number">0</span><br>isConnected<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[i]</span> == <span class="hljs-number">1</span><br>isConnected<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> == isConnected<span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[i]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">210</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span>(x != p[x]) p[x] = find(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] isConnected)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> isConnected.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">province</span> <span class="hljs-operator">=</span> n; <span class="hljs-comment">// 先假设这些城市都没连通 有n个省份</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            count[i] = <span class="hljs-number">1</span>;<br>            p[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(isConnected[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> find(i);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">pj</span> <span class="hljs-operator">=</span> find(j);<br>                    <span class="hljs-keyword">if</span>(pj != pi)&#123;<br>                        p[pi] = pj;<br>                        province --; <span class="hljs-comment">// 连通一个建一个省份</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a>冗余连接</h3><blockquote><p>树可以看成是一个连通且 无环 的 无向 图。</p><p>给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] &#x3D; [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p><p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p><p><img src="/leetcode.assets/1626676174-hOEVUL-image.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: edges = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,3]</span>, <span class="hljs-comment">[2,3]</span>]</span><br>输出: <span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><p><img src="/leetcode.assets/1626676179-kGxcmu-image.png" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: edges = <span class="hljs-selector-attr">[[1,2]</span>, <span class="hljs-selector-attr">[2,3]</span>, <span class="hljs-selector-attr">[3,4]</span>, <span class="hljs-selector-attr">[1,4]</span>, <span class="hljs-selector-attr">[1,5]</span>]<br>输出: <span class="hljs-selector-attr">[1,4]</span><br><br>n == edges<span class="hljs-selector-class">.length</span><br><span class="hljs-number">3</span> &lt;= n &lt;= <span class="hljs-number">1000</span><br>edges<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">2</span><br><span class="hljs-number">1</span> &lt;= ai &lt; bi &lt;= edges<span class="hljs-selector-class">.length</span><br>ai != bi<br>edges 中无重复元素<br>给定的图是连通的 <br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span>[] p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1010</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x != p[x]) p[x] = find(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findRedundantConnection(<span class="hljs-type">int</span>[][] edges) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> edges.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) p[i] = i;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> edge: edges)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> find(edge[<span class="hljs-number">0</span>]), pj = find(edge[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span>(pi == pj) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;edge[<span class="hljs-number">0</span>],edge[<span class="hljs-number">1</span>]&#125;;<br>                p[pi] = pj;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h3><blockquote><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><img src="/leetcode.assets/mat1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure></blockquote><p>题记：水平翻转+主对角线翻转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">// 水平翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n - i - <span class="hljs-number">1</span>][j];<br>                matrix[n - i - <span class="hljs-number">1</span>][j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 主对角线翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="牛客Top101"><a href="#牛客Top101" class="headerlink" title="牛客Top101"></a>牛客Top101</h1><h2 id="①链表"><a href="#①链表" class="headerlink" title="①链表"></a><strong>①链表</strong></h2><h3 id="BM1-反转链表"><a href="#BM1-反转链表" class="headerlink" title="BM1 反转链表"></a><strong>BM1</strong> <strong>反转链表</strong></h3><blockquote><p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p><p>要求：空间复杂度 O(1) ，时间复杂度 O*(*n) 。</p><p><img src="/leetcode.assets/4A47A0DB6E60853DEDFCFDF08A5CA249" alt="img"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 头插</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">ReverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">myhead</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = myhead;<br>            myhead = head;<br>            head = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> myhead;<br>    &#125;    <br>    <span class="hljs-comment">// 递归</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">ReverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">myHead</span> <span class="hljs-operator">=</span> ReverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> myHead;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a><strong>BM2</strong> <strong>链表内指定区间反转</strong></h3><blockquote><p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)<em>O</em>(<em>n</em>)，空间复杂度 O(1)。<br>例如：<br>给出的链表为 1→2→3→4→5→null, m&#x3D;2,n&#x3D;4<br>返回 1→4→3→2→5→null</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：&#123;<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>&#125;,<span class="hljs-number">2</span>,<span class="hljs-number">4</span><br>返回值：&#123;<span class="hljs-number">1,4,3,2</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *   int val;</span><br><span class="hljs-comment"> *   ListNode next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span> <span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">myhead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        myhead.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> myhead, cur = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m; i &lt; n; i++)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = temp.next;<br>            temp.next = pre.next;<br>            pre.next = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> myhead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a><strong>BM3</strong> <strong>链表中的节点每k个一组翻转</strong></h3><blockquote><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p><p>数据范围：0≤<em>n</em>≤2000 ，1≤<em>k</em>≤2000 ，链表中每个元素都满足 0≤<em>v<strong>a</strong>l</em>≤1000<br>要求空间复杂度 O(1)，时间复杂度 O(n)</p><p>例如：</p><p>给定的链表是 1→2→3→4→5</p><p>对于 k &#x3D; 2 , 你应该返回2→1→4→3→5</p><p>对于 k &#x3D; 3, 你应该返回 3→2→1→4→5</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：&#123;<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>&#125;,<span class="hljs-number">2</span><br>返回值：&#123;<span class="hljs-number">2,1,4,3</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span> <span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            <span class="hljs-keyword">if</span>(tail == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>            tail = tail.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>,cur = head;<br>        <span class="hljs-keyword">while</span>(cur != tail)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        head.next = reverseKGroup(tail,k);<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="②二分查找-x2F-排序"><a href="#②二分查找-x2F-排序" class="headerlink" title="②二分查找&#x2F;排序"></a><strong>②二分查找&#x2F;排序</strong></h2><h2 id="③二叉树"><a href="#③二叉树" class="headerlink" title="③二叉树"></a><strong>③二叉树</strong></h2><h2 id="④堆-x2F-栈-x2F-队列"><a href="#④堆-x2F-栈-x2F-队列" class="headerlink" title="④堆&#x2F;栈&#x2F;队列"></a><strong>④堆&#x2F;栈&#x2F;队列</strong></h2><h3 id="BM42-用两个栈实现队列"><a href="#BM42-用两个栈实现队列" class="headerlink" title="BM42 用两个栈实现队列"></a><strong>BM42</strong> <strong>用两个栈实现队列</strong></h3><blockquote><p>用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p><p>数据范围： n*≤1000</p><p>要求：存储n个元素的空间复杂度为 O*(*n) ，插入与删除的时间复杂度都是 O(1)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：[<span class="hljs-string">&quot;PSH1&quot;</span>,<span class="hljs-string">&quot;PSH2&quot;</span>,<span class="hljs-string">&quot;POP&quot;</span>,<span class="hljs-string">&quot;POP&quot;</span>]<br>返回值：<span class="hljs-number">1</span>,<span class="hljs-number">2</span><br><span class="hljs-string">&quot;PSH1&quot;</span>:代表将<span class="hljs-number">1</span>插入队列尾部<br><span class="hljs-string">&quot;PSH2&quot;</span>:代表将<span class="hljs-number">2</span>插入队列尾部<br><span class="hljs-string">&quot;POP“:代表删除一个元素，先进先出=&gt;返回1</span><br><span class="hljs-string">&quot;POP“:代表删除一个元素，先进先出=&gt;返回2    </span><br><br>输入：[<span class="hljs-string">&quot;PSH2&quot;</span>,<span class="hljs-string">&quot;POP&quot;</span>,<span class="hljs-string">&quot;PSH1&quot;</span>,<span class="hljs-string">&quot;POP&quot;</span>]<br>返回值：<span class="hljs-number">2</span>,<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br>        <span class="hljs-keyword">while</span>(!stack2.isEmpty())&#123;<br>            stack1.push(stack2.pop());<br>        &#125;<br>        stack1.push(node);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;<br>            stack2.push(stack1.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM43-包含min函数的栈"><a href="#BM43-包含min函数的栈" class="headerlink" title="BM43 包含min函数的栈"></a><strong>BM43</strong> <strong>包含min函数的栈</strong></h3><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。</p><p>此栈包含的方法有：</p><p>push(value):将value压入栈中</p><p>pop():弹出栈顶元素</p><p>top():获取栈顶元素</p><p>min():获取栈中最小元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    Stack&lt;Integer&gt; sup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br>        stack.push(node);<br>        <span class="hljs-keyword">if</span>(sup.isEmpty())&#123;<br>            sup.push(node);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sup.peek() &gt;= node)&#123;<br>            sup.push(node);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(stack.pop().equals(sup.peek()))&#123;<br>            sup.pop();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sup.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM44-有效括号序列"><a href="#BM44-有效括号序列" class="headerlink" title="BM44 有效括号序列"></a><strong>BM44</strong> <strong>有效括号序列</strong></h3><blockquote><p>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</p><p>数据范围：字符串长度 0≤<em>n</em>≤10000</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：<span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>返回值：<span class="hljs-literal">true</span><br>输入：<span class="hljs-string">&quot;[]&quot;</span><br>返回值：<span class="hljs-literal">true</span><br>输入：<span class="hljs-string">&quot;([)]&quot;</span><br>返回值：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></blockquote><p>题记：可以使用一个map，当然使用if更快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span> <span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Map&lt;Character,Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character,Character&gt;()&#123;&#123;<br>            put(<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>);<br>        &#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span>(map.containsValue(ch))&#123;<br>                stack.push(ch);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(!stack.isEmpty() &amp;&amp; map.get(ch) == stack.peek())<br>                    stack.pop();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⑤哈希"><a href="#⑤哈希" class="headerlink" title="⑤哈希"></a><strong>⑤哈希</strong></h2><h3 id="BM50-两数之和"><a href="#BM50-两数之和" class="headerlink" title="BM50 两数之和"></a><strong>BM50</strong> <strong>两数之和</strong></h3><blockquote><p>给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。</p><p>（注：<strong>返回</strong>的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到）</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<span class="hljs-comment">[3,2,4]</span>,6<br>返回值：<span class="hljs-comment">[2,3]</span><br>说明：因为 2+4=6 ，而 2的下标为2 ， 4的下标为3 ，又因为 下标2 &lt; 下标3 ，所以返回<span class="hljs-comment">[2,3]</span>   <br>输入：<span class="hljs-comment">[20,70,110,150]</span>,90<br>返回值：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum (<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numbers.length; i++) &#123;<br>            <span class="hljs-comment">//将不包含target - numbers[i]，装入map中，包含的话直接返回下标</span><br>            <span class="hljs-comment">//注意放回大小顺序</span><br>            <span class="hljs-keyword">if</span>(map.containsKey(target - numbers[i])) <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(target - numbers[i])+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>&#125;;<br>            <span class="hljs-keyword">else</span> <br>                map.put(numbers[i], i);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;No solution&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM51-数组中出现次数超过一半的数字"><a href="#BM51-数组中出现次数超过一半的数字" class="headerlink" title="BM51 数组中出现次数超过一半的数字"></a><strong>BM51</strong> <strong>数组中出现次数超过一半的数字</strong></h3><blockquote><p>给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p><p>数据范围：n≤50000</p><p>要求：空间复杂度：O(1)，时间复杂度 O(n)</p><p>保证数组输入非空，且保证有解</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,2,3,2</span>,<span class="hljs-number">2,2,5,4</span>,<span class="hljs-number">2</span>]<br>返回值：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">MoreThanHalfNum_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> [] array)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cond</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>,cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : array)&#123;<br>            <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br>                cond = x;<br>                cnt ++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(cond == x)&#123;<br>                    cnt ++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cnt--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cond;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM52-数组中只出现一次的两个数字"><a href="#BM52-数组中只出现一次的两个数字" class="headerlink" title="BM52 数组中只出现一次的两个数字"></a><strong>BM52</strong> <strong>数组中只出现一次的两个数字</strong></h3><blockquote><p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p>数据范围：数组长度2≤<em>n</em>≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>提示：输出时按非降序排列。</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,4,1,6]</span><br>返回值：<span class="hljs-selector-attr">[4,6]</span><br>输入：<span class="hljs-selector-attr">[1,2,3,3,2,9]</span><br>返回值：<span class="hljs-selector-attr">[1,9]</span><br>说明：返回的结果中较小的数排在前面    <br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array int整型一维数组 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型一维数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] FindNumsAppearOnce (<span class="hljs-type">int</span>[] array) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : array) sum ^= x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(((sum &gt;&gt; i) &amp; <span class="hljs-number">1</span> )== <span class="hljs-number">1</span>)&#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t : array)&#123;<br>            <span class="hljs-keyword">if</span>(((t &gt;&gt; index) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                x ^= t;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                y ^= t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;Math.min(x,y),Math.max(x,y)&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a><strong>BM53</strong> <strong>缺失的第一个正整数</strong></h3><blockquote><p>给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数</p><p>进阶： 空间复杂度 O*(1)，时间复杂度 O(n)*</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[-2,3,4,1,5]</span><br>返回值：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minNumberDisappeared</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[i] != nums[nums[i]-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[nums[i]-<span class="hljs-number">1</span>];<br>                nums[nums[i]-<span class="hljs-number">1</span>] = nums[i];<br>                nums[i] = t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums)&#123;<br>            <span class="hljs-keyword">if</span>(x != ++i) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM54-三数之和"><a href="#BM54-三数之和" class="headerlink" title="BM54 三数之和"></a><strong>BM54</strong> <strong>三数之和</strong></h3><blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c&#x3D;0？找出数组S中所有满足条件的三元组。</p><p>数据范围：0≤<em>n</em>≤3000</p><p>空间复杂度：O(n^2)，时间复杂度 O(n^2)</p><p>注意：</p><ol><li>三元组（a、b、c）中的元素可以按任意顺序排列。</li><li>解集中不能包含重复的三元组。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs \">输入：[-10,0,10,20,-10,-40]<br>返回值：[[-10,-10,20],[-10,0,10]]<br>输入：[-2,0,1,1,2]<br>返回值：[[-2,0,2],[-2,1,1]]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] num)</span> &#123;<br>        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> num.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res; <br>        Arrays.sort(num);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n ; i++)&#123;<br>            <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt; n &amp;&amp; num[i] == num[i-<span class="hljs-number">1</span>]) i++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>, k = n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; k)&#123;<br>                <span class="hljs-keyword">if</span>(num[i]+num[j]+num[k]==<span class="hljs-number">0</span>)&#123;<br>                    ArrayList&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                    temp.add(num[i]);<br>                    temp.add(num[j]);<br>                    temp.add(num[k]);<br>                    res.add(temp);<br>                    k--;<br>                    j++;<br>                    <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; num[j] == num[j-<span class="hljs-number">1</span>]) j++;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num[i]+num[j]+num[k] &lt; <span class="hljs-number">0</span>)&#123;<br>                    j++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    k--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⑥递归-x2F-回溯"><a href="#⑥递归-x2F-回溯" class="headerlink" title="⑥递归&#x2F;回溯"></a><strong>⑥递归&#x2F;回溯</strong></h2><h3 id="BM55-没有重复项数字的全排列"><a href="#BM55-没有重复项数字的全排列" class="headerlink" title="BM55 没有重复项数字的全排列"></a><strong>BM55</strong> <strong>没有重复项数字的全排列</strong></h3><blockquote><p>给出一组数字，返回该组数字的所有排列</p><p>例如：</p><p>[1,2,3]的所有排列如下<br>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].<br>（以数字在数组中的位置靠前为优先级，按字典序排列输出。）</p><p>数据范围：数字个数 0 &lt;&#x3D; n &lt;&#x3D; 6</p><p>要求：空间复杂度O*(*n!) ，时间复杂度 O(n!）</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;输入：<span class="hljs-comment">[1,2,3]</span><br>返回值：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：[<span class="hljs-number">1</span>]<br>返回值：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] num)</span> &#123;<br>        ArrayList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] status = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num.length];<br>        dfs(path,num,<span class="hljs-number">0</span>,status);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(ArrayList&lt;Integer&gt; path, <span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> deep, <span class="hljs-type">int</span>[] status)</span>&#123;<br>        <span class="hljs-keyword">if</span>(deep == nums.length) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(status[i] == <span class="hljs-number">0</span>)&#123;<br>                status[i] = <span class="hljs-number">1</span>;<br>                path.add(nums[i]);<br>                dfs(path,nums,deep+<span class="hljs-number">1</span>,status);<br>                path.remove(deep);<br>                status[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM56-有重复项数字的全排列"><a href="#BM56-有重复项数字的全排列" class="headerlink" title="BM56 有重复项数字的全排列"></a><strong>BM56</strong> <strong>有重复项数字的全排列</strong></h3><blockquote><p>给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。</p><p>数据范围： 0&lt;<em>n</em>≤8 ，数组中的值满足 −1≤val≤5</p><p>要求：空间复杂度O*(*n!) ，时间复杂度 O(n!）</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[1,1,2]</span><br>返回值：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] num)</span> &#123;<br>        ArrayList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] status = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num.length];<br>        Arrays.sort(num); <span class="hljs-comment">// 字典序输出，需要排序，也利于后续去重的比较规则</span><br>        dfs(path,num,<span class="hljs-number">0</span>,status);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(ArrayList&lt;Integer&gt; path, <span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> deep, <span class="hljs-type">int</span>[] status)</span>&#123;<br>        <span class="hljs-keyword">if</span>(deep == nums.length) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span> (status[i] == <span class="hljs-number">1</span> || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; status[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>                status[i] = <span class="hljs-number">1</span>;<br>                path.add(nums[i]);<br>                dfs(path,nums,deep+<span class="hljs-number">1</span>,status);<br>                path.remove(deep);<br>                status[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM57-岛屿数量"><a href="#BM57-岛屿数量" class="headerlink" title="BM57 岛屿数量"></a><strong>BM57</strong> <strong>岛屿数量</strong></h3><blockquote><p>给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p><p>岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。</p><p>输入</p><p>[</p><p>[1,1,0,0,0],</p><p>[0,1,0,1,1],</p><p>[0,0,0,1,1],</p><p>[0,0,0,0,0],</p><p>[0,0,1,1,1]</p><p>]</p><p>对应的输出为3</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0,0]</span>,<span class="hljs-comment">[0,1,0,1,1]</span>,<span class="hljs-comment">[0,0,0,1,1]</span>,<span class="hljs-comment">[0,0,0,0,0]</span>,<span class="hljs-comment">[0,0,1,1,1]</span>]</span><br>返回值：3<br></code></pre></td></tr></table></figure></blockquote><p>题记：使用BFS也可以，BFS相当于四周扩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断岛屿数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> grid char字符型二维数组 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">solve</span> <span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    cnt++;<br>                    dfs(grid,i,j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        dfs(grid,i-<span class="hljs-number">1</span>,j);<br>        dfs(grid,i,j-<span class="hljs-number">1</span>);<br>        dfs(grid,i+<span class="hljs-number">1</span>,j);<br>        dfs(grid,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM58-字符串的排列"><a href="#BM58-字符串的排列" class="headerlink" title="BM58 字符串的排列"></a><strong>BM58</strong> <strong>字符串的排列</strong></h3><blockquote><p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。</p><p>例如输入字符串ABC,则输出由字符A,B,C所能排列出来的所有字符串ABC,ACB,BAC,BCA,CBA和CAB。</p><p>数据范围：n*&lt;10<br>要求：空间复杂度 O(n!)，时间复杂度 O(n!)*</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-string">&quot;ab&quot;</span><br>返回值：[<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>]<br>返回[<span class="hljs-string">&quot;ba&quot;</span>,<span class="hljs-string">&quot;ab&quot;</span>]也是正确的    <br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> ArrayList&lt;String&gt; <span class="hljs-title function_">Permutation</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span>(str.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>        Arrays.sort(chars);<br>        <span class="hljs-type">boolean</span>[] status = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[str.length()];<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        dfs(chars,path,<span class="hljs-number">0</span>,status);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars,StringBuilder path,<span class="hljs-type">int</span> deep,<span class="hljs-type">boolean</span>[] status)</span>&#123;<br>        <span class="hljs-keyword">if</span>(deep == chars.length) &#123;<br>            res.add(path.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(status[i] || i &gt; <span class="hljs-number">0</span> &amp;&amp; chars[i] == chars[i-<span class="hljs-number">1</span>] &amp;&amp; !status[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            status[i] = <span class="hljs-literal">true</span>;<br>            path.append(chars[i]);<br>            dfs(chars,path,deep+<span class="hljs-number">1</span>,status);<br>            path.deleteCharAt(path.length()-<span class="hljs-number">1</span>);<br>            status[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM59-N皇后问题"><a href="#BM59-N皇后问题" class="headerlink" title="BM59 N皇后问题"></a><strong>BM59</strong> <strong>N皇后问题</strong></h3><blockquote><p>N 皇后问题是指在 n * n 的棋盘上要摆 n 个皇后，<br>要求：任何两个皇后不同行，不同列也不在同一条斜线上，<br>求给一个整数 n ，返回 n 皇后的摆法数。</p><p>数据范围: 1≤<em>n</em>≤9</p><p>要求：空间复杂度 O(1) ，时间复杂度 O(n!)</p><p><img src="/leetcode.assets/image-20220331155200232.png" alt="n-queens"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">输入：1<br>返回值：1<br>输入：8<br>返回值：92<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span>[] col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span>[] dg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30</span>];<br>    <span class="hljs-type">int</span>[] udg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30</span>];<br>    <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Nqueen</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>,n,board);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> deep, <span class="hljs-type">int</span> n,<span class="hljs-type">char</span>[][] board)</span>&#123;<br>        <span class="hljs-keyword">if</span>(deep == n)&#123;<br>            cnt ++;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n ; i++)&#123;<br>            <span class="hljs-keyword">if</span>(row[deep] == <span class="hljs-number">0</span> &amp;&amp; col[i] == <span class="hljs-number">0</span> &amp;&amp; dg[deep+i] == <span class="hljs-number">0</span> &amp;&amp; udg[i-deep+<span class="hljs-number">15</span>] == <span class="hljs-number">0</span>)&#123;<br>                board[deep][i] = <span class="hljs-string">&#x27;@&#x27;</span>;<br>                row[deep] = <span class="hljs-number">1</span>; col[i] = <span class="hljs-number">1</span>; dg[deep+i] = <span class="hljs-number">1</span>; udg[i-deep+<span class="hljs-number">15</span>] = <span class="hljs-number">1</span>;<br>                dfs(deep+<span class="hljs-number">1</span>,n,board);<br>                row[deep] = <span class="hljs-number">0</span>; col[i] = <span class="hljs-number">0</span>; dg[deep+i] = <span class="hljs-number">0</span>; udg[i-deep+<span class="hljs-number">15</span>] = <span class="hljs-number">0</span>;<br>                board[deep][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;   <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM60-括号生成"><a href="#BM60-括号生成" class="headerlink" title="BM60 括号生成"></a><strong>BM60</strong> <strong>括号生成</strong></h3><blockquote><p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p><p>例如，给出n&#x3D;3，解集为：</p><p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-number">1</span><br>返回值：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;()&quot;</span>]</span><br>输入：<span class="hljs-number">2</span><br>返回值：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;(())&quot;</span>,<span class="hljs-string">&quot;()()&quot;</span>]</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">public</span> ArrayList&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        dfs(<span class="hljs-number">0</span>,n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> deep, <span class="hljs-type">int</span> n,<span class="hljs-type">int</span> open,<span class="hljs-type">int</span> close)</span>&#123;<br>        <span class="hljs-keyword">if</span>(deep == <span class="hljs-number">2</span>*n)&#123;<br>            res.add(path.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(open &lt; n)&#123;<br>            path.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            dfs(deep+<span class="hljs-number">1</span>,n,open+<span class="hljs-number">1</span>,close);<br>            path.deleteCharAt(path.length()-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(close &lt; open)&#123;<br>            path.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            dfs(deep+<span class="hljs-number">1</span>,n,open,close+<span class="hljs-number">1</span>);<br>            path.deleteCharAt(path.length()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM61-矩阵最长递增路径"><a href="#BM61-矩阵最长递增路径" class="headerlink" title="BM61 矩阵最长递增路径"></a><strong>BM61</strong> <strong>矩阵最长递增路径</strong></h3><blockquote><p>给定一个 n 行 m 列矩阵 matrix ，矩阵内所有数均为非负整数。 你需要在矩阵中找到一条最长路径，使这条路径上的元素是递增的。并输出这条最长路径的长度。</p><p>这个路径必须满足以下条件：</p><ol><li><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。</p></li><li><p>你不能走重复的单元格。即每个格子最多只能走一次。</p></li></ol><p>数据范围：1≤<em>n</em>,<em>m</em>≤1000</p><p>进阶：空间复杂度 O(nm)，时间复杂度 O(nm)</p><p>例如：当输入为[[1,2,3],[4,5,6],[7,8,9]]时，对应的输出为5，</p><p>其中的一条最长递增路径如下图所示：</p><p><img src="/leetcode.assets/A6B05D015D3BE3C77C34DDF224044A1F" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>返回值：<span class="hljs-number">5</span><br>输入：<span class="hljs-string">[[1,2],[4,3]]</span><br>返回值：<span class="hljs-number">4</span><br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">9</span>即可。当然这种递增路径不是唯一的。       <br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     * 递增路径的最大长度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> matrix int整型二维数组 描述矩阵的每个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">solve</span> <span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; matrix.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; matrix[i].length; j++)&#123;<br>                max = Math.max(max, dfs(matrix, i, j, -<span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span> <span class="hljs-params">(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> pre)</span>&#123;<br>        <span class="hljs-keyword">if</span>(mat[i][j] &lt;= pre)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>            max = Math.max(max, dfs(mat, i - <span class="hljs-number">1</span>, j, mat[i][j]));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>)&#123;<br>            max = Math.max(max, dfs(mat, i, j - <span class="hljs-number">1</span>, mat[i][j]));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &lt; mat.length - <span class="hljs-number">1</span>)&#123;<br>            max = Math.max(max, dfs(mat, i + <span class="hljs-number">1</span>, j, mat[i][j]));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j &lt; mat[i].length - <span class="hljs-number">1</span>)&#123;<br>            max = Math.max(max, dfs(mat, i, j + <span class="hljs-number">1</span>, mat[i][j]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> max + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⑦动态规划"><a href="#⑦动态规划" class="headerlink" title="⑦动态规划"></a><strong>⑦动态规划</strong></h2><h3 id="BM62-斐波那契数列"><a href="#BM62-斐波那契数列" class="headerlink" title="BM62 斐波那契数列"></a><strong>BM62</strong> <strong>斐波那契数列</strong></h3><blockquote><p>大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a+b;<br>            a = b;<br>            b = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM63-跳台阶"><a href="#BM63-跳台阶" class="headerlink" title="BM63 跳台阶"></a><strong>BM63</strong> <strong>跳台阶</strong></h3><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; target; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a+b;<br>            a = b;<br>            b = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM64-最小花费爬楼梯"><a href="#BM64-最小花费爬楼梯" class="headerlink" title="BM64 最小花费爬楼梯"></a><strong>BM64</strong> <strong>最小花费爬楼梯</strong></h3><blockquote><p>给定一个整数数组 cost，其中 cost[i]是从楼梯第i个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= cost.length; i++)&#123;<br>            dp[i] = Math.min(dp[i-<span class="hljs-number">1</span>]+cost[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+cost[i-<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.length];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM65-最长公共子序列"><a href="#BM65-最长公共子序列" class="headerlink" title="BM65 最长公共子序列"></a><strong>BM65</strong> <strong>最长公共子序列</strong></h3><blockquote><p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">LCS</span> <span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s1.charAt(i-<span class="hljs-number">1</span>) == s2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>       <span class="hljs-keyword">if</span>(dp[m][n]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>       <span class="hljs-type">char</span>[] lcs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[dp[m][n]];<br>       <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> lcs.length - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>           <span class="hljs-keyword">if</span> (s1.charAt(m - <span class="hljs-number">1</span>) == s2.charAt(n - <span class="hljs-number">1</span>)) &#123;<br>               lcs[cur--] = s1.charAt(m - <span class="hljs-number">1</span>);<br>               <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(lcs);<br>               m--;<br>               n--;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">if</span> (dp[m - <span class="hljs-number">1</span>][n] &gt; dp[m][n - <span class="hljs-number">1</span>]) &#123;<br>                   m--;<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   n--;<br>               &#125;<br>           &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM66-最长公共子串-1"><a href="#BM66-最长公共子串-1" class="headerlink" title="BM66 最长公共子串"></a><strong>BM66</strong> <strong>最长公共子串</strong></h3><blockquote><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串</p><p>题目保证str1和str2的最长公共子串存在且唯一。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">LCS</span> <span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> str1.length(), n = str2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(str1.charAt(i) == str2.charAt(j))&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] &gt; maxLen) &#123;<br>                        maxLen = dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];<br>                        index = i;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str1.substring(index-maxLen+<span class="hljs-number">1</span>,index+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM67-不同路径的数目-一"><a href="#BM67-不同路径的数目-一" class="headerlink" title="BM67 不同路径的数目(一)"></a><strong>BM67</strong> <strong>不同路径的数目(一)</strong></h3><blockquote><p>一个机器人在m×n大小的地图的左上角（起点）。</p><p>机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。</p><p>可以有多少种不同的路径从起点走到终点？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span> <span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m ; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM68-矩阵的最小路径和"><a href="#BM68-矩阵的最小路径和" class="headerlink" title="BM68 矩阵的最小路径和"></a><strong>BM68</strong> <strong>矩阵的最小路径和</strong></h3><blockquote><p>给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span> <span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + matrix[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + matrix[<span class="hljs-number">0</span>][i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM69-把数字翻译成字符串-1"><a href="#BM69-把数字翻译成字符串-1" class="headerlink" title="BM69 把数字翻译成字符串"></a><strong>BM69</strong> <strong>把数字翻译成字符串</strong></h3><blockquote><p>有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p><p>现在给一串数字，返回有多少种可能的译码结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">solve</span> <span class="hljs-params">(String nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length() == <span class="hljs-number">0</span> || nums.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length()];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums.charAt(i) != <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                dp[i] = dp[i-<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (nums.charAt(i-<span class="hljs-number">1</span>)-<span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span> + (nums.charAt(i)-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">10</span> &amp;&amp; num &lt;= <span class="hljs-number">26</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>                    dp[i] += <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i] += dp[i-<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length()-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM70-兑换零钱-一"><a href="#BM70-兑换零钱-一" class="headerlink" title="BM70 兑换零钱(一)"></a><strong>BM70</strong> <strong>兑换零钱(一)</strong></h3><blockquote><p>给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。</p><p>如果无解，请返回-1.</p><p>数据范围：数组大小满足0≤<em>n</em>≤10000 ， 数组中每个数字都满足0&lt;<em>v<strong>a</strong>l</em>≤10000，0≤<em>a<strong>i</strong>m</em>≤5000</p><p>要求：时间复杂度 O*(<em>n</em>×*a<strong>i</strong>m) ，空间复杂度 O(<em>a<strong>i</strong>m</em>)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[5,2,3]</span>,<span class="hljs-number">20</span><br>返回值：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMoney</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> aim)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[aim+<span class="hljs-number">1</span>];<br>        Arrays.fill(dp,aim+<span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= aim; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt;= arr[j])&#123;<br>                    dp[i] = Math.min(dp[i],dp[i-arr[j]]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[aim] &gt; aim) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> dp[aim];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM71-最长上升子序列-一"><a href="#BM71-最长上升子序列-一" class="headerlink" title="BM71 最长上升子序列(一)"></a><strong>BM71</strong> <strong>最长上升子序列(一)</strong></h3><blockquote><p>给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。</p><p>所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。</p><p>数据范围： 0≤<em>n</em>≤1000</p><p>要求：时间复杂度 O(n^2)， 空间复杂度 O(n)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[6,3,1,5,2,3,7]</span><br>返回值：<span class="hljs-number">4</span><br>说明：该数组最长上升子序列为 <span class="hljs-selector-attr">[1,2,3,7]</span> ，长度为<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">LIS</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxlen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(arr[i] &gt; arr[j])&#123;<br>                    dp[i] = Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                    maxlen = Math.max(maxlen,dp[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxlen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM72-连续子数组的最大和"><a href="#BM72-连续子数组的最大和" class="headerlink" title="BM72 连续子数组的最大和"></a><strong>BM72</strong> <strong>连续子数组的最大和</strong></h3><h3 id="BM73-最长回文子串"><a href="#BM73-最长回文子串" class="headerlink" title="BM73 最长回文子串"></a><strong>BM73</strong> <strong>最长回文子串</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maxlen</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, String str)</span>&#123;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; str.length() &amp;&amp; str.charAt(i) == str.charAt(j))&#123;<br>            i--;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j-i-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLongestPalindrome</span> <span class="hljs-params">(String A)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length()-<span class="hljs-number">1</span>; i++)&#123;<br>            max = Math.max(max,Math.max(maxlen(i,i,A),maxlen(i,i+<span class="hljs-number">1</span>,A)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM74-数字字符串转化成IP地址"><a href="#BM74-数字字符串转化成IP地址" class="headerlink" title="BM74 数字字符串转化成IP地址"></a><strong>BM74</strong> <strong>数字字符串转化成IP地址</strong></h3><h3 id="BM75-编辑距离-一"><a href="#BM75-编辑距离-一" class="headerlink" title="BM75 编辑距离(一)"></a><strong>BM75</strong> <strong>编辑距离(一)</strong></h3><blockquote><p><img src="/leetcode.assets/image-20220404230816200.png" alt="编辑距离"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">editDistance</span> <span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> str1.length(), n = str2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) dp[<span class="hljs-number">0</span>][i] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(str1.charAt(i-<span class="hljs-number">1</span>) == str2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM76-正则表达式匹配"><a href="#BM76-正则表达式匹配" class="headerlink" title="BM76 正则表达式匹配"></a><strong>BM76</strong> <strong>正则表达式匹配</strong></h3><h3 id="BM77-最长的括号子串"><a href="#BM77-最长的括号子串" class="headerlink" title="BM77 最长的括号子串"></a><strong>BM77</strong> <strong>最长的括号子串</strong></h3><h3 id="BM78-打家劫舍-一"><a href="#BM78-打家劫舍-一" class="headerlink" title="BM78 打家劫舍(一)"></a><strong>BM78</strong> <strong>打家劫舍(一)</strong></h3><blockquote><p>你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。</p><p>给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+nums[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM79-打家劫舍-二"><a href="#BM79-打家劫舍-二" class="headerlink" title="BM79 打家劫舍(二)"></a><strong>BM79</strong> <strong>打家劫舍(二)</strong></h3><blockquote><p>你是一个经验丰富的小偷，准备偷沿湖的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家，如果偷了第二家，那么就不能偷第一家和第三家。沿湖的房间组成一个闭合的圆形，即第一个房间和最后一个房间视为相邻。</p><p>给定一个长度为n的整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 可以偷第一家</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+nums[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dp[n-<span class="hljs-number">1</span>];<br>        Arrays.fill(dp,<span class="hljs-number">0</span>);  <span class="hljs-comment">// 第一家不能偷</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+nums[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(res,dp[n]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM80-买卖股票的最好时机-一"><a href="#BM80-买卖股票的最好时机-一" class="headerlink" title="BM80 买卖股票的最好时机(一)"></a><strong>BM80</strong> <strong>买卖股票的最好时机(一)</strong></h3><blockquote><p>假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p><p>1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天</p><p>2.如果不能获取到任何利润，请返回0</p><p>3.假设买入卖出均无手续费</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 贪心</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++)&#123;<br>            min = Math.min(min,prices[i]);<br>            val = Math.max(val,prices[i] - min);<br>        &#125;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM81-买卖股票的最好时机-二"><a href="#BM81-买卖股票的最好时机-二" class="headerlink" title="BM81 买卖股票的最好时机(二)"></a><strong>BM81</strong> <strong>买卖股票的最好时机(二)</strong></h3><h3 id="BM82-买卖股票的最好时机-三"><a href="#BM82-买卖股票的最好时机-三" class="headerlink" title="BM82 买卖股票的最好时机(三)"></a><strong>BM82</strong> <strong>买卖股票的最好时机(三)</strong></h3><h2 id="⑧字符串"><a href="#⑧字符串" class="headerlink" title="⑧字符串"></a><strong>⑧字符串</strong></h2><h2 id="⑨双指针"><a href="#⑨双指针" class="headerlink" title="⑨双指针"></a>⑨双指针</h2><h3 id="BM88-判断是否为回文字符串"><a href="#BM88-判断是否为回文字符串" class="headerlink" title="BM88 判断是否为回文字符串"></a><strong>BM88</strong> <strong>判断是否为回文字符串</strong></h3><blockquote><p>给定一个长度为 n 的字符串，请编写一个函数判断该字符串是否回文。如果是回文请返回true，否则返回false。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judge</span> <span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = str.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">if</span>(str.charAt(l++) != str.charAt(r--))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM89-合并区间"><a href="#BM89-合并区间" class="headerlink" title="BM89 合并区间"></a><strong>BM89</strong> <strong>合并区间</strong></h3><blockquote><p>给出一组区间，请合并所有重叠的区间。</p><p>请保证合并后的区间按区间起点升序排列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for an interval.</span><br><span class="hljs-comment"> * public class Interval &#123;</span><br><span class="hljs-comment"> *     int start;</span><br><span class="hljs-comment"> *     int end;</span><br><span class="hljs-comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span><br><span class="hljs-comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ArrayList&lt;Interval&gt; <span class="hljs-title function_">merge</span><span class="hljs-params">(ArrayList&lt;Interval&gt; intervals)</span> &#123;<br>        ArrayList&lt;Interval&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(intervals.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        intervals.sort((o1,o2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(o1.start == o2.start)&#123;<br>                <span class="hljs-keyword">return</span> o1.end - o2.end;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> o1.start - o2.start;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> intervals.get(<span class="hljs-number">0</span>).start, r = intervals.get(<span class="hljs-number">0</span>).end;<br>        <span class="hljs-keyword">for</span>(Interval x : intervals)&#123;<br>            <span class="hljs-keyword">if</span>(x.start &gt; r)&#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interval</span>(l,r));<br>                l = x.start;<br>                r = x.end;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = Math.max(r,x.end);<br>            &#125;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interval</span>(l,r));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM93-盛水最多的容器"><a href="#BM93-盛水最多的容器" class="headerlink" title="BM93 盛水最多的容器"></a><strong>BM93</strong> <strong>盛水最多的容器</strong></h3><blockquote><p>给定一个数组height，长度为n，每个数代表坐标轴中的一个点的高度，height[i]是在第i点的高度，请问，从中选2个高度与x轴组成的容器最多能容纳多少水</p><p>1.你不能倾斜容器</p><p>2.当n小于2时，视为不能形成容器，请返回0</p><p>3.数据保证能容纳最多的水不会超过整形范围，即不会超过2^31-1</p><p><img src="/leetcode.assets/B9F3EB6BBC1EE9A63532E7EB494A11A7" alt="盛水最多的容器"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = len-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">if</span>(height[l] &lt;= height[r])&#123;<br>                max = Math.max(max,(r-l)*height[l]);<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                max = Math.max(max,(r-l)*height[r]);<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM94-接雨水问题"><a href="#BM94-接雨水问题" class="headerlink" title="BM94 接雨水问题"></a><strong>BM94</strong> <strong>接雨水问题</strong></h3><blockquote><p>给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个柱子高度图，计算按此排列的柱子，下雨之后能接多少雨水。(数组以外的区域高度视为0)</p><p><img src="/leetcode.assets/26A2E295DEE51749C45B5E8DD671E879" alt="接雨水问题"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxWater</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hl</span> <span class="hljs-operator">=</span> arr[l], hr = arr[len-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">if</span>(hl &lt;= hr)&#123;<br>                res += Math.max(hl-arr[l+<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>                hl = Math.max(hl,arr[l+<span class="hljs-number">1</span>]);<br>                l++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res += Math.max(hr-arr[r-<span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<br>                hr = Math.max(hr,arr[r-<span class="hljs-number">1</span>]);<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="⑩贪心"><a href="#⑩贪心" class="headerlink" title="⑩贪心"></a><strong>⑩贪心</strong></h2><h2 id="⑪模拟"><a href="#⑪模拟" class="headerlink" title="⑪模拟"></a><strong>⑪模拟</strong></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java日志系统</title>
    <link href="/2022/03/13/java-log/"/>
    <url>/2022/03/13/java-log/</url>
    
    <content type="html"><![CDATA[<h1 id="slf4j与jcl、juc、log4j1、log4j2、logback的集成"><a href="#slf4j与jcl、juc、log4j1、log4j2、logback的集成" class="headerlink" title="slf4j与jcl、juc、log4j1、log4j2、logback的集成"></a>slf4j与jcl、juc、log4j1、log4j2、logback的集成</h1><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>如果需要，可先了解java日志的发展历史，这可能有助于你对日志框架的理解<br>可先了解设计模式的相关知识，java日志系统涉及到了设计模式的知识，如门面模式，桥接模式<br>不过，不了解也无妨！ Let’s go！🎉🎉🎉<br></code></pre></td></tr></table></figure><h1 id="一、使用SLF4J做日志门面"><a href="#一、使用SLF4J做日志门面" class="headerlink" title="一、使用SLF4J做日志门面"></a>一、使用SLF4J做日志门面</h1><h2 id="1、slf4j与jul的集成"><a href="#1、slf4j与jul的集成" class="headerlink" title="1、slf4j与jul的集成"></a>1、slf4j与jul的集成</h2><p>jar包依赖关系图：</p><p><img src="/java-log.assets/image-20220313111051835.png" alt="image-20220313111051835"></p><!-- java.util.logging --><p><strong>依赖：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maven">&lt;!--需要的jar包：slf4j-api.jar、slf4j-jdk14.jar--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;<br>    &lt;version&gt;1.7.24&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>[^tips：可以不引入slf4j-api.jar，因为引入slf4j-jdk14时，会自动导入。下同理]: </p><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jeiker.demo.slf4j;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Slf4jJdkTest</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Slf4jJdkTest.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>       <span class="hljs-keyword">if</span>(logger.isDebugEnabled())&#123;<br>           logger.debug(<span class="hljs-string">&quot;slf4j-jdk debug message&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(logger.isInfoEnabled())&#123;<br>           logger.debug(<span class="hljs-string">&quot;slf4j-jdk info message&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(logger.isTraceEnabled())&#123;<br>           logger.debug(<span class="hljs-string">&quot;slf4j-jdk trace message&quot;</span>);<br>       &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、slf4j与log4j1的集成"><a href="#2、slf4j与log4j1的集成" class="headerlink" title="2、slf4j与log4j1的集成"></a>2、slf4j与log4j1的集成</h2><p>jar包依赖关系图：</p><p><img src="/java-log.assets/image-20220313111029132.png" alt="image-20220313111029132"></p><!-- log4j1 --><p><strong>依赖：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maven">&lt;!--需要的jar包：slf4j-api.jar、slf4j-jdk14.jar--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;<br>    &lt;version&gt;1.7.24&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Slf4jLog4j1Test</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Slf4jLog4j1Test.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">if</span>(logger.isDebugEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-log4j1 debug message&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(logger.isInfoEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-log4j1 info message&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(logger.isTraceEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-log4j1 trace message&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="3、slf4j与log4j2的集成"><a href="#3、slf4j与log4j2的集成" class="headerlink" title="3、slf4j与log4j2的集成"></a>3、slf4j与log4j2的集成</h2><p>jar包依赖关系图</p><p><img src="/java-log.assets/image-20220313111447132.png" alt="image-20220313111447132"></p><p><strong>依赖：</strong></p><!-- log4j2 --><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Slf4jLog4j2Test</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Slf4jLog4j2Test.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">if</span>(logger.isDebugEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-log4j2 debug message&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(logger.isInfoEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-log4j2 info message&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(logger.isTraceEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-log4j2 trace message&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4、slf4j与logback的集成"><a href="#4、slf4j与logback的集成" class="headerlink" title="4、slf4j与logback的集成"></a>4、slf4j与logback的集成</h2><p>jar包依赖关系图</p><p><img src="/java-log.assets/image-20220313111808087.png" alt="image-20220313111808087"></p><p><strong>依赖：</strong></p><!-- logback --><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Slf4jLogbackTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Slf4jLogbackTest.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">if</span>(logger.isDebugEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-logback debug message&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(logger.isInfoEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-logback info message&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(logger.isTraceEnabled())&#123;<br>            logger.debug(<span class="hljs-string">&quot;slf4j-logback trace message&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="二、使用JCL做日志门面"><a href="#二、使用JCL做日志门面" class="headerlink" title="二、使用JCL做日志门面"></a>二、使用JCL做日志门面</h1><p>全称为Jakarta Commons Logging,是Apache提供的一个通用日志API。它是为”所有的Java日志实现”，提供一个统一的接口，它自身也提供一个日志的实现，但是功能非常弱（SimpleLog），故而一般不单独使用它（作为统一接口调用，换日志框架，比如换成log4j，切换依赖即可）。</p><p><strong>通过LogFactory动态加载Log实现类顺序</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Log4JLogger &gt; <span class="hljs-keyword">JDK14Logger </span>&gt; <span class="hljs-keyword">Jdk13LumberjackLogger </span>&gt;  SimpleLog<br></code></pre></td></tr></table></figure><p>如果同时引入了多个实现类，可以在类路径下编写commoms-logging.properties来指定实现类，若不指定，则按照上述加载顺序加载实现类</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#实现为指定Log4JLogger日志</span><br><span class="hljs-attr">org.apache.commons.logging.Log</span>=<span class="hljs-string">org.apache.commons.logging.impl.JDK14Logger</span><br></code></pre></td></tr></table></figure><h2 id="1、jcl与jul集成"><a href="#1、jcl与jul集成" class="headerlink" title="1、jcl与jul集成"></a>1、jcl与jul集成</h2><p>因为JDK自带JDK14Logger，所以只引入JCL也可以使用日志，默认使用java.util.logging</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>jul的配置文件在JDK_HOME&#x2F;jre&#x2F;lib&#x2F;logging.properties，JDK自带的所以不需要配置</p><h2 id="2、jcl与log4j集成"><a href="#2、jcl与log4j集成" class="headerlink" title="2、jcl与log4j集成"></a>2、jcl与log4j集成</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于具体的log4j配置在类目录下编写 log4j.properties 即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log4j.rootLogger</span>=<span class="hljs-string">INFO, stdout</span><br><br><span class="hljs-attr">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><br><span class="hljs-attr">log4j.appender.stdout.Target</span>=<span class="hljs-string">System.out</span><br><br><span class="hljs-attr">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><br><span class="hljs-attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span><br><br></code></pre></td></tr></table></figure><h2 id="3、jcl与log4j2集成"><a href="#3、jcl与log4j2集成" class="headerlink" title="3、jcl与log4j2集成"></a>3、jcl与log4j2集成</h2><p>log4j2是对log4j的重写，性能更好。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于具体的log4j2配置在类目录下编写 log4j2.xml即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--status表示log4j2自身的日志打印级别，如trace会打印出log4j2加载、运行等信息, monitorinterval监控间隔，单位为秒--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;trace&quot;</span> <span class="hljs-attr">monitorinterval</span>=<span class="hljs-string">&quot;6&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--定义变量--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;nowDate&quot;</span>&gt;</span>%date&#123;yyyy-MM-dd&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logDir&quot;</span>&gt;</span>$&#123;sys:catalina.home&#125;/logs/<span class="hljs-tag">&lt;/<span class="hljs-name">Property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--日志输出到控制台--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;consoleAppender&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%date %logger %processId %threadId %method %class %file %highlight&#123;%level&#125; : %green&#123;%msg&#125; %n&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--日志写入文件中--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;File name=&quot;fileAppender&quot; fileName=&quot;log4j2Study_$&#123;date:yyyy-MM-dd&#125;.log&quot;&gt;--&gt;</span><br>            <span class="hljs-comment">&lt;!--&lt;PatternLayout pattern=&quot;%date %logger %level : %msg%n&quot; /&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;/File&gt;--&gt;</span><br><br>        <span class="hljs-comment">&lt;!--日志写入文件，根据自定义的滚动策略归档文件，filePattern定义日志文件归档格式--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rollingFileAppender&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;log4j2_rollingFileAppender.log&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$$&#123;date:yyyy-MM&#125;/%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%date %logger %level : %msg%n&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!--定义滚动策略--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--基于cron表达式触发归档--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">CronTriggeringPolicy</span> <span class="hljs-attr">schedule</span>=<span class="hljs-string">&quot;0 0 * * * ?&quot;</span>/&gt;</span><br>                <span class="hljs-comment">&lt;!--基于时间触发归档,与上文filePattern配合使用，当filePattern不符合时，就归档--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> /&gt;</span><br>                <span class="hljs-comment">&lt;!--基于文件大小触发归档--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;100 MB&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!--默认日志保留7天--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;7&quot;</span> /&gt;</span><br><br>            <span class="hljs-comment">&lt;!--log4j 2.5引入，可更精细地控制删除日志策略--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--同时满足下述条件，进行删除--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--文件名符合.log.gz后缀--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;*.log.gz&quot;</span> /&gt;</span><br>                    <span class="hljs-comment">&lt;!--超过60天--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;60d&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--定义日志输出配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--控制指定包或类的日志输出（包括等级和目的地）, additivity表示日志信息是否向上传递，false为不传递（即不重复打印）--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.dragon.study.log.test&quot;</span>  <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;consoleAppender&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--全局日志级别为info--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志输出到控制台和文件中--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;consoleAppender&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;fileAppender&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4、spring-jcl与log4j2集成"><a href="#4、spring-jcl与log4j2集成" class="headerlink" title="4、spring-jcl与log4j2集成"></a>4、spring-jcl与log4j2集成</h2><p>由于apache不再维护jcl，因此spring将jcl重写并引入框架中，为spring-jcl。</p><p>值得注意的是spring-jcl不支持log4j1。</p><p>spring-jcl的加载顺序为**<code>Log4j 2.x</code>**， <strong><code>Try SLF4J 1.7 SPI</code><strong>，</strong><code>SLF4J 1.7 API</code><strong>，</strong>jul</strong></p><p><img src="/java-log.assets/image-20220313124441148.png" alt="image-20220313124441148"></p><p><strong>依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果你想在spring中使用log4j，那么需要将spring-jcl排除，然后使用apache的jcl</p><p><img src="/java-log.assets/image-20220313125217953.png" alt="image-20220313125217953"></p><p>如果你想使用slf4j，那么根据第一部分所说的方法引入依赖就可以了，spring-jcl已经做好了到slf4j的桥接</p><h1 id="三、使用slf4j统一各种日志"><a href="#三、使用slf4j统一各种日志" class="headerlink" title="三、使用slf4j统一各种日志"></a>三、使用slf4j统一各种日志</h1><p>当项目是使用多种日志API时，可以统一适配到slf4j，然后通过slf4j适配底层实现。</p><p>中间使用slf4j进行统一项目中使用的多种日志框架的API，然后转发到slf4j,slf4j再底层用开发者想用的一个日志框架来进行日志系统的实现。从而达到了多种日志的统一实现。</p><p>slf4j在这中间充当了中间人，充当翻译的感觉。</p><p>slf4j官网桥接说明：<a href="https://www.slf4j.org/legacy.html">https://www.slf4j.org/legacy.html</a></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="/java-log.assets/image-20220313115305496.png" alt="image-20220313115305496"></p><p>例子：目前的应用程序（application）中已经使用了以下的几种API来进行日志的编程：</p><p>commons-logging + log4j<br>现在想统一将日志的输出交给jdk-logging。</p><p>解决方案：</p><p>将上面的日志系统全部转换到slf4j</p><p>使用jcl-over-slf4j(桥接)将commons-logging的底层日志输出切换到sl4j，或者移除log4j1(必须移除)，使用log4j-over-slf4j(桥接)，将log4j1的日志输出切换到slf4j，让slf4j选择jdk-logging作为底层日志输出</p><p>问题：目前的应用程序（application）中已经使用了以下的几种API来进行日志的编程：</p><p>commons-logging<br>jdk-loging<br>现在想统一将日志的输出交给log4j1。</p><p>解决方法：</p><p>将上面的日志系统全部转换到slf4j</p><p>移除commons-logging(可以不移除)，使用jcl-over-slf4j(桥接)将commons-logging的底层日志输出切换到sl4j，使用jul-to-slf4j(桥接)，将jul的日志输出切换到slf4j，让slf4j选择log4j1作为底层日志输出</p><p>问题：目前的应用程序（application）中已经使用了以下的几种API来进行日志的编程：</p><p>commons-logging<br>log4j1<br>jdk-loging<br>现在想统一将日志的底层处理交给logback，也就是说，用多种API编程，用logback实现日志输出。</p><p>解决方法：</p><p>将上面的日志系统全部转换到slf4j</p><p>移除commons-logging(可以不移除)，使用jcl-over-slf4j(桥接)将commons-logging的底层日志输出切换到sl4j，移除log4j1实现（必须移除），使用log4j-over-slf4j(桥接)将log4j1的日志输出切换到sl4j，使用jul-to-slf4j(桥接)，将jul的日志输出切换到slf4j，让slf4j选择logback作为底层日志输出</p><h2 id="旧日志API到slf4j的适配器"><a href="#旧日志API到slf4j的适配器" class="headerlink" title="旧日志API到slf4j的适配器"></a>旧日志API到slf4j的适配器</h2><p>介绍之前先说明下日志简称：</p><p>jdk自带的logging，简称 jul (java-util-logging)<br>apache commons-logging，简称 jcl (java-commons-logging)<br>日志适配器：<br>jcl-over-slf4j    java-commons-logging API到slf4j的适配<br>jul-to-slf4j    java-util-logging API到slf4j的适配<br>log4j-over-slf4j    log4j 1 API到slf4j的适配<br>log4j-to-slf4j    log4j 2 API到slf4j的适配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- JCL 1.2 implemented over SLF4J --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- JUL to SLF4J bridge --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jul-to-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Log4j implemented over SLF4J --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Log4j 2 to SLF4J Adapter --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="slf4j到新日志实现的适配器"><a href="#slf4j到新日志实现的适配器" class="headerlink" title="slf4j到新日志实现的适配器"></a>slf4j到新日志实现的适配器</h2><p>日志适配器：<br>slf4j-jcl    slf4j到java-commons-logging的适配<br>slf4j-jdk14    slf4j到java-util-logging实现的适配<br>slf4j-log4j12    slf4j到log4j 1实现的适配<br>log4j-slf4j-impl    slf4j到log4j 2实现的适配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SLF4J JCL Binding --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-jcl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- SLF4J JDK14 Binding --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-jdk14<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- SLF4J LOG4J-12 Binding --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- SLF4J Log4j 2 Binding --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="slf4j冲突说明"><a href="#slf4j冲突说明" class="headerlink" title="slf4j冲突说明"></a>slf4j冲突说明</h2><p>其实明白上面介绍的各jar包的作用，就很容易理解为什么会出现冲突了。</p><p>冲突的出现主要是形成了日志的事件闭环。就相当于两个人在互相推卸责任。</p><ol><li>jcl-over-slf4j 与 slf4j-jcl 冲突<br>jcl-over-slf4j : commons-logging切换到slf4j<br>slf4j-jcl : slf4j切换到commons-logging<br>jcl把日志输出事件交给slf4j，slf4j又还给了jcl。</li></ol><p>如果这两者共存的话，必然造成相互委托，造成内存溢出。</p><ol start="2"><li>log4j-over-slf4j 与 slf4j-log4j12 冲突<br>log4j-over-slf4j ： log4j1切换到slf4j<br>slf4j-log4j12 : slf4j切换到log4j1<br>log4j1把日志输出事件交给slf4j，slf4j又还给了log4j1。</li></ol><p>如果这两者共存的话，必然造成相互委托，造成内存溢出。</p><ol start="3"><li>jul-to-slf4j 与 slf4j-jdk14 冲突<br>jul-to-slf4j : jdk-logging切换到slf4j<br>slf4j-jdk14 : slf4j切换到jdk-logging<br>jul把日志输出事件交给slf4j，slf4j又还给了jul。</li></ol><p>如果这两者共存的话，必然造成相互委托，造成内存溢出。</p><h1 id="四、配置问题"><a href="#四、配置问题" class="headerlink" title="四、配置问题"></a>四、配置问题</h1><p>不管使用那种日志实现类，都可以自定义配置的，根据项目所使用的日志系统，编写日志配置即可，形式为xxx.xml或者xxx.properties。</p><p>编写的配置文件放在类路径下，如果使用的是spring则放在resources文件夹下。</p><p>commoms-logging.properties：在引入多个日志实现类时，可以手动选择加载哪一个</p><p>log4j.properties：具体配置参见<a href="https://logging.apache.org/log4j/2.x/">https://logging.apache.org/log4j/2.x/</a></p><p>log4j2.xml：具体配置参见<a href="https://logging.apache.org/log4j/2.x/">https://logging.apache.org/log4j/2.x/</a></p><p>logback.xml：具体配置参见<a href="https://logback.qos.ch/">Logback Home (qos.ch)</a></p><p>由于本篇文章，只做各种日志关系的梳理以及简单使用，所以具体各种日志的具体配置，暂不作讲解，若需要请自行到相应官网了解，或者查看其他博客对配置文件的讲解。</p><p>🤭🤭🤭若精力有限，定会补上</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql高级</title>
    <link href="/2022/03/13/mysql2/"/>
    <url>/2022/03/13/mysql2/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Mysql逻辑架构"><a href="#一、Mysql逻辑架构" class="headerlink" title="一、Mysql逻辑架构"></a>一、Mysql逻辑架构</h1><h2 id="1、整体架构"><a href="#1、整体架构" class="headerlink" title="1、整体架构"></a>1、整体架构</h2><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200813170808.png"><img src="/mysql2.assets/20200813170808.png" alt="MySQL架构"></a></p><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客服端和连接服务，包括socket通信和大多数基于客服端&#x2F;服务端工具实现的类似于tcp&#x2F;ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</p><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作</p><table><thead><tr><th>Management Serveices &amp; Utilities</th><th>系统管理和控制工具</th></tr></thead><tbody><tr><td>SQL Interface</td><td>SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface</td></tr><tr><td>Parser</td><td>解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析</td></tr><tr><td>Optimizer</td><td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。</td></tr><tr><td>Cache 和 Buffer</td><td>查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存， 权限缓存等</td></tr></tbody></table><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同</p><table><thead><tr><th>对比项</th><th>MylSAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁（不适合高并发）</td><td>行锁（适合高并发操作）</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引，还缓存真实数据。对内存要求较高</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr></tbody></table><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互</p><h1 id="二、JOIN"><a href="#二、JOIN" class="headerlink" title="二、JOIN"></a>二、JOIN</h1><h3 id="手写顺序"><a href="#手写顺序" class="headerlink" title="手写顺序"></a>手写顺序</h3><p><img src="/mysql2.assets/image-20220403172344930.png" alt="手写SQL顺序"></p><p>随着 Mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而<strong>动态调整执行顺序</strong></p><h3 id="查询顺序"><a href="#查询顺序" class="headerlink" title="查询顺序"></a>查询顺序</h3><p><img src="/mysql2.assets/20200814112343-1648977950246.png" alt="查询顺序"></p><p><img src="/mysql2.assets/20200814191644-1648977968634.png" alt="查询顺序"></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814150926.png"><img src="/mysql2.assets/20200814150926.png" alt="img"></a></p><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a><strong>建表语句</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_dept`(<br>    `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    `deptName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>)<span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_emp` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `age` <span class="hljs-type">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `deptId` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    empno <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>    KEY `idx_dept_id` (`deptId`)<br>#<span class="hljs-keyword">CONSTRAINT</span> `fk_dept_id` <span class="hljs-keyword">FOREIGN</span> KEY (`deptId`) <span class="hljs-keyword">REFERENCES</span> `t_dept` (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;华山&#x27;</span>,<span class="hljs-string">&#x27;华山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;丐帮&#x27;</span>,<span class="hljs-string">&#x27;洛阳&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;峨眉&#x27;</span>,<span class="hljs-string">&#x27;峨眉山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;武当&#x27;</span>,<span class="hljs-string">&#x27;武当山&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;明教&#x27;</span>,<span class="hljs-string">&#x27;光明顶&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_dept(deptName,address) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;少林&#x27;</span>,<span class="hljs-string">&#x27;少林寺&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;风清扬&#x27;</span>,<span class="hljs-number">90</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100001</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;岳不群&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100002</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;令狐冲&#x27;</span>,<span class="hljs-number">24</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100003</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;洪七公&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100004</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;乔峰&#x27;</span>,<span class="hljs-number">35</span>,<span class="hljs-number">2</span>,<span class="hljs-number">100005</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;灭绝师太&#x27;</span>,<span class="hljs-number">70</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100006</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;周芷若&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100007</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张三丰&#x27;</span>,<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">100008</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张无忌&#x27;</span>,<span class="hljs-number">25</span>,<span class="hljs-number">5</span>,<span class="hljs-number">100009</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_emp(NAME,age,deptId,empno) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;韦小宝&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">100010</span>);<br></code></pre></td></tr></table></figure><h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a>JOIN查询</h3><ul><li>笛卡尔积</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept, t_emp;<br></code></pre></td></tr></table></figure><p>t_dept共6条记录，t_emp共10条记录。两表共同查询后共60条记录</p><ul><li>内连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><ul><li>左外连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><ul><li>右外连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><ul><li>左外连接<strong>取左表的独有部分</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span>  a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><ul><li>右外连接<strong>取右表的独有部分</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">right</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">where</span> a.deptId <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：判断字段是否为NULL时，**不能使用 ’&#x3D;’ **</p><p>因为 &#x3D; NULL 的结果不会报错，但是<strong>结果永远为false</strong>。所以必须使用 IS NULL 来进行判空.</p></blockquote><ul><li>全外连接</li></ul><p>MySQL不支持全外连接，要查询两个表的全集，需要合并两个查询结果，所以要使用 <strong>UNION</strong> 关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><ul><li>查询两表独有内容</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h1 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h1><h2 id="1、什么是索引"><a href="#1、什么是索引" class="headerlink" title="1、什么是索引"></a>1、什么是索引</h2><ul><li><p>MySQL 官方对索引的定义为：<strong>索引（Index）是帮助 MySQL 高效获取数据的数据结构</strong>。可以得到索引的本质： <strong>索引是数据结构</strong>。</p><p>可以简单理解为：<strong>排好序的快速查找数据结构</strong></p></li><li><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200814173647.png"><img src="/mysql2.assets/20200814173647.png" alt="img"></a></p><ul><li>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用 二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录</li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上</li></ul><h2 id="2、索引的优缺点"><a href="#2、索引的优缺点" class="headerlink" title="2、索引的优缺点"></a>2、索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>提高数据检索的效率</strong>，降低数据库的IO成本</li><li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>虽然索引大大提高了查询速度，同时却<strong>会降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<strong>索引列也是要占用空间的</strong></li></ul><h2 id="3、索引的分类"><a href="#3、索引的分类" class="headerlink" title="3、索引的分类"></a>3、索引的分类</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] INDEX [indexName] <span class="hljs-keyword">ON</span> table_name(<span class="hljs-keyword">column</span>);<br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX [indexName] <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>单值索引</p><ul><li><p>定义：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,<br>customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <br><span class="hljs-keyword">PRIMARY</span> KEY(id), <br>KEY (customer_name) <span class="hljs-comment">--单值索引</span><br>);<br><br><span class="hljs-comment">--单独创建单值索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_customer_name <span class="hljs-keyword">ON</span> customer(customer_name);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>唯一索引</p><ul><li><p>定义：索引列的值必须唯一，但允许有空值</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>    id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,<br>    customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>    customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <br>    <span class="hljs-keyword">PRIMARY</span> KEY(id), <br>    KEY (customer_name), <span class="hljs-comment">--单值索引</span><br>    <span class="hljs-keyword">UNIQUE</span> (customer_no) <span class="hljs-comment">--唯一索引</span><br>);<br><br><span class="hljs-comment">--单独创建唯一索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_customer_no <span class="hljs-keyword">ON</span> customer(customer_no);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>主键索引</p><ul><li><p>定义：设定为主键后数据库会<strong>自动建立索引</strong>，innodb为<strong>聚簇索引</strong></p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><br>    <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>    id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,<br>    customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>    customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <br>    <span class="hljs-keyword">PRIMARY</span> KEY(id) <span class="hljs-comment">--主键索引</span><br>);<br><br><span class="hljs-comment">--单独创建主键索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY customer(customer_no);<br><br><span class="hljs-comment">--删除主键索引</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> customer <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br><br><span class="hljs-comment">--修改建主键索引</span><br>必须先删除掉(<span class="hljs-keyword">drop</span>)原索引，再新建(<span class="hljs-keyword">add</span>)索引<br></code></pre></td></tr></table></figure></li></ul></li><li><p>复合索引</p><ul><li><p>定义：即一个索引包含多个列</p></li><li><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--和表一起创建</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer (<br>    id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED AUTO_INCREMENT,<br>    customer_no <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),<br>    customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>), <br>    <span class="hljs-keyword">PRIMARY</span> KEY(id), <br>    KEY (customer_name), <span class="hljs-comment">--单值索引</span><br>    <span class="hljs-keyword">UNIQUE</span> (customer_no), <span class="hljs-comment">--唯一索引</span><br>    KEY (customer_no,customer_name) <span class="hljs-comment">--复合索引</span><br>);<br><br><span class="hljs-comment">--单独创建复合索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_no_name <span class="hljs-keyword">ON</span> customer(customer_no,customer_name);<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><strong>聚簇索引</strong>也称为主索引，指的是索引和真实数据保存在一起 </p><p><strong>非聚簇索引</strong>也称为辅助索引，指的是索引结点保存的是主键信息 </p><p>如果利用非聚簇索引来查询数据执行流程是：非聚簇索引-&gt;取得主索引-&gt;数据 这一过程也称为<strong>回表查询</strong></p><p><strong>覆盖索引</strong>可以避免回表查询</p></blockquote></li></ul><h2 id="4、MySQL的索引"><a href="#4、MySQL的索引" class="headerlink" title="4、MySQL的索引"></a>4、MySQL的索引</h2><h3 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h3><p><img src="/mysql2.assets/20200815153029-1648978675101.png" alt="BTree"></p><p><img src="/mysql2.assets/20200815153043.png" alt="B+Tree"></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>B树的<strong>关键字和记录是放在一起的</strong>，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，<strong>记录只放在叶子节点中</strong></li><li>在 B树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录 的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看 B树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B树多，树高比 B树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到 一个记录所需的比较次数要比 B树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故</li></ul><p><strong>为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><ul><li>B+树的磁盘读写代价更低<ul><li>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了</li></ul></li><li>B+树的查询效率更加稳定<ul><li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li></ul></li></ul><h3 id="MySQL中的B-树"><a href="#MySQL中的B-树" class="headerlink" title="MySQL中的B+树"></a>MySQL中的B+树</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><img src="/mysql2.assets/20200822173605-1648978771857.png" alt="主键索引">]</p><p>MySQL在创建表时，会根据主键来创建主键索引（如果没有主键，会用一个隐藏值来作为主键）。主键索引所构建的B+树，表中所有的记录都存放在了树的最后一层。<strong>且与一般的B+树不同的是：叶子节点间的指针是双向的</strong></p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p><img src="/mysql2.assets/20200822185520-1648978781357.png" alt="复合索引"></p><p>创建复合索引时，会将作为<strong>复合索引字段的值</strong>进行排序并放在B+树的最后一层中，同时还会将其<strong>对应的主键值</strong>放在其后。如：</p><table><thead><tr><th>a（主键）</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>1</td><td>1</td><td>a</td></tr></tbody></table><p>其中字段a为主键，字段bcd共同作为复合索引，此时存放在最后一层的数据就是：111（复合索引） 2（主键索引）</p><p>根据这个特点，可以看出复合索引具有以下使用方法</p><ul><li><p>最佳左前缀：使用复合索引的顺序必须和创建的<strong>顺序一致</strong></p></li><li><p>覆盖索引的同时，可以带上主键字段，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a, b, c, d <span class="hljs-keyword">FROM</span> t_emp;<br></code></pre></td></tr></table></figure><p>因为<strong>主键字段和复合索引一起存放在了复合索引说产生的B+树的最后一层</strong>。如果需要a字段，无需进行全表扫描</p></li><li><p>如果进行范围查找，可能会进行全表扫描，这取决于处在范围内记录的多少</p><ul><li><p><strong>记录多</strong>，从复合索引映射到主键索引的次数过多，成本过高，<strong>会直接进行全表扫描</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175336.png"><img src="/mysql2.assets/20200822175336.png" alt="img"></a></p></li><li><p><strong>记录少</strong>，先<strong>使用复合索引</strong>，然后映射到全表中的对应记录上</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">80</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175403.png"><img src="/mysql2.assets/20200822175403.png" alt="img"></a></p></li><li><p>但是使用<strong>覆盖索引</strong>，无论记录多少，都会用到索引</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age, <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">1</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175611.png"><img src="/mysql2.assets/20200822175611.png" alt="img"></a></p></li></ul></li><li><p>不带WHERE也可以通过复合索引查找到主键+复合索引的记录</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> id, age, <span class="hljs-type">name</span>, deptId <span class="hljs-keyword">FROM</span> t_emp ;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822175746.png"><img src="/mysql2.assets/20200822175746.png" alt="img"></a></p></li></ul><h2 id="5、索引的使用场景"><a href="#5、索引的使用场景" class="headerlink" title="5、索引的使用场景"></a>5、索引的使用场景</h2><h3 id="适合索引的场景"><a href="#适合索引的场景" class="headerlink" title="适合索引的场景"></a>适合索引的场景</h3><ul><li>主键自动建立唯一索引</li><li>频繁作为<strong>查询条件</strong>的字段应该创建索引</li><li>查询中与其它表关联的字段，<strong>外键关系</strong>建立索引</li><li>单键&#x2F;组合索引的选择问题，<strong>组合索引性价比更高</strong></li><li>查询中<strong>排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中<strong>统计</strong>或者<strong>分组</strong>字段</li></ul><h3 id="不适合索引的场景"><a href="#不适合索引的场景" class="headerlink" title="不适合索引的场景"></a>不适合索引的场景</h3><ul><li>表<strong>记录太少</strong>（有无索引差别不大）</li><li>经常<strong>增删改</strong>的表或者字段</li><li>Where 条件里用不到的字段不创建索引</li><li><strong>过滤性不好</strong>的不适合建索引（重复性较高，比如国籍、性别之类的字段）</li></ul><h2 id="6、Hash索引"><a href="#6、Hash索引" class="headerlink" title="6、Hash索引"></a>6、Hash索引</h2><p>Hash索引只能用于对等比较，例如&#x3D;,&lt;&#x3D;&gt;（相当于&#x3D;）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。<br>但为什么我们使用BTree比使用Hash多呢？主要Hash本身由于其特殊性，也带来了很多限制和弊端：</p><ol><li>Hash索引仅仅能满足“&#x3D;”,“IN”,“&lt;&#x3D;&gt;”查询，<strong>不能使用范围查询</strong>。</li><li>联合索引中，Hash索引<strong>不能利用部分索</strong>引键查询。<br>对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持B+Tree支持的联合索引的最优左前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。</li><li>Hash索引无法避免数据的排序操作<br>由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。</li><li>Hash索引任何时候都不能避免表扫描<br>Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。</li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定会比B+Tree高<br>对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。</li></ol><h1 id="四、Explain-性能分析"><a href="#四、Explain-性能分析" class="headerlink" title="四、Explain 性能分析"></a>四、Explain 性能分析</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>使用 <strong>EXPLAIN</strong> 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。<strong>分析</strong>你的查询语句或是表结构的<strong>性能瓶颈</strong></p><h2 id="2、用法"><a href="#2、用法" class="headerlink" title="2、用法"></a>2、用法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- EXPLAIN + SQL语句 或 DESC + SQL语句，如</span><br><span class="hljs-keyword">desc</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> `index` <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>Explain 执行后返回的信息：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">desc</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> `index` <span class="hljs-operator">=</span> <span class="hljs-number">1</span>\G;<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span>            <span class="hljs-comment">-- 表示 SELECT 语句的编号，也就是在整个查询中 SELECT 的位置。</span><br>  select_type: SIMPLE    <span class="hljs-comment">--表示 SELECT 语句的类型</span><br>        <span class="hljs-keyword">table</span>: tb_user<span class="hljs-comment">-- 表示查询的表</span><br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: const     <span class="hljs-comment">-- 表示表的连接类型</span><br>possible_keys: <span class="hljs-keyword">PRIMARY</span><span class="hljs-comment">--表示查询中可以使用的索引</span><br>          key: <span class="hljs-keyword">PRIMARY</span><span class="hljs-comment">--表示实际查询中使用到的索引</span><br>      key_len: <span class="hljs-number">4</span>             <span class="hljs-comment">--表示索引字段的长度</span><br>          <span class="hljs-keyword">ref</span>: const<span class="hljs-comment">--表示使用哪个列或常数与索引一起来查询记录；</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><span class="hljs-comment">--表示查询的行数</span><br>     filtered: <span class="hljs-number">100.00</span><span class="hljs-comment">--表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询记录数量的比例</span><br>        Extra: <span class="hljs-keyword">NULL</span><span class="hljs-comment">--表示查询过程的附件信息</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h2 id="3、表头字段介绍"><a href="#3、表头字段介绍" class="headerlink" title="3、表头字段介绍"></a>3、表头字段介绍</h2><table><thead><tr><th align="left">Column</th><th align="left">JSON Name</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_id"><code>id</code></a></td><td align="left"><code>select_id</code></td><td align="left">The <code>SELECT</code> identifier</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type"><code>select_type</code></a></td><td align="left">None</td><td align="left">The <code>SELECT</code> type</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_table"><code>table</code></a></td><td align="left"><code>table_name</code></td><td align="left">The table for the output row</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_partitions"><code>partitions</code></a></td><td align="left"><code>partitions</code></td><td align="left">The matching partitions</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_type"><code>type</code></a></td><td align="left"><code>access_type</code></td><td align="left">The join type</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td><td align="left"><code>possible_keys</code></td><td align="left">The possible indexes to choose</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key"><code>key</code></a></td><td align="left"><code>key</code></td><td align="left">The index actually chosen</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key_len"><code>key_len</code></a></td><td align="left"><code>key_length</code></td><td align="left">The length of the chosen key</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_ref"><code>ref</code></a></td><td align="left"><code>ref</code></td><td align="left">The columns compared to the index</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows"><code>rows</code></a></td><td align="left"><code>rows</code></td><td align="left">Estimate of rows to be examined</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_filtered"><code>filtered</code></a></td><td align="left"><code>filtered</code></td><td align="left">Percentage of rows filtered by table condition</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra"><code>Extra</code></a></td><td align="left">None</td><td align="left">Additional information</td></tr></tbody></table><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t2(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t3(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (id));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t4(id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) AUTO_INCREMENT,content <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (id));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t1_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t2(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t2_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t3(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t3_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t4(content) <span class="hljs-keyword">VALUES</span>(CONCAT(<span class="hljs-string">&#x27;t4_&#x27;</span>,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">1000</span>)));<br></code></pre></td></tr></table></figure><h3 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a>id：表的读取顺序</h3><p>id是select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><ul><li><p><strong>id相同</strong>：执行顺序为 <strong>从上至下执行</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">EXPLAIN SELECT * FROM <span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t2</span>, <span class="hljs-built_in">t3</span> WHERE <span class="hljs-built_in">t1</span>.id = <span class="hljs-built_in">t2</span>.id <span class="hljs-keyword">AND </span><span class="hljs-built_in">t2</span>.id = <span class="hljs-built_in">t3</span>.id<span class="hljs-comment">;Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815173157.png"><img src="/mysql2.assets/20200815173157.png" alt="img"></a></p><p>查询时，表的加载<strong>顺序为t1, t2, t3</strong></p></li><li><p><strong>id不同</strong>：执行顺序为 <strong>id大的先执行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> t2.id <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">WHERE</span> t2.id <span class="hljs-operator">=</span> <br>(<span class="hljs-keyword">SELECT</span> t1.id <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> <br>(<span class="hljs-keyword">SELECT</span> t3.id <span class="hljs-keyword">FROM</span> t3)<br>);<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174216.png"><img src="/mysql2.assets/20200815174216.png" alt="img"></a></p><p>查询时，表的加载<strong>顺序为t3, t1, t2</strong></p></li><li><p><strong>id相同又不同</strong>： 执行顺序为</p><ul><li>id不同时，值较大的先执行</li><li>id相同时，从上至下执行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> t3.id <span class="hljs-keyword">FROM</span> t3) s1, t2 <span class="hljs-keyword">WHERE</span> s1.id <span class="hljs-operator">=</span> t2.id;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200815174740.png"><img src="/mysql2.assets/20200815174740.png" alt="img"></a></p><p>查询时，表的<strong>加载顺序为t3, t2, 虚表dervied2</strong></p><ul><li>其中dervied<strong>2</strong> 的 2，为 id &#x3D; 2</li></ul></li></ul><h3 id="select-type：查询操作类型"><a href="#select-type：查询操作类型" class="headerlink" title="select_type：查询操作类型"></a>select_type：查询操作类型</h3><p>select_type代表<strong>查询的类型</strong>，主要是用于区别<strong>普通查询、联合查询、子查询等</strong>的复杂查询</p><table><thead><tr><th>select_type 属性</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的 select 查询,查询中<strong>不包含子查询或者 UNION</strong></td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子部分，<strong>最外层</strong>查询则被标记为 Primary</td></tr><tr><td>DERIVED</td><td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里</td></tr><tr><td>SUBQUERY</td><td>在SELECT或WHERE列表中包含了<strong>子查询</strong></td></tr><tr><td>DEPEDENT SUBQUERY</td><td>在SELECT或WHERE列表中包含了子查询,<strong>子查询基于外层</strong></td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td><strong>无法使用缓存</strong>的子查询</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表<strong>获取结果</strong>的SELECT</td></tr></tbody></table><ul><li><p>SUBQUERY 和 DEPEDENT SUBQUERY</p></li><li><p>都是 WHERE 后面的条件，SUBQUERY 是单个值（&#x3D;），DEPEDENT SUBQUERY 是一组值（IN）</p></li><li><p>UNCACHEABLE SUBQUERY</p></li><li><p>当使用了**@@来引用系统变量**的时候，不会使用缓存</p></li><li><p>UNION 和 UNION RESULT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span>  t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp a <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span>  t_dept b <span class="hljs-keyword">ON</span> a.deptId <span class="hljs-operator">=</span> b.id <span class="hljs-keyword">WHERE</span> a.deptId <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816135453.png"><img src="/mysql2.assets/20200816135453.png" alt="img"></a></p></li></ul><h3 id="table：表的来源"><a href="#table：表的来源" class="headerlink" title="table：表的来源"></a>table：表的来源</h3><p>table表示这个数据是基于哪张表的</p><h3 id="type：访问类型"><a href="#type：访问类型" class="headerlink" title="type：访问类型"></a>type：访问类型</h3><p>type 是查询的访问类型。<strong>是较为重要的一个指标</strong>，结果值从最好到最坏依次是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">system</span> <span class="hljs-operator">&gt;</span> const <span class="hljs-operator">&gt;</span> eq_ref <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ref</span> <span class="hljs-operator">&gt;</span> fulltext <span class="hljs-operator">&gt;</span> ref_or_null <span class="hljs-operator">&gt;</span> index_merge <span class="hljs-operator">&gt;</span> unique_subquery <span class="hljs-operator">&gt;</span> index_subquery <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">&gt;</span> index <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span><br><br><span class="hljs-comment">--常见的顺序为</span><br><span class="hljs-keyword">system</span> <span class="hljs-operator">&gt;</span> const <span class="hljs-operator">&gt;</span> eq_ref <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ref</span> <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">&gt;</span> index <span class="hljs-operator">&gt;</span> allCopy<br></code></pre></td></tr></table></figure><p>一般来说，得保证查询<strong>至少达到 range 级别</strong>，最好能达到 ref</p><table><thead><tr><th>类型名</th><th>含义</th></tr></thead><tbody><tr><td>SYSTEM</td><td>表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也<strong>可以忽略不计</strong></td></tr><tr><td>CONST</td><td>表示<strong>通过索引一次就找到了</strong>,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</td></tr><tr><td>EQ_REF</td><td>唯一性索引扫描，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>。常见于主键或唯一索引扫描</td></tr><tr><td>REF</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行， 然而，它<strong>可能会找到多个符合条件的行</strong>，所以他应该属于查找和扫描的混合体</td></tr><tr><td>RANGE</td><td>只检索给定<strong>范围</strong>的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现 了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而 结束语另一点，不用扫描全部索引</td></tr><tr><td>INDEX</td><td>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组</td></tr><tr><td>ALL</td><td>Full Table Scan，将遍历全表以找到匹配的行</td></tr></tbody></table><ul><li><p>REF</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，且用到了&#x27; = &#x27;</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165420.png"><img src="/mysql2.assets/20200816165420.png" alt="img"></a></p></li><li><p>RANGE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，用到了 BETWEEN...AND... , IN , &gt; , &lt; 等范围查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816213631.png"><img src="/mysql2.assets/20200816213631.png" alt="img"></a></p></li><li><p>INDEX</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--其中deptId为索引，查找了整张表时，用到了索引</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> deptId <span class="hljs-keyword">FROM</span> t_emp;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165651.png"><img src="/mysql2.assets/20200816165651.png" alt="img"></a></p></li><li><p>ALL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--其中name为非索引</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> t_emp;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816165722.png"><img src="/mysql2.assets/20200816165722.png" alt="img"></a></p></li></ul><h3 id="possible-key：可能用到的索引"><a href="#possible-key：可能用到的索引" class="headerlink" title="possible_key：可能用到的索引"></a>possible_key：可能用到的索引</h3><p>显示<strong>可能</strong>应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但<strong>不一 定被查询实际使用</strong></p><h3 id="key：实际使用的索引"><a href="#key：实际使用的索引" class="headerlink" title="key：实际使用的索引"></a>key：实际使用的索引</h3><p><strong>实际使用的索引</strong>。如果为NULL，则没有使用索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816172950.png"><img src="/mysql2.assets/20200816172950.png" alt="img"></a></p><p>MySQL推测可能用到主键索引和idx_dept_id索引，实际上用到的是主键索引</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h4><p>当查找的字段与建立的索引的匹配（查询的字段都是索引，但不需要全是索引）时，会发生覆盖索引。MySQL推测使用的索引为NULL，而实际上会使用索引</p><p>有以下两种解释</p><ul><li>select的数据列<strong>只用从索引中就能够取得</strong>，不必从数据表中读取，换句话说<strong>查询列要被所使用的索引覆盖</strong></li><li>索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引</li></ul><p>注意：要使用覆盖索引，则<strong>只取出需要的列</strong>（被令为索引），<strong>不要</strong>使用 SELECT *</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--其中id和deptId都为索引</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> id, deptId <span class="hljs-keyword">FROM</span> t_emp;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173253.png"><img src="/mysql2.assets/20200816173253.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816173228.png"><img src="/mysql2.assets/20200816173228.png" alt="img"></a></p><h3 id="key-len：索引使用字节数"><a href="#key-len：索引使用字节数" class="headerlink" title="key_len：索引使用字节数"></a>key_len：索引使用字节数</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引</p><p><strong>ken_len 越长，说明索引使用的越充分</strong></p><h3 id="ref：显示被使用的索引的具体信息"><a href="#ref：显示被使用的索引的具体信息" class="headerlink" title="ref：显示被使用的索引的具体信息"></a>ref：显示被使用的索引的具体信息</h3><p>ref显示索引的哪一列被使用了，如果可能的话，可以是一个常数。哪些列或常量被用于查找索引列上的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId <span class="hljs-operator">=</span> t_dept.id;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816194305.png"><img src="/mysql2.assets/20200816194305.png" alt="img"></a></p><h3 id="rows：被查询的行数"><a href="#rows：被查询的行数" class="headerlink" title="rows：被查询的行数"></a>rows：被查询的行数</h3><p>rows 列显示 MySQL 认为它执行查询时必须检查的行数。<strong>越少越好！</strong></p><p><strong>验证</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--先删除索引</span><br><span class="hljs-keyword">DROP</span> INDEX idx_dept_id <span class="hljs-keyword">ON</span> t_emp;<br><br><span class="hljs-comment">--查找</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId <span class="hljs-operator">=</span> t_dept.id;<br><br><span class="hljs-comment">--再创建索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_dept_id <span class="hljs-keyword">ON</span> t_emp(deptId);<br><br><span class="hljs-comment">--查找</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept, t_emp <span class="hljs-keyword">WHERE</span> t_emp.deptId <span class="hljs-operator">=</span> t_dept.id;<br></code></pre></td></tr></table></figure><p><strong>结果如下</strong></p><ul><li><p>未使用索引时，一共需要查询26行</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195241.png"><img src="/mysql2.assets/20200816195241.png" alt="img"></a></p></li><li><p>使用索引后，一共需要查询6行</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816195401.png"><img src="/mysql2.assets/20200816195401.png" alt="img"></a></p></li></ul><h3 id="Extra：额外重要信息"><a href="#Extra：额外重要信息" class="headerlink" title="Extra：额外重要信息"></a>Extra：额外重要信息</h3><p>其他的额外<strong>重要</strong>的信息</p><ul><li><p><strong>Using filesort</strong>：使用外部索引排序（未使用用户创建的索引）</p><ul><li>说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引 完成的排序操作称为“文件排序”</li><li>出现 Using filesort <strong>说明SQL语句设计的不好</strong>，<strong>没有按照创建的索引进行排序</strong>，或者<strong>未按照索引指定的顺序进行排序</strong></li></ul><p><strong>演示</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--创建符合索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_emp_empno_age <span class="hljs-keyword">ON</span> t_emp(empno, age);<br><br><span class="hljs-comment">--进行查询操作，通过 age 字段进行排序（未按照复合索引顺序进行排序查询）</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br><br><span class="hljs-comment">--进行查询操作，通过 empno 或者 empno + age 字段进行排序（按照复合索引顺序进行排序查询）</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> empno;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno <span class="hljs-operator">&gt;</span><span class="hljs-number">100002</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> empno, age;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205145.png"><img src="/mysql2.assets/20200816205145.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205226.png"><img src="/mysql2.assets/20200816205226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816205112.png"><img src="/mysql2.assets/20200816205112.png" alt="img"></a></p></li><li><p><strong>Using temporary</strong></p><ul><li>使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。<strong>常见于排序 order by 和分组查询 group by</strong></li><li>出现 Using temporary <strong>说明SQL语句设计的非常不好</strong>，可能是因为没有按照顺序使用复合索引</li></ul><p><strong>演示</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--进行查询操作， 通过 age 字段进行分组（未按照复合索引顺序进行排序查询）</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_emp_empno_age <span class="hljs-keyword">ON</span> t_emp(empno, age);<br><br><span class="hljs-comment">----进行查询操作，通过 empno 或者 empno + age 字段进行分组（按照复合索引顺序进行排序查询）</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> empno;<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> empno &gt;<span class="hljs-number">100002</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> empno, age;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210843.png"><img src="/mysql2.assets/20200816210843.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816210908.png"><img src="/mysql2.assets/20200816210908.png" alt="img"></a></p></li></ul><p><strong>重要结论</strong></p><p>如果创建了<strong>复合索引</strong>，一定要<strong>按照复合索引的顺序来使用</strong>，否则会使得性能大幅下降</p><ul><li><p><strong>Using index</strong></p><ul><li>Using index 代表表示相应的 select 操作中使用了<strong>覆盖索引</strong>(Covering Index)，详见<a href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">key：实际用到的索引——覆盖索引</a>，避免访问了表的数据行，<strong>效率不错</strong>！</li><li>如果同时出现 using where，表明<strong>索引被用来执行索引键值的查找</strong></li><li>如果没有同时出现 using where，表明<strong>索引只是用来读取数据</strong>而非利用索引执行查找。</li></ul><p><strong>演示</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--查询 age 字段，使用了WHERE</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age &gt;<span class="hljs-number">100000</span>;<br><br><span class="hljs-comment">--查询 empno 和 age 字段，未使用WHERE</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno, age <span class="hljs-keyword">FROM</span> t_emp;<br><br><span class="hljs-comment">--查询 empno 和 name 字段 （name字段不是索引）</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> empno, <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> t_emp;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212055.png"><img src="/mysql2.assets/20200816212055.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212129.png"><img src="/mysql2.assets/20200816212129.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200816212243.png"><img src="/mysql2.assets/20200816212243.png" alt="img"></a></p></li><li><p>Using where</p><ul><li>表明使用了 where 过滤</li></ul></li><li><p>Using join buffer</p><ul><li>使用了连接缓存</li></ul></li><li><p>impossible where</p><ul><li>where 子句的值总是 false，不能用来获取任何元组</li></ul></li><li><p>select tables optimized away</p><ul><li>在没有 GROUP BY 子句的情况下，基于索引优化 MIN&#x2F;MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操 作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li></ul></li></ul><h1 id="五、查询优化"><a href="#五、查询优化" class="headerlink" title="五、查询优化"></a>五、查询优化</h1><h2 id="单表查询优化"><a href="#单表查询优化" class="headerlink" title="单表查询优化"></a>单表查询优化</h2><h2 id="1、全值匹配很快捷"><a href="#1、全值匹配很快捷" class="headerlink" title="1、全值匹配很快捷"></a>1、全值匹配很快捷</h2><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--建立符合索引（age, deptId, name）</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_emp_ade <span class="hljs-keyword">ON</span> t_emp(age, deptId, NAME);<br><br><span class="hljs-comment">--查找</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--和上一条SQL语句中WHERE后字段的顺序不同，但是不影响查询结果</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164200.png"><img src="/mysql2.assets/20200817164200.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="/mysql2.assets/20200817164226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164241.png"><img src="/mysql2.assets/20200817164241.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="/mysql2.assets/20200817164506.png" alt="img"></a></p><p>可以看到，<strong>复合索引都被用到了，并且SQL中查询字段的顺序，跟使用索引中字段的顺序，没有关系</strong>。优化器会在不影响 SQL 执行结果的前提下，自动地优化</p><p><strong>结论：全职匹配我最爱指的是，查询的字段按照顺序在索引中都可以匹配到</strong></p><h2 id="2、最佳左前缀法则"><a href="#2、最佳左前缀法则" class="headerlink" title="2、最佳左前缀法则"></a>2、最佳左前缀法则</h2><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--先删除之前创建的单值索引</span><br><span class="hljs-keyword">DROP</span> INDEX idx_dept_id <span class="hljs-keyword">ON</span> t_emp; <br><br><span class="hljs-comment">--查询，未按照最佳左前缀法则</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--查询，部分按照最佳左前缀法则（age字段和复合索引匹配，但name没有）</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span>  age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--查询，完全按照最佳左前缀法则</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164932.png"><img src="/mysql2.assets/20200817164932.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164948.png"><img src="/mysql2.assets/20200817164948.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817165100.png"><img src="/mysql2.assets/20200817165100.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164226.png"><img src="/mysql2.assets/20200817164226.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817164506.png"><img src="/mysql2.assets/20200817164506.png" alt="img"></a></p><p>可以看到，查询<strong>字段与索引字段顺序的不同会导致，索引无法充分使用，甚至索引失效</strong></p><p><strong>原因</strong>：使用复合索引，需要<strong>遵循最佳左前缀法则</strong>，即如果索引了多列，要遵守最左前缀法则。指的是查询从索引的<strong>最左前列开始并且不跳过索引中的列</strong></p><p><strong>结论：过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong></p><h2 id="3、索引列上不计算"><a href="#3、索引列上不计算" class="headerlink" title="3、索引列上不计算"></a>3、索引列上不计算</h2><p>不在索引列上做任何操作（计算、函数、(自动 or 手动)类型转换），<strong>可能会导致索引失效而转向全表扫描</strong></p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--直接查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--使用MySQL函数查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(age,<span class="hljs-number">2</span>) <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170139.png"><img src="/mysql2.assets/20200817170139.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817170522.png"><img src="/mysql2.assets/20200817170522.png" alt="img"></a></p><p>可以看出，当age字段使用了left函数以后，<strong>导致索引完全失效</strong></p><p><strong>结论：等号左边无计算</strong></p><h2 id="4、范围之后全失效"><a href="#4、范围之后全失效" class="headerlink" title="4、范围之后全失效"></a>4、范围之后全失效</h2><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--范围查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br><br><span class="hljs-comment">--未使用范围查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171833.png"><img src="/mysql2.assets/20200817171833.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817172159.png"><img src="/mysql2.assets/20200817172159.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817171903.png"><img src="/mysql2.assets/20200817171903.png" alt="img"></a></p><p>可以看出，当对age字段使用范围查询后，使得范围后面的索引失效了</p><p><strong>建议：</strong>将可能做范围查询的字段的索引顺序<strong>放在最后</strong></p><p><strong>结论：使用范围查询后，如果范围内的记录过多，会导致索引失效</strong>，因为从自定义索引映射到主键索引需要耗费太多的时间，反而不如全表扫描来得快</p><h2 id="5、覆盖索引多使用"><a href="#5、覆盖索引多使用" class="headerlink" title="5、覆盖索引多使用"></a>5、覆盖索引多使用</h2><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询所有字段</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">--查询索引字段</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t_dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173338.png"><img src="/mysql2.assets/20200817173338.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817173314.png"><img src="/mysql2.assets/20200817173314.png" alt="img"></a></p><p><strong>结论：使用覆盖索引（Using index）会提高检索效率</strong></p><h2 id="6、使用不等会失效"><a href="#6、使用不等会失效" class="headerlink" title="6、使用不等会失效"></a>6、使用不等会失效</h2><p>在使用<strong>不等于(!&#x3D; 或者&lt;&gt;)时</strong>，有时会无法使用索引会导致全表扫描</p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--SQL语句中有不等于</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">!=</span> <span class="hljs-number">90</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">90</span>;<br><br><span class="hljs-comment">--SQL语句中没有不等于</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180448.png"><img src="/mysql2.assets/20200817180448.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180505.png"><img src="/mysql2.assets/20200817180505.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817180521.png"><img src="/mysql2.assets/20200817180521.png" alt="img"></a></p><p><strong>结论：尽量不要使用不等于</strong></p><h2 id="7、使用NULL值要小心"><a href="#7、使用NULL值要小心" class="headerlink" title="7、使用NULL值要小心"></a>7、使用NULL值要小心</h2><p>在使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> 或者 <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><p>时，可能会导致索引失效</p><p>但是如果<strong>允许字段为空</strong>，则</p><ul><li>IS NULL 不会导致索引失效</li><li>IS NOT NULL 会导致索引失效</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181044.png"><img src="/mysql2.assets/20200817181044.png" alt="img"></a></p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181116.png"><img src="/mysql2.assets/20200817181116.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817181137.png"><img src="/mysql2.assets/20200817181137.png" alt="img"></a></p><h2 id="8、模糊查询加右边"><a href="#8、模糊查询加右边" class="headerlink" title="8、模糊查询加右边"></a>8、模糊查询加右边</h2><p>要使用模糊查询时，<strong>百分号最好加在右边，而且进行模糊查询的字段必须是单值索引</strong></p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--创建单值索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_emp_name <span class="hljs-keyword">ON</span> t_emp(NAME);<br><br><span class="hljs-comment">--进行模糊查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;风%&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="/mysql2.assets/20200817183416.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183401.png"><img src="/mysql2.assets/20200817183401.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183416.png"><img src="/mysql2.assets/20200817183416.png" alt="img"></a></p><p>可以看出，对索引使用模糊查询时，<strong>只有当百分号在右边，索引为单值索引且模糊查询语句在最右边时，索引才会生效</strong></p><p>其他情况均失效了</p><p><strong>但是</strong>有时必须使用其他类型的模糊查询，这时就需要用<strong>覆盖索引</strong>来解决索引失效的问题</p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;风%&#x27;</span>;<br><br>EXPLAIN <span class="hljs-keyword">SELECT</span> NAME <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="/mysql2.assets/20200817183741.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183801.png"><img src="/mysql2.assets/20200817183801.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817183741.png"><img src="/mysql2.assets/20200817183741.png" alt="img"></a></p><p><strong>结论：对索引进行模糊查询时，最好在右边加百分号。必须在左边或左右加百分号时，需要用到覆盖索引来提升查询效率</strong></p><h2 id="9、字符串加单引号"><a href="#9、字符串加单引号" class="headerlink" title="9、字符串加单引号"></a>9、字符串加单引号</h2><p>当字段为字符串时，查询时必须带上单引号。否则<strong>会发生自动的类型转换</strong>，从而发生全表扫描</p><p><strong>用于查询的表</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817203952.png"><img src="/mysql2.assets/20200817203952.png" alt="img"></a></p><p><strong>其中card_id字段为varchar类型，且设置了单值索引</strong></p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--使用了单引号</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> card_id <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">WHERE</span> card_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br><br><span class="hljs-comment">--未使用单引号，发生自动类型转换</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> card_id <span class="hljs-keyword">FROM</span> person <span class="hljs-keyword">WHERE</span> card_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204047.png"><img src="/mysql2.assets/20200817204047.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204027.png"><img src="/mysql2.assets/20200817204027.png" alt="img"></a></p><h2 id="10、尽量不用or查询"><a href="#10、尽量不用or查询" class="headerlink" title="10、尽量不用or查询"></a>10、尽量不用or查询</h2><p>如果使用or，可能导致索引失效。所以要减少or的使用，可以<strong>使用 union all 或者 union 来替代：</strong></p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--使用or进行查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">OR</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风清扬&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200817204307.png"><img src="/mysql2.assets/20200817204307.png" alt="img"></a></p><h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p><strong>全职匹配我最爱，最左前缀要遵守</strong></p><p><strong>带头大哥不能死，中间兄弟不能断</strong></p><p><strong>索引列上少计算，范围之后全失效</strong></p><p><strong>LIKE 百分写最右，覆盖索引不写</strong></p><p><strong>不等空值还有 OR，索引影响要注意</strong></p><p><strong>VARCHAR 引号不可丢，SQL 优化有诀窍</strong></p><h2 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h2><p><strong>建表语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `class` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `card` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `book` (<br>`bookid` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, `card` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY (`bookid`)<br>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> class(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> book(card) <span class="hljs-keyword">VALUES</span>(<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span> <span class="hljs-operator">+</span> (RAND() <span class="hljs-operator">*</span> <span class="hljs-number">20</span>)));<br></code></pre></td></tr></table></figure><h2 id="1、LEFT-JOIN优化"><a href="#1、LEFT-JOIN优化" class="headerlink" title="1、LEFT JOIN优化"></a>1、LEFT JOIN优化</h2><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--未建立索引时的左外连接查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<br><br><span class="hljs-comment">--左表（class）建立索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_class_card <span class="hljs-keyword">ON</span> class(card);<br><br><span class="hljs-comment">--再次执行查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<br><br><span class="hljs-comment">--去掉左表索引</span><br><span class="hljs-keyword">DROP</span> INDEX idx_class_card <span class="hljs-keyword">ON</span> class;<br><br><span class="hljs-comment">--右表建立索引</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_book_card <span class="hljs-keyword">ON</span> book(card);<br><br><span class="hljs-comment">--再次执行查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170458.png"><img src="/mysql2.assets/20200818170458.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170402.png"><img src="/mysql2.assets/20200818170402.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818170547.png"><img src="/mysql2.assets/20200818170547.png" alt="img"></a></p><p><strong>结论</strong></p><ul><li>在优化关联查询时，只有在<strong>被驱动表上建立索引才有效</strong></li><li>left join 时，左侧的为驱动表，<strong>右侧为被驱动表</strong></li></ul><h2 id="2、INNER-JOIN优化"><a href="#2、INNER-JOIN优化" class="headerlink" title="2、INNER JOIN优化"></a>2、INNER JOIN优化</h2><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询操作，目前索引在book表的card上，class表和book表的位置不会改变查询结果</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> class <span class="hljs-keyword">ON</span> book.card <span class="hljs-operator">=</span> class.card;<br><br><span class="hljs-comment">--删除book表中的几条记录</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> book <span class="hljs-keyword">WHERE</span> bookid<span class="hljs-operator">&lt;</span><span class="hljs-number">10</span>;<br><br><span class="hljs-comment">--再次查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<br><br><span class="hljs-comment">--删除book表card字段索引，给class表的card字段添加索引</span><br><span class="hljs-keyword">DROP</span> INDEX idx_book_card <span class="hljs-keyword">ON</span> book;<br><span class="hljs-keyword">CREATE</span> INDEX idx_class_card <span class="hljs-keyword">ON</span> class(card);<br><br><span class="hljs-comment">--再次查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> class <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> book <span class="hljs-keyword">ON</span> class.card <span class="hljs-operator">=</span> book.card;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171341.png"><img src="/mysql2.assets/20200818171341.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171538.png"><img src="/mysql2.assets/20200818171538.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200818171625.png"><img src="/mysql2.assets/20200818171625.png" alt="img"></a></p><p><strong>结论</strong>：inner join 时，<strong>mysql 会把小结果集的表选为驱动表</strong>（小表驱动大表）</p><p><strong>所以最好把索引建立在大表（数据较多的表）上</strong></p><h2 id="3、RIGHT-JOIN优化"><a href="#3、RIGHT-JOIN优化" class="headerlink" title="3、RIGHT JOIN优化"></a>3、RIGHT JOIN优化</h2><p>优化类型和LEFT JOIN类似，只不过<strong>被驱动表变成了左表</strong></p><h2 id="排序分组优化"><a href="#排序分组优化" class="headerlink" title="排序分组优化"></a>排序分组优化</h2><p>在查询中难免会对查询结果进行排序操作。进行排序操作时要<strong>避免出现 Using filesort</strong>，应使用索引给排序带来的方便</p><p><strong>索引信息</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819160428.png"><img src="/mysql2.assets/20200819160428.png" alt="img"></a></p><h2 id="1、ORDER-BY-优化"><a href="#1、ORDER-BY-优化" class="headerlink" title="1、ORDER BY 优化"></a>1、ORDER BY 优化</h2><p>以下查询都是在<strong>索引覆盖</strong>的条件下进行的</p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--不满足索引覆盖时进行排序查询</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> empno <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId;<br><br><span class="hljs-comment">--按照复合索引顺序进行排序</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age, deptId, name;<br><br><span class="hljs-comment">--不按照复合索引顺序进行排序（无 age 字段），发生Using filesort</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, name;<br><br><span class="hljs-comment">--不按照复合索引顺序进行排序（索引顺序打乱），发生Using filesort</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, name, age;<br><br><span class="hljs-comment">--排序时部分(age)升序，部分(deptId)降序，发生Using filesort</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>, deptId <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">--排序时都为降序</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>, deptId <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">--排序时，在前面的字段为常量时（非范围）</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, name;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> age, deptId <span class="hljs-keyword">FROM</span> t_emp  <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">AND</span> deptId<span class="hljs-operator">&gt;</span><span class="hljs-number">10000</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptId, name;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162506.png"><img src="/mysql2.assets/20200819162506.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="/mysql2.assets/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="/mysql2.assets/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162240.png"><img src="/mysql2.assets/20200819162240.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162314.png"><img src="/mysql2.assets/20200819162314.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200907210532.png"><img src="/mysql2.assets/20200907210532.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162429.png"><img src="/mysql2.assets/20200819162429.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819162901.png"><img src="/mysql2.assets/20200819162901.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164020.png"><img src="/mysql2.assets/20200819164020.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164317.png"><img src="/mysql2.assets/20200819164317.png" alt="img"></a></p><p><strong>结论</strong>：</p><p>要想在排序时使用索引，避免 Using filesort，首先需要发生<strong>索引覆盖</strong>，其次</p><ul><li>ORDER BY 后面字段的顺序要和复合索引的<strong>顺序完全一致</strong></li><li>ORDER BY 后面的索引必须按照顺序出现，<strong>排在后面的可以不出现</strong></li><li>要进行升序或者降序时，<strong>字段的排序顺序必须一致</strong>。不能一部分升序，一部分降序，可以都升序或者都降序</li><li>如果复合索引前面的<strong>字段作为常量</strong>出现在过滤条件中，<strong>排序字段可以为紧跟其后的字段</strong></li></ul><h3 id="MySQL的排序算法"><a href="#MySQL的排序算法" class="headerlink" title="MySQL的排序算法"></a>MySQL的排序算法</h3><p>当发生 Using filesort 时，MySQL会根据自己的算法对查询结果进行排序</p><ul><li>双路排序<ul><li>MySQL 4.1 之前是使用双路排序,字面意思就是<strong>两次扫描磁盘</strong>，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在 buffer 进行排序，再从磁盘取其他字段</li><li>简单来说，<strong>取一批数据，要对磁盘进行了两次扫描</strong>，众所周知，I\O 是很耗时的，所以在 mysql4.1 之后，出现了第二种改进的算法，就是单路排序</li></ul></li><li>单路排序<ul><li>从磁盘读取查询需要的所有列，按照 order by 列<strong>在 buffer 对它们进行排序</strong>，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO,但是它会使用更多的空间， 因为它把每一行都保存在内存中了</li><li><strong>存在的问题</strong>：在 sort_buffer 中，方法 B 比方法 A 要多占用很多空间，因为方法 B 是把所有字段都取出, 所以有可能<strong>取出的数据的总大小超出了 sort_buffer 的容量</strong>，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 tmp 文件，多 路合并），排完再取取 sort_buffer 容量大小，再排……从而多次 I&#x2F;O。也就是<strong>本来想省一次 I&#x2F;O 操作，反而导致了大量的 I&#x2F;O 操作，反而得不偿失</strong></li></ul></li><li>优化Using filesort<ul><li>增大 sort_butter_size 参数的设置<ul><li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对<strong>每个进程的 1M-8M 之间调整</strong></li></ul></li><li>增大 max_length_for_sort_data 参数的设置<ul><li>mysql 使用单路排序的前提是<strong>排序的字段大小要小于 max_length_for_sort_data</strong></li><li>提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大， 明显症状是高的磁盘 I&#x2F;O 活动和低的处理器使用率。（1024-8192 之间调整）</li></ul></li><li>减少 select 后面的查询的字段<ul><li>查询的字段减少了，缓冲里就能容纳更多的内容了，<strong>间接增大了sort_buffer_size</strong></li></ul></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200819164341.png"><img src="/mysql2.assets/20200819164341.png" alt="img"></a></p><h2 id="2、GROUP-BY-优化"><a href="#2、GROUP-BY-优化" class="headerlink" title="2、GROUP BY 优化"></a>2、GROUP BY 优化</h2><p>优化方式和 ORDER BY 类似，参考ORDER BY 的优化方式即可</p><h1 id="六、截取查询分析"><a href="#六、截取查询分析" class="headerlink" title="六、截取查询分析"></a>六、截取查询分析</h1><h2 id="1、慢日志查询"><a href="#1、慢日志查询" class="headerlink" title="1、慢日志查询"></a>1、慢日志查询</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，<strong>它用来记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中</li><li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句</li><li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能 收集超过5秒的sql，结合之前explain进行全面分析</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们<strong>手动</strong>来设置这个参数</p><p>如果不是调优需要的话，<strong>一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件</p><blockquote><p>查看查询日志一般有两种方法 使用 <strong>select @@系统变量;</strong>  或者  <strong>SHOW VARIABLES LIKE ‘%系统变量%’;</strong></p></blockquote><table><thead><tr><th>SQL 语句</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>SHOW VARIABLES LIKE ‘%slow_query_log%’</td><td>查看慢查询日志是否开启</td><td>默认情况下 slow_query_log 的值为 OFF</td></tr><tr><td>set global slow_query_log&#x3D;1</td><td>开启慢查询日志</td><td></td></tr><tr><td>SHOW VARIABLES LIKE ‘long_query_time%’</td><td>查看慢查询设定阈值</td><td>单位：秒</td></tr><tr><td>set long_query_time&#x3D;1</td><td>设定慢查询阈值</td><td>单位：秒</td></tr></tbody></table><p>运行查询时间长的 sql，<strong>可以打开慢查询日志查看</strong></p><h2 id="2、批量数据脚本"><a href="#2、批量数据脚本" class="headerlink" title="2、批量数据脚本"></a>2、批量数据脚本</h2><h3 id="建表语句-1"><a href="#建表语句-1" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--dept 部门表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `dept` (<br>    `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    `deptName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    ceo <span class="hljs-type">INT</span> <span class="hljs-keyword">NULL</span> ,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-comment">-- emp 员工表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `emp` (<br>    `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    `empno` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> ,<br>    `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `age` <span class="hljs-type">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `deptId` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>    #<span class="hljs-keyword">CONSTRAINT</span> `fk_dept_id` <span class="hljs-keyword">FOREIGN</span> KEY (`deptId`) <span class="hljs-keyword">REFERENCES</span> `t_dept` (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><p>在执行创建函数之前，首先请保证 log_bin_trust_function_creators 参数为 1，即 on 开启状态。 否则会报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询</span><br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;log_bin_trust_function_creators&#x27;</span>;<br><br><span class="hljs-comment">--设置</span><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> log_bin_trust_function_creators<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="编写随机函数"><a href="#编写随机函数" class="headerlink" title="编写随机函数"></a>编写随机函数</h3><h4 id="随机产生字符串"><a href="#随机产生字符串" class="headerlink" title="随机产生字符串"></a><strong>随机产生字符串</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--DELIMITER 是用于改变结束的标志的，一般以分号结尾，但这里改为了以 $$ 结尾</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_string(n <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>)<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> chars_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<br><span class="hljs-keyword">DECLARE</span> return_str <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>WHILE i <span class="hljs-operator">&lt;</span> n DO<br><span class="hljs-keyword">SET</span> return_str <span class="hljs-operator">=</span>CONCAT(return_str,<span class="hljs-built_in">SUBSTRING</span>(chars_str,<span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1</span><span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span><span class="hljs-number">52</span>),<span class="hljs-number">1</span>));<br><span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">RETURN</span> return_str;<br><span class="hljs-keyword">END</span> $$<br></code></pre></td></tr></table></figure><p>如果要<strong>删除函数</strong>，则执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> rand_string;<br></code></pre></td></tr></table></figure><h4 id="随机产生部门编号"><a href="#随机产生部门编号" class="headerlink" title="随机产生部门编号"></a>随机产生部门编号</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> rand_num (from_num <span class="hljs-type">INT</span> ,to_num <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-built_in">FLOOR</span>(from_num <span class="hljs-operator">+</span>RAND()<span class="hljs-operator">*</span>(to_num <span class="hljs-operator">-</span>from_num<span class="hljs-operator">+</span><span class="hljs-number">1</span>)) ;<br><span class="hljs-keyword">RETURN</span> i;<br><span class="hljs-keyword">END</span>$$<br></code></pre></td></tr></table></figure><p>如果要<strong>删除函数</strong>，则执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> rand_num;<br></code></pre></td></tr></table></figure><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><h4 id="创建往-emp-表中插入数据的存储过程"><a href="#创建往-emp-表中插入数据的存储过程" class="headerlink" title="创建往 emp 表中插入数据的存储过程"></a>创建往 emp 表中插入数据的存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp( <span class="hljs-keyword">START</span> <span class="hljs-type">INT</span> , max_num <span class="hljs-type">INT</span> )<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br>#<span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span><span class="hljs-number">0</span> 把 autocommit 设置成 <span class="hljs-number">0</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>REPEAT<br><span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (empno, NAME ,age ,deptid ) <span class="hljs-keyword">VALUES</span> ((<span class="hljs-keyword">START</span><span class="hljs-operator">+</span>i) ,rand_string(<span class="hljs-number">6</span>) , rand_num(<span class="hljs-number">30</span>,<span class="hljs-number">50</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>));<br>UNTIL i <span class="hljs-operator">=</span> max_num<br><span class="hljs-keyword">END</span> REPEAT;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">END</span>$$<br><br><span class="hljs-comment">--删除</span><br><span class="hljs-comment">-- DELIMITER ;</span><br><span class="hljs-comment">-- drop PROCEDURE insert_emp;</span><br></code></pre></td></tr></table></figure><h4 id="创建往-dept-表中插入数据的存储过程"><a href="#创建往-dept-表中插入数据的存储过程" class="headerlink" title="创建往 dept 表中插入数据的存储过程"></a>创建往 dept 表中插入数据的存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 dept 表添加随机数据</span><br>DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `insert_dept`( max_num <span class="hljs-type">INT</span> )<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>REPEAT<br><span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept ( deptname,address,ceo ) <span class="hljs-keyword">VALUES</span> (rand_string(<span class="hljs-number">8</span>),rand_string(<span class="hljs-number">10</span>),rand_num(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>));<br>UNTIL i <span class="hljs-operator">=</span> max_num<br><span class="hljs-keyword">END</span> REPEAT;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">END</span>$$<br><br><span class="hljs-comment">--删除</span><br><span class="hljs-comment">-- DELIMITER ;</span><br><span class="hljs-comment">-- drop PROCEDURE insert_dept;</span><br></code></pre></td></tr></table></figure><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><h4 id="添加数据到部门表"><a href="#添加数据到部门表" class="headerlink" title="添加数据到部门表"></a>添加数据到部门表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 dept 表添加 1 万条数据</span><br>DELIMITER ;<br><span class="hljs-keyword">CALL</span> insert_dept(<span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure><h4 id="添加数据到员工表"><a href="#添加数据到员工表" class="headerlink" title="添加数据到员工表"></a>添加数据到员工表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--执行存储过程，往 emp 表添加 50 万条数据</span><br>DELIMITER ;<br><span class="hljs-keyword">CALL</span> insert_emp(<span class="hljs-number">100000</span>,<span class="hljs-number">500000</span>);<br></code></pre></td></tr></table></figure><h3 id="批量删除某个表上的所有索引"><a href="#批量删除某个表上的所有索引" class="headerlink" title="批量删除某个表上的所有索引"></a>批量删除某个表上的所有索引</h3><h4 id="删除索引的存储过程"><a href="#删除索引的存储过程" class="headerlink" title="删除索引的存储过程"></a>删除索引的存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $$<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> `proc_drop_index`(dbname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>),tablename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>))<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> done <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">DECLARE</span> ct <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">DECLARE</span> _index <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">DECLARE</span> _cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> index_name <span class="hljs-keyword">FROM</span> information_schema.STATISTICS <span class="hljs-keyword">WHERE</span><br>table_schema<span class="hljs-operator">=</span>dbname <span class="hljs-keyword">AND</span> table_name<span class="hljs-operator">=</span>tablename <span class="hljs-keyword">AND</span> seq_in_index<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> index_name <span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;PRIMARY&#x27;</span> ;<br><span class="hljs-keyword">DECLARE</span> CONTINUE HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">set</span> done<span class="hljs-operator">=</span><span class="hljs-number">2</span> ;<br><span class="hljs-keyword">OPEN</span> _cur;<br><span class="hljs-keyword">FETCH</span> _cur <span class="hljs-keyword">INTO</span> _index;<br>WHILE _index<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;&#x27;</span> DO<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@str</span> <span class="hljs-operator">=</span> CONCAT(&quot;drop index &quot;,_index,&quot; on &quot;,tablename );<br><span class="hljs-keyword">PREPARE</span> sql_str <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@str</span> ;<br><span class="hljs-keyword">EXECUTE</span> sql_str;<br><span class="hljs-keyword">DEALLOCATE</span> <span class="hljs-keyword">PREPARE</span> sql_str;<br><span class="hljs-keyword">SET</span> _index<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">FETCH</span> _cur <span class="hljs-keyword">INTO</span> _index;<br><span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">CLOSE</span> _cur;<br><span class="hljs-keyword">END</span>$$<br></code></pre></td></tr></table></figure><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);<br></code></pre></td></tr></table></figure><h1 id="七、MySQL锁机制"><a href="#七、MySQL锁机制" class="headerlink" title="七、MySQL锁机制"></a>七、MySQL锁机制</h1><h2 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h2><p><strong>MylSAM引擎使用表锁，并且不支持事务</strong></p><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--展示表是否加锁</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> TABLES;<br><br><span class="hljs-comment">--加锁 read (读锁) write (写锁)</span><br>LOCK <span class="hljs-keyword">TABLE</span> table1 read(write), table2 read(write)...<br><br><span class="hljs-comment">--全部解锁</span><br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><ul><li>主机A给表加上<strong>表锁（读锁）</strong>以后<ul><li>主机A和其他主机都可以读取<strong>该表</strong>的信息</li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中所有表的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，<strong>会修改失败</strong></li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加锁并查询状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK <span class="hljs-keyword">TABLE</span> dept READ;<br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> TABLES;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820151441-1648979654474.png"></p></li></ul><p><strong>读取</strong></p><ul><li><p>两个客户端分别读取dept表的信息，都能读出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li><li><p>客户端A（加锁端）A<strong>读取其他表</strong>信息，<strong>读取失败</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820152614-1648979680658.png"></p></li><li><p>其他客户端读取度其他表信息，读取成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820152714.png"></p></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A对表中内容进行修改，<strong>修改失败</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820151654-1648979708173.png"></p></li><li><p>客户端B对表中内容进行修改，进入阻塞状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/mysql2.assets/20200820151737-1648979720572.png"></p><ul><li><p>从客户端A解锁后，客户端B修改成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">UNLOCK TABLES;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820151818.png" alt="img"></p></li></ul><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>主机A给表加上<strong>表锁（写锁）</strong>以后</p><ul><li>主机A可以读取该表信息，但<strong>其他主机读取时，会进入阻塞状态，知道读锁被释放</strong></li><li><strong>主机A不能读取库中其他表的信息</strong>，但其他主机可以读取库中<strong>除该表以外所有表</strong>的信息</li><li>如果要修改被锁表的信息<ul><li>主机A如果对表进行修改，修改成功</li><li>其他主机对表进行修改，<strong>会被阻塞，直到锁被释放</strong></li></ul></li></ul><p><strong>演示</strong></p><ul><li><p>给dept表加上写锁并查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOCK <span class="hljs-keyword">TABLE</span> dept WRITE;<br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> TABLES;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820153259-1648979752395.png"></p></li><li><p>客户端A查询该表内容，查询成功；读取其他表，读取失败</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> dept;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820153403-1648979754873.png"></p></li></ul><p><img src="/mysql2.assets/20200820153437-1648979767765.png"></p><ul><li>&#96;&#96;&#96;sql<br>SELECT * FROM dept;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">  <br>  ![img](mysql2.assets/<span class="hljs-number">20200820153517</span>-<span class="hljs-number">1648979783908</span>.png)<br><br>- 释放后，读取成功<br><br>  ```sql<br>  UNLOCK TABLES<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>修改</strong></p><ul><li><p>客户端A修改<strong>该表</strong>内容，修改成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> dept <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820153637.png"></p></li><li><p>客户端A修改<strong>其他表</strong>内容，修改失败</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="/mysql2.assets/20200820153710-1648979795325.png"></p></li><li><p>其他客户端修改<strong>该表</strong>内容，进入阻塞状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>读锁不会阻塞读，只会阻塞写。但是写锁会阻塞读和写。</strong></p><h2 id="2、行锁"><a href="#2、行锁" class="headerlink" title="2、行锁"></a>2、行锁</h2><p><strong>InnoDB使用行锁，并且支持事务</strong>，事务相关可参考 <a href="https://nyimac.gitee.io/2020/08/11/MySQL%E5%9F%BA%E7%A1%80/#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1"><strong>MySQL基础</strong></a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>如果两个客户端<strong>对同一条记录进行修改</strong></p><ul><li>客户端A修改后，未提交（未commit），此时客户端B修改，则会阻塞</li><li>客户端A修改后，提交后，客户端B再修改，则不会阻塞</li></ul><p>如果两个客户端分别<strong>对不同的记录进行修改</strong>，则不会被阻塞</p><p><strong>修改同一条记录</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--关闭自动提交</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">--客户端A、B查询id=2的记录</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端A进行修改操作（将年龄改为了80），但未提交</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">80</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端A进行查询</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端B进行查询</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端B进行修改（客户端A未提交）</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端A提交</span><br><span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-comment">--客户端B提交</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><strong>对应结果</strong></p><p>客户端A查询结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="/mysql2.assets/20200820163718.png" alt="img"></a></p><p>客户端B查询结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="/mysql2.assets/20200820163718.png" alt="img"></a></p><p>客户端A修改后A查询</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163847.png"><img src="/mysql2.assets/20200820163847.png" alt="img"></a></p><p>客户端A修改后B查询</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163718.png"><img src="/mysql2.assets/20200820163718.png" alt="img"></a></p><p>客户端A修改，未提交，此时B进行修改，<strong>被阻塞</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820163957.png"><img src="/mysql2.assets/20200820163957.png" alt="img"></a></p><p>客户端A提交后，B修改成功</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820164036.png"><img src="/mysql2.assets/20200820164036.png" alt="img"></a></p><p><strong>修改不同记录</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--客户端A对id=2的年龄进行修改</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">--客户端B对id=3的年龄进行修改</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">--客户端A，B分别提交</span><br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>因为InnoDB使用行锁，对于不同行的操作，不会出现阻塞现象</p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>索引失效，<strong>行锁变表锁</strong></p><p>当<strong>索引失效</strong>后，即使多个客户端操作的不是同一条记录，<strong>如果未提交，其他客户端也会进入阻塞状态</strong></p><p>所以要<strong>避免索引失效</strong></p><h2 id="3、间隙锁"><a href="#3、间隙锁" class="headerlink" title="3、间隙锁"></a>3、间隙锁</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>当我们用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁</p><p>对于键值<strong>在条件范围内但并不存在的记录</strong>，叫做<strong>“间隙(GAP)<strong>” ，</strong>InnoDB也会对这个“间隙”加锁</strong>，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询表记录，此处没有id=2的记录</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp;<br><br><span class="hljs-comment">--客户端A进行范围查询，但是范围内没有id=2的记录</span><br><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> deptId <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">--客户端B进行插入数据，插入一条id=2的记录</span><br><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">INSERT</span> t_emp <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;岳不群&#x27;</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100002</span>); <br><br><span class="hljs-comment">--客户端A提交</span><br><span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-comment">--客户端B提交</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170126.png"><img src="/mysql2.assets/20200820170126-1648979831256.png" alt="img"></a></p><p><strong>客户端B进入阻塞状态</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170617.png"><img src="/mysql2.assets/20200820170617.png" alt="img"></a></p><p>提交后，插入成功</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200820170654.png"><img src="/mysql2.assets/20200820170654-1648979863808.png" alt="img"></a></p><p><strong>结论</strong>：可以看到表中本来<strong>没有id&#x3D;2的记录</strong>，但是在客户端A进行<strong>范围修改</strong>时，客户端B对<strong>在范围内但不存在的数据进行插入时，客户端B进入了阻塞状态</strong></p><h3 id="锁住指定的一行"><a href="#锁住指定的一行" class="headerlink" title="锁住指定的一行"></a>锁住指定的一行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-comment">--锁住指定的一行，如果进行更新操作就是 ... FOR UPDATE，删除操作就是 ... FOR DELETE 以此类推</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br><br><span class="hljs-comment">--进行修改操作</span><br><span class="hljs-keyword">UPDATE</span> t_emp <span class="hljs-keyword">SET</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;风车车&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">--提交</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>如果当某一行被锁住后，其他客户端对改行进行操作，会被<strong>阻塞</strong></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Innodb存储引擎由于实现了<strong>行级锁定</strong>，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些， 但是在整体<strong>并发处理能力方面要远远优于MyISAM的表级锁定的</strong>。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们<strong>使用不当的时候</strong>，可能会让Innodb的整体性能表现不仅不能比MylSAM高，甚至可能会更差。</p><h1 id="八、无锁并发MVCC"><a href="#八、无锁并发MVCC" class="headerlink" title="八、无锁并发MVCC"></a>八、无锁并发MVCC</h1><blockquote><p>这部分也是一个重难点 结合这位Up主的MVCC介绍视频会很好理解<a href="https://www.bilibili.com/video/BV1f94y1Z7V7?spm_id_from=333.1007.top_right_bar_window_history.content.click">【mysql】mvcc介绍 通俗易懂_哔哩哔哩_bilibili</a></p></blockquote><p>全称 **Multi-Version Concurrency Control **，即 **多版本并发控制 **，主要是为了提高数据库的并发性能。</p><p><strong>当前读：</strong>它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作。</p><p>如下操作都是当前读：select lock in share mode (共享锁)、select for update (排他锁)、update (排他锁)、insert (排他锁)、delete (排他锁)、串行化事务隔离级别</p><p><strong>快照读：</strong>快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。</p><p>如下操作是快照读：不加锁的select操作（注：事务级别不是串行化）<br>快照读与mvcc的关系，MVCC是“维持一个数据的多个版本，使读写操作没有冲突”的一个抽象概念。</p><h3 id="数据库并发场景"><a href="#数据库并发场景" class="headerlink" title="数据库并发场景"></a>数据库并发场景</h3><p>读-读：不存在任何问题，也不需要并发控制</p><p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</p><p>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</p><h3 id="MVCC解决并发哪些问题？"><a href="#MVCC解决并发哪些问题？" class="headerlink" title="MVCC解决并发哪些问题？"></a>MVCC解决并发哪些问题？</h3><p>mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联，读操作只读取该事务开始前的数据库快照。</p><p>解决问题如下：</p><p>并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。</p><p>解决脏读、幻读、不可重复读等事务隔离问题，但<strong>不能解决</strong>上面的写-写 更新丢失问题。</p><p>因此有了下面提高并发性能的组合拳：</p><p>MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突</p><p>MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>它的实现原理主要是 <strong>版本链 <strong>，</strong>undo日志</strong> ，<strong>Read View</strong> 来实现的</p><p><strong>版本链</strong><br>我们数据库中的每行数据，除了我们肉眼看见的数据，还有几个隐藏字段，得开天眼才能看到。分别是 <strong>db_trx_id <strong>、</strong>db_roll_pointer <strong>、</strong>db_row_id</strong>。</p><p>db_trx_id：6byte，最近修改(修改&#x2F;插入)事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID。</p><p>db_roll_pointer（版本链关键）：7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p><p>db_row_id：6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。</p><p>实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了</p><p>db_row_id是数据库默认为该行记录生成的唯一隐式主键，db_trx_id是当前操作该记录的事务ID，而db_roll_pointer是一个回滚指针，用于配合undo日志，指向上一个旧版本。</p><p>每次对数据库记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：<br>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的<strong>事务id</strong>，这个信息很重要，在根据 <strong>ReadView</strong> 判断版本可见性的时候会用到。</p><p><strong>undo日志</strong><br>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log里。</p><p>当事务进行回滚时可以通过undo log 里的日志进行数据还原。</p><p>Undo log 的用途</p><p>保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p><p>用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p><p>undo log主要分为两种：</p><p><strong>insert undo log</strong></p><p>代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p><strong>update undo log</strong>（主要）</p><p>事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；</p><p>所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被<strong>purge线程</strong>统一清除</p><p><strong>Read View(读视图)</strong><br>事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照。</p><p>记录并维护系统当前活跃事务的ID(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被本事务看到的其他事务id列表。</p><p>Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View几个属性</p><p><strong>trx_ids</strong>: 当前系统活跃(未提交)事务版本号集合。</p><p><strong>low_limit_id</strong>: 创建当前read view 时“当前系统最大事务版本号+1”。</p><p><strong>up_limit_id</strong>: 创建当前read view 时“系统正处于活跃事务最小版本号”</p><p><strong>creator_trx_id</strong>: 创建当前read view的事务版本号；</p><p>Read View可见性判断条件<br>db_trx_id &lt; up_limit_id || db_trx_id &#x3D;&#x3D; creator_trx_id（显示）</p><p>如果数据事务ID小于read view中的最小活跃事务ID，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。</p><p>或者数据的事务ID等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。</p><p>db_trx_id &gt;&#x3D; low_limit_id（不显示）</p><p>如果数据事务ID大于read view 中的当前系统的最大事务ID，则说明该数据是在当前read view 创建之后才产生的，所以数据不显示。如果小于则进入下一个判断</p><p>db_trx_id是否在活跃事务（trx_ids）中</p><p>不存在：则说明read view产生的时候事务已经commit了，这种情况数据则可以显示。</p><p>已存在：则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的。</p><p>MVCC和事务隔离级别<br>上面所讲的Read View用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</p><p>RR、RC生成时机<br>RC隔离级别下，是每个快照读都会生成并获取最新的Read View；</p><p>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View，之后的查询就不会重复生成了，所以一个事务的查询结果每次都是一样的。</p><p>解决幻读问题<br>快照读：通过MVCC来进行控制的，不用加锁。按照MVCC中规定的“语法”进行增删改查等操作，以避免幻读。</p><p>当前读：通过next-key锁（行锁+gap锁）来解决问题的。</p><p>RC、RR级别下的InnoDB快照读区别<br>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</p><p>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</p><p>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</p><p>总结<br>从以上的描述中我们可以看出来，所谓的MVCC指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><h1 id="九、日志"><a href="#九、日志" class="headerlink" title="九、日志"></a>九、日志</h1><p><img src="/mysql2.assets/image-20220403180815953.png" alt="Server层四种日志"></p><h2 id="二进制日志-bin-log"><a href="#二进制日志-bin-log" class="headerlink" title="二进制日志 bin-log"></a>二进制日志 bin-log</h2><p>该日志文件会以二进制的形式记录数据库的各种操作，但不记录查询语句。</p><h2 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志 error-log"></a>错误日志 error-log</h2><p>该日志文件会记录 MySQL 服务器的启动、关闭和运行错误等信息。</p><h2 id="通用查询日志-general-log"><a href="#通用查询日志-general-log" class="headerlink" title="通用查询日志 general-log"></a>通用查询日志 general-log</h2><p>该日志记录 MySQL 服务器的启动和关闭信息、客户端的连接信息、更新、查询数据记录的 SQL 语句等。</p><h2 id="慢查询日志-slow-log"><a href="#慢查询日志-slow-log" class="headerlink" title="慢查询日志 slow-log"></a>慢查询日志 slow-log</h2><p>记录执行事件超过指定时间的操作，通过工具分析慢查询日志可以定位 MySQL 服务器性能瓶颈所在。</p><h2 id="回滚日志-undo-log-和-前滚日志-redo-log"><a href="#回滚日志-undo-log-和-前滚日志-redo-log" class="headerlink" title="回滚日志 undo-log 和 前滚日志 redo-log"></a>回滚日志 undo-log 和 前滚日志 redo-log</h2><p>redolog和undolog只存在于innodb中，myisam引擎并没有实现，这两个日志在innodb中统称为事务日志。但要注意的是，虽然undolog和redolog都能恢复数据，但undolog并不是redolog的逆向操作。undolog用于回滚，redolog用于前滚。</p><p>redolog是工作在<strong>物理层</strong>，它的作用主要是为了减少磁盘开销。因为磁盘操作是极为耗时的，因此，不可能每次对数据的更改都直接写入磁盘。redolog的作用就是缓存起来这些数据改动（缓存到磁盘），等缓存到达一定的数量后再统一写磁盘。</p><p>回滚日志主要的用途是多版本并发控制中的回滚，多个事务同时更新数据时会生成回滚日志：</p><h1 id="十、复制"><a href="#十、复制" class="headerlink" title="十、复制"></a>十、复制</h1><h2 id="1、主从复制"><a href="#1、主从复制" class="headerlink" title="1、主从复制"></a>1、主从复制</h2><p>主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改<strong>写入二进制日志</strong>（<strong>Binary log</strong>）中。</li><li><strong>I&#x2F;O 线程</strong> ：负责从主服务器上读取二进制日志，并<strong>写入从服务器的中继日志</strong>（Relay log）。</li><li><strong>SQL 线程</strong> ：负责<strong>读取中继日志</strong>，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133613.png"><img src="/mysql2.assets/20200822133613.png" alt="img"></a></p><h2 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h2><p><strong>主服务器处理写操作</strong>以及实时性要求比较高的读操作，而<strong>从服务器处理读操作</strong></p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度<strong>缓解了锁的争用</strong></li><li><strong>从服务器</strong>可以使用 <a href="https://nyimac.gitee.io/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/#%E5%BC%95%E6%93%8E%E5%B1%82">MyISAM</a>，提升查询性能以及节约系统开销</li><li>增加冗余，提高可用性</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200822133739.png"><img src="/mysql2.assets/20200822133739.png" alt="img"></a></p>]]></content>
    
    
    <categories>
      
      <category>db</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql基础</title>
    <link href="/2022/03/11/mysql1/"/>
    <url>/2022/03/11/mysql1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Mysql安装以及配置"><a href="#一、Mysql安装以及配置" class="headerlink" title="一、Mysql安装以及配置"></a>一、Mysql安装以及配置</h1><p>Linux：移步<a href="https://zhuanlan.zhihu.com/p/472517343">Linux (centos)安装Mysql8.0+ - 知乎 (zhihu.com)</a></p><p>Window：进入Oracle官网下载msi或者zip压缩包即可</p><p>推荐实验Docker安装，好用省事！</p><h1 id="二、Mysql基本操作语句"><a href="#二、Mysql基本操作语句" class="headerlink" title="二、Mysql基本操作语句"></a>二、Mysql基本操作语句</h1><p>移步：<a href="https://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.html</a></p><h1 id="三、Mysql函数和存储过程"><a href="#三、Mysql函数和存储过程" class="headerlink" title="三、Mysql函数和存储过程"></a>三、Mysql函数和存储过程</h1><p>MySQL的存储过程（stored procedure）和函数（stored function）统称为stored routines。它是事先经过编译并存储在数据库中的一段SQL语句的集合。</p><p><strong>存储过程（Stored Procedure）</strong>是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p><strong>函数（Stored Function）</strong>：是由一个或多个SQL语句组成的子程序，可用于封装代码以便重新使用。自定义函数诸多限制，有许多语句不能使用，许多功能不能实现。函数可以直接引用返回值，用表变量返回记录集。但是，用户定义函数不能用于执行一组修改全局数据库状态的操作。</p><h2 id="1、存储过程与函数的区别"><a href="#1、存储过程与函数的区别" class="headerlink" title="1、存储过程与函数的区别"></a>1、<strong>存储过程与函数的区别</strong></h2><p>本质上没区别。函数只能通过return语句返回单个值或者表对象。而存储过程不允许执行return，但是通过out参数返回多个值。 函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程不行。函数限制比较多，如不能用临时表，只能用表变量等，而存储过程的限制相对就比较少。</p><ol><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强</li><li>当对数据库进行复杂操作时(如对多个表进行Update、Insert、Query、Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。<a href="http://blog.csdn.net/xiaohutushen/article/details/1956429">存储过程可以从自己的存储过程内引用其它存储过程</a>，这可以简化一系列复杂语句</li><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面</li><li>存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度</li><li>存储过程可以接受参数、输出参数、返回单个或多个结果集以及返回值，可以向程序返回错误原因。但函数只能返回一个特定类型的值或者表对象</li><li>存储过程中的CRUD的操作会影响数据库状态，但函数却不能</li><li>函数只能是in类型，存储过程可以使用In\out\inout类型</li></ol><h2 id="2、函数定义与使用"><a href="#2、函数定义与使用" class="headerlink" title="2、函数定义与使用"></a>2、函数定义与使用</h2><h2 id="3、存储过程定于与使用"><a href="#3、存储过程定于与使用" class="headerlink" title="3、存储过程定于与使用"></a>3、存储过程定于与使用</h2><h1 id="四、约束"><a href="#四、约束" class="headerlink" title="四、约束"></a>四、约束</h1><h2 id="1、主键"><a href="#1、主键" class="headerlink" title="1、主键"></a>1、主键</h2><p>能够唯一确定表中的一条记录。我们通过给某个字段添加该约束，就可以使得该字段不重复且不为空。</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="2、联合主键"><a href="#2、联合主键" class="headerlink" title="2、联合主键"></a>2、联合主键</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user2 (<br>id <span class="hljs-type">INT</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(id, name)<br>);<br></code></pre></td></tr></table></figure><p>此处字段id和name一同作为主键，联合主键要求每个字段<strong>加起来不同即可</strong>（无需每个字段都不同）</p><p><strong>建表后添加主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id);<br></code></pre></td></tr></table></figure><p>或者通过<strong>修改字段</strong>的方式来添加主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 MODIFY id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure><p><strong>建表后删除主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ALERT <span class="hljs-keyword">TABLE</span> user2 <span class="hljs-keyword">DROP</span>  <span class="hljs-keyword">PRIMARY</span> KEY (id);<br></code></pre></td></tr></table></figure><h2 id="2、自增约束"><a href="#2、自增约束" class="headerlink" title="2、自增约束"></a>2、自增约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user3 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user3 (name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>插入成功，自动生成了id<br></code></pre></td></tr></table></figure><p>自增约束一般<strong>与主键搭配使用</strong></p><h2 id="3、唯一约束"><a href="#3、唯一约束" class="headerlink" title="3、唯一约束"></a>3、唯一约束</h2><p>约束修饰的字段不可以重复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT <span class="hljs-keyword">UNIQUE</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREAMENT,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br><span class="hljs-keyword">UNIQUE</span>(id, name)<br>);<br></code></pre></td></tr></table></figure><h2 id="4、非空约束"><a href="#4、非空约束" class="headerlink" title="4、非空约束"></a>4、非空约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>);<br></code></pre></td></tr></table></figure><h2 id="5、默认约束"><a href="#5、默认约束" class="headerlink" title="5、默认约束"></a>5、默认约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user4 (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">10</span>,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>);<br></code></pre></td></tr></table></figure><p>如果我们插入字段时没有传值，就会<strong>使用默认值</strong></p><h2 id="6、外键约束"><a href="#6、外键约束" class="headerlink" title="6、外键约束"></a>6、外键约束</h2><p>主表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> master(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><p>从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> pet(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>master_id <span class="hljs-type">int</span>,<br><span class="hljs-keyword">FOREIGN</span> KEY(master_id) <span class="hljs-keyword">REFERENCES</span> master(id)<br>);<br></code></pre></td></tr></table></figure><ul><li>主表中没有的数据，在副表中是不可以使用的</li><li>主表中的数据被副标引用时，是不可以删除的</li></ul><h1 id="五、数据库范式"><a href="#五、数据库范式" class="headerlink" title="五、数据库范式"></a>五、数据库范式</h1><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><p>通常使用到的有 <strong>1NF</strong>、<strong>2NF</strong>、<strong>3NF</strong>、<strong>BCNF</strong>，在实际开发中最为常见的设计范式用前三个：</p><h2 id="1、第一范式"><a href="#1、第一范式" class="headerlink" title="1、第一范式"></a>1、第一范式</h2><p><strong>字段还可以拆分的，就不满足第一范式</strong></p><p>比如地址如果写为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">地址：陕西省西安市长安区学府大街西北大学</span><br></code></pre></td></tr></table></figure><p>就是可以被拆分的</p><p>如果字段写为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">省份：陕西省</span><br><span class="hljs-string">城市：西安市</span><br><span class="hljs-string">区域：长安区</span><br><span class="hljs-string">街名：学府大街西北大学</span><br></code></pre></td></tr></table></figure><p>就是不可拆分的</p><p>建表如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCRAEMENT,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>province <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>city <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>area <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>street: <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><p>就是<strong>符合第一范式</strong>的，但<strong>并不是拆分的越详细越好</strong></p><h2 id="2、第二范式"><a href="#2、第二范式" class="headerlink" title="2、第二范式"></a>2、第二范式</h2><ul><li>满足第一范式的条件下，第二范式要求：<strong>除主键外的每一列，都必须完全依赖于主键</strong></li><li>如果出现不完全依赖，则只可能发生在<strong>联合主键</strong>的情况下</li></ul><p><strong>不满足第二范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<br>product_id <span class="hljs-type">INT</span>,<br>customer_id <span class="hljs-type">INT</span>,<br>product_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(product_id, customer_id)<br>);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>此处product_name只依赖于product_id，customer_name只依赖于customer_id</p><p><strong>满足第二范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>product_id <span class="hljs-type">INT</span>,<br>customer_id <span class="hljs-type">INT</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> product(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="3、第三范式"><a href="#3、第三范式" class="headerlink" title="3、第三范式"></a>3、第三范式</h2><ul><li>满足第二范式，除主键外的其他列之间不能有传递依赖关系</li></ul><p><strong>不满足第三范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>product_id <span class="hljs-type">INT</span>,<br>customer_id <span class="hljs-type">INT</span>,<br>customer_phone <span class="hljs-type">INT</span><br>);<br></code></pre></td></tr></table></figure><p>此处customer_phone又依赖于customer_id，存在传递依赖关系，不满足第三范式</p><p><strong>满足第三范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">order</span>(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>product_id <span class="hljs-type">INT</span>,<br>customer_id <span class="hljs-type">INT</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customer(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    phone <span class="hljs-type">INT</span><br>);<br></code></pre></td></tr></table></figure><h1 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h1><h2 id="1、事务的ACID"><a href="#1、事务的ACID" class="headerlink" title="1、事务的ACID"></a>1、事务的ACID</h2><p><strong>原子性(atomicity)</strong><br>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分操作，这就是事务的原子性。</p><p><strong>一致性 (consistency)</strong><br>数据库总是从一个一致性的状态转换到另外一个一致性的状态。例如在一个事务执行过程中,服务器突然断电，但因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中，而如果事务正常执行且成功提交，那么数据库就转换到了另外一个一致性状态。</p><p><strong>隔离性 (isolation)</strong><br>通常来谠，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><p><strong>持久性 (durability)</strong><br>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p><h2 id="2、隔离级别"><a href="#2、隔离级别" class="headerlink" title="2、隔离级别"></a>2、隔离级别</h2><p><strong>READ UNCOMMITTED（未提交读)</strong><br>在 READ UNCOMMITTED 级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这会导致脏读。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED 不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。</p><p><strong>READ COMMITTED（提交读）</strong><br>大多数数据库系统的默认隔离级别都是 READ COMMITTED （但 MySQL 不是）。READCOMMITTED 满足前面提到的隔离性的简单定义：一个事务开始时，只能 “看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别会出现不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。</p><p><strong>REPEATABLE READ（可重复读）</strong><br>REPEATABLE READ 解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。所谓幻读，指的是当某个事务 在读取某个范围内的记录时，另外一个事务又在该范围内插人了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB 和XtraDB 存储引擎通过多版本井发控制 (MVCC, Multiversion Concurrency Control)解决了幻读的问题。<strong>可重复读是 MySQL 的默认事务隔离级别</strong>。</p><p><strong>SERIALIZABLE（可串行化）</strong><br>SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE 会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有井发的情况下，才考虑采用该级别。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">脏读：事务<span class="hljs-selector-tag">A</span>在事务<span class="hljs-selector-tag">B</span>修改某个字段数据后，读取该字段值，随后事务发生回滚，此时<span class="hljs-selector-tag">A</span>读到的数据就是&quot;脏的&quot;<br>不可重复度：事务<span class="hljs-selector-tag">A</span>读取某个字段值后，事务<span class="hljs-selector-tag">B</span>修改该字段值，事务<span class="hljs-selector-tag">B</span>提交后，事务<span class="hljs-selector-tag">A</span>再次读取该字段值，两次读取的值不一致<br>幻读：事务<span class="hljs-selector-tag">A</span>读取某字段值后，会给该字段上锁(注意是行锁)，此时事务<span class="hljs-selector-tag">A</span>执行条件查询，查询到一条记录，随后删除，此时<span class="hljs-selector-tag">B</span>可以Insert一条与删除记录一样的记录，此时事务<span class="hljs-selector-tag">A</span>再次执行查询，又发现了一条记录<br></code></pre></td></tr></table></figure><table><thead><tr><th>隔离级别</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th></tr></thead><tbody><tr><td>读未提交</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>读已提交</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>可重复读</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>串行化</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table><p><strong>总结</strong>：不可重复读的和幻读很容易混淆，<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong></p><p>默认情况下，Mysql是自动提交的，也就是我们每次输入一条语句然后回车，这也执行了一个事务。</p><h2 id="3、事务操作"><a href="#3、事务操作" class="headerlink" title="3、事务操作"></a>3、事务操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">查看自动提交状态<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@autocommit</span>; <span class="hljs-comment">--带@@的变量为系统变量</span><br>关闭自动提交<br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><br>此时可以输入执行任意多条语句<br>执行<span class="hljs-keyword">ROLLBACK</span>回滚到上次提提交后状态<br>执行<span class="hljs-keyword">COMMIT</span>则提交此次事务<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">也可以手动开启一个事务<br><span class="hljs-keyword">BEGIN</span>; <span class="hljs-comment">-- 或者 START TRANSACTION;</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;老六&#x27;</span>, <span class="hljs-number">7</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> person <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;老七&#x27;</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">ROLLBACK</span>; <span class="hljs-comment">-- 回滚</span><br><span class="hljs-keyword">COMMIT</span>; <span class="hljs-comment">-- 提交</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>db</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/2022/03/10/redis/"/>
    <url>/2022/03/10/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="第一部分-常用命令"><a href="#第一部分-常用命令" class="headerlink" title="第一部分 常用命令"></a>第一部分 <strong>常用命令</strong></h1><h1 id="第二部分-数据结构与对象"><a href="#第二部分-数据结构与对象" class="headerlink" title="第二部分 数据结构与对象"></a>第二部分 <strong>数据结构与对象</strong></h1><h2 id="1、简单动态字符串SDS"><a href="#1、简单动态字符串SDS" class="headerlink" title="1、简单动态字符串SDS"></a>1、简单动态字符串SDS</h2><p><img src="/redis.assets/image-20220416231648172.png" alt="SDS"></p><ul><li>Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS作为字符串表示</li><li>常数复杂度获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串长度时所需要的内存分配次数 <strong>预分配</strong> <strong>惰性释放</strong></li><li>二进制安全</li><li>兼容C字符串函数</li></ul><blockquote><p>预分配：当修改后，sds的len小于1MB，则预分配len大小的空间，free&#x3D;len；如果修改后len大于1MB，则预分配1MB的空间，free &#x3D; 1MB。</p><p>惰性释放：减短字符串长度后，不会立即释放free空间，如何释放有系统判断。</p></blockquote><h2 id="2、链表LinkedList"><a href="#2、链表LinkedList" class="headerlink" title="2、链表LinkedList"></a>2、链表LinkedList</h2><p><img src="/redis.assets/image-20220416232731309.png" alt="链表"></p><ul><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，双端链表。</li><li>每个链表使用一个list结构表示，有表头，表尾节点指针，以及链表长度等信息。</li><li>指针类型，可以保存不同类型的值。</li></ul><h2 id="3、字典Dict"><a href="#3、字典Dict" class="headerlink" title="3、字典Dict"></a>3、字典Dict</h2><p><img src="/redis.assets/image-20220416233223699.png" alt="hash"></p><ul><li>Redis的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</li><li>哈希表使用链地址结构来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</li><li>对哈希表进行扩展或者收缩操作时，进行的是渐进式rehash。</li></ul><blockquote><p>负载因子：ht[0].used &#x2F; ht[0].size</p><p>扩容：服务器没有执行 <strong>BGSAVA</strong> 或者 <strong>BGREWRITEAOF</strong> 命令，并且哈希表的负载因子大于等于  <strong>1</strong>；服务器正在执行 <strong>BGSAVA</strong> 或者 <strong>BGREWRITEAOF</strong> 命令，并且负载因子大于等于 <strong>5</strong></p><p>收缩：负载因子小于 <strong>0.1</strong> 。</p></blockquote><h2 id="4、整数集合IntSet"><a href="#4、整数集合IntSet" class="headerlink" title="4、整数集合IntSet"></a>4、整数集合IntSet</h2><p><img src="/redis.assets/image-20220416235213740.png" alt="intset"></p><ul><li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变数组的类型。</li><li>升级操作为整数集合带来了操作上的灵活性，并且尽可能的节约了内存。</li><li>整数集合只支持升级操作，不支持降级操作。</li></ul><h2 id="5、跳跃表SkipList"><a href="#5、跳跃表SkipList" class="headerlink" title="5、跳跃表SkipList"></a>5、跳跃表SkipList</h2><p><img src="/redis.assets/image-20220416234344527.png" alt="skiplist"></p><ul><li>Redis的跳跃表实现由 <strong>zskiplist</strong> 和 <strong>zskiplistNode</strong> 两个结构组成，其中 <strong>zskiplist</strong> 用于保存跳跃表信息(表头节点，表尾节点，长度)，<strong>zskiplistNode</strong> 用于保存跳跃表节点(层，前向指针，分值和成员对象)。</li><li>跳跃表的层高是1-32之间的随机数。</li><li>可以有相同的分值，但是成员对象必须唯一。</li><li>按照分值从小到大排序，分值相同时，节点按照成员对象的大小进行排序。</li></ul><h2 id="6、压缩列表ZipList"><a href="#6、压缩列表ZipList" class="headerlink" title="6、压缩列表ZipList"></a>6、压缩列表ZipList</h2><p><img src="/redis.assets/image-20220416235901337.png" alt="ziplist"></p><p><img src="/redis.assets/image-20220416235942956.png" alt="entry"></p><ul><li>压缩列表是一种为了节约内存而开发的顺序型数据结构。</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，出现机率不高。</li></ul><h2 id="7、对象结构"><a href="#7、对象结构" class="headerlink" title="7、对象结构"></a>7、对象结构</h2><p><img src="/redis.assets/image-20220417000646880.png" alt="redisObject"></p><p>Redis对象的三个重要属性为 类型，编码和指针，其中基本类型有五种：</p><p><img src="/redis.assets/image-20220417000856148.png" alt="redisObject基本类型"></p><p><strong>redisObject</strong> 的底层数据结构，使用OBJECT ENCODING “xxx” 可以输出底层结构名称</p><p><img src="/redis.assets/image-20220417001100403.png" alt="redisObject 底层结构"></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>int编码：字符串对象保存的值是整数值并且整数值可以使用long类型来表示</p><p>embstr编码：字符串长度小于 44 字节，分配只需一次</p><p>raw编码：字符串长度大于 44 字节，需要两次分配，修改embstr编码类型字符串会转换为raw编码字符串。</p><h3 id="列表编码"><a href="#列表编码" class="headerlink" title="列表编码"></a>列表编码</h3><p>列表对象的编码可以是ziplist和linkedlist。</p><p>编码转换：列表对象元素字符串长度小于64 且 元素个数小于512使用ziplist，否则使用 linkedlist。</p><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist和hashtable。</p><p>编码转换：哈希对象元素字符串长度小于64 且 元素个数小于512使用 ziplist，否则使用 hashtable。</p><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是intset和hashtable。</p><p>编码转换：集合对象元素全部属于整数值且元素个数小于512使用 intset，否则使用 hashtable。</p><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合对象编码可以是ziplist或者skiplist，使用skiplist时还会使用hashtable结构，目的是O(1)时间查询分数值。</p><p><img src="/redis.assets/image-20220417005639902.png" alt="zset底层结构"></p><p>编码转换：有序集合保存的所有元素成员的长度都小于64字节，且元素少于128个。</p><ul><li>Redis数据库中的每个键值对的键和值都是一个对象</li><li>Redis共有字符串，列表，哈希，集合和有序集合五种基本类型的对象，每种类型的对象至少都有两种或者以上的编码方式，不同的编码方式可以在不同的使用场景上优化对象的使用效率。</li><li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个见的类型就是检查键的值对象的类型。</li><li>Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被引用时，该对象所占用的内存就会被自动释放。</li><li>Redis会共享0-9999的字符串对象。</li><li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</li></ul><hr><h1 id="第三部分-单机数据库"><a href="#第三部分-单机数据库" class="headerlink" title="第三部分 单机数据库"></a>第三部分 <strong>单机数据库</strong></h1><h2 id="1、数据库"><a href="#1、数据库" class="headerlink" title="1、数据库"></a>1、数据库</h2><h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><p><img src="/redis.assets/image-20220417010738210.png" alt="服务器数据库结构(默认大小为16)"></p><h4 id="键空间"><a href="#键空间" class="headerlink" title="键空间"></a>键空间</h4><p><img src="/redis.assets/image-20220417011505446.png" alt="数据库键空间(字典结构的简化形式)"></p><h4 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h4><p><img src="/redis.assets/image-20220417011214309.png" alt="过期时间"></p><blockquote><p>EXPIRE <key> <ttl> 单位为秒</p><p>PEXPIRE <key> <ttl> 单位为毫秒</p><p>EXPIREAT <key> <timestamp> 单位为秒时间戳</p><p>PEXPIREAT <key> <timestamp> 单位为毫秒时间戳</p><p>PERSIST 命令可以移除过期时间</p><p>TTL 返回剩余生存时间，单位为秒</p><p>PTTL 返回剩余生存时间，单位为毫秒</p></blockquote><h4 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h4><ul><li>定时删除：每个键设置定时器，时间到就删，优点是节约内存，缺点是CPU大</li><li>惰性删除：读取时根据时间挫判断，如果未过期就返回数据，否则删除数据，优点是节约CPU性能，缺点是内存压力大</li><li>定期删除：周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度</li><li>Redis服务器采用的是定期删除搭配惰性删除的方式</li></ul><h4 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h4><p>当新数据进入redis时，如果内存不足会使用逐出算法删除数据</p><p><img src="/redis.assets/20200608142953.png" alt="逐出算法"></p><h2 id="2、RDB"><a href="#2、RDB" class="headerlink" title="2、RDB"></a>2、RDB</h2><h2 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h2><h2 id="4、事件"><a href="#4、事件" class="headerlink" title="4、事件"></a>4、事件</h2><h2 id="5、客户端"><a href="#5、客户端" class="headerlink" title="5、客户端"></a>5、客户端</h2><h2 id="6、服务器"><a href="#6、服务器" class="headerlink" title="6、服务器"></a>6、服务器</h2><hr><h1 id="第四部分-多机数据库"><a href="#第四部分-多机数据库" class="headerlink" title="第四部分 多机数据库"></a>第四部分 <strong>多机数据库</strong></h1><h2 id="1、主从复制"><a href="#1、主从复制" class="headerlink" title="1、主从复制"></a>1、主从复制</h2><h2 id="2、哨兵"><a href="#2、哨兵" class="headerlink" title="2、哨兵"></a>2、哨兵</h2><h2 id="3、集群"><a href="#3、集群" class="headerlink" title="3、集群"></a>3、集群</h2><hr><h1 id="第五部分-功能模块"><a href="#第五部分-功能模块" class="headerlink" title="第五部分 功能模块"></a>第五部分 <strong>功能模块</strong></h1><h2 id="1、发布与订阅"><a href="#1、发布与订阅" class="headerlink" title="1、发布与订阅"></a>1、发布与订阅</h2><h3 id="①subscribe-channel-…"><a href="#①subscribe-channel-…" class="headerlink" title="①subscribe [channel …]"></a>①subscribe [channel …]</h3><h3 id="②unsubscribe-channel-…"><a href="#②unsubscribe-channel-…" class="headerlink" title="②unsubscribe [channel …]"></a>②unsubscribe [channel …]</h3><h3 id="③psubscribe-pattern"><a href="#③psubscribe-pattern" class="headerlink" title="③psubscribe [pattern]"></a>③psubscribe [pattern]</h3><h3 id="④punsubscribe-pattern"><a href="#④punsubscribe-pattern" class="headerlink" title="④punsubscribe [pattern]"></a>④punsubscribe [pattern]</h3><h3 id="⑤pubsub"><a href="#⑤pubsub" class="headerlink" title="⑤pubsub"></a>⑤pubsub</h3><h3 id="⑥publish"><a href="#⑥publish" class="headerlink" title="⑥publish"></a>⑥publish</h3><h2 id="2、事务"><a href="#2、事务" class="headerlink" title="2、事务"></a>2、事务</h2><h3 id="①muti"><a href="#①muti" class="headerlink" title="①muti"></a>①muti</h3><h3 id="②exec"><a href="#②exec" class="headerlink" title="②exec"></a>②exec</h3><h3 id="③watch"><a href="#③watch" class="headerlink" title="③watch"></a>③watch</h3><h2 id="3、Lua脚本"><a href="#3、Lua脚本" class="headerlink" title="3、Lua脚本"></a>3、Lua脚本</h2><h2 id="4、monitor监视器"><a href="#4、monitor监视器" class="headerlink" title="4、monitor监视器"></a>4、monitor监视器</h2><h2 id="5、sort-排序"><a href="#5、sort-排序" class="headerlink" title="5、sort 排序"></a>5、sort 排序</h2><h2 id="6、慢查询日志"><a href="#6、慢查询日志" class="headerlink" title="6、慢查询日志"></a>6、慢查询日志</h2><h2 id="7、二进制位数组"><a href="#7、二进制位数组" class="headerlink" title="7、二进制位数组"></a>7、二进制位数组</h2><h3 id="1、bitset"><a href="#1、bitset" class="headerlink" title="1、bitset"></a>1、bitset</h3><h3 id="2、bitget"><a href="#2、bitget" class="headerlink" title="2、bitget"></a>2、bitget</h3><h3 id="3、bitcount"><a href="#3、bitcount" class="headerlink" title="3、bitcount"></a>3、bitcount</h3><h3 id="4、bitop-and-or-not-xor"><a href="#4、bitop-and-or-not-xor" class="headerlink" title="4、bitop [and] [or] [not] [xor]"></a>4、bitop [and] [or] [not] [xor]</h3><hr><h1 id="第六部分-企业级解决方案"><a href="#第六部分-企业级解决方案" class="headerlink" title="第六部分 企业级解决方案"></a>第六部分 <strong>企业级解决方案</strong></h1><h2 id="1、缓存预热"><a href="#1、缓存预热" class="headerlink" title="1、缓存预热"></a>1、缓存预热</h2><h2 id="2、缓存血崩"><a href="#2、缓存血崩" class="headerlink" title="2、缓存血崩"></a>2、缓存血崩</h2><h2 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a>3、缓存击穿</h2><h2 id="4、缓存穿透"><a href="#4、缓存穿透" class="headerlink" title="4、缓存穿透"></a>4、缓存穿透</h2><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="第七部分-配置文件"><a href="#第七部分-配置文件" class="headerlink" title="第七部分 配置文件"></a>第七部分 <strong>配置文件</strong></h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">port 6379  <span class="hljs-comment"># 监听端口号，默认为6379，如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接。</span><br>daemonize <span class="hljs-built_in">yes</span> <span class="hljs-comment">#指定redis是否以守护线程的方式启动</span><br>databases 16 <span class="hljs-comment">#创建database的数量，默认为0库</span><br><br>save 900 1 <span class="hljs-comment">#刷新快照到硬盘中。必须满足下列三个要求之一才会触发，即900秒内至少有1个key发生变化。</span><br>save 300 10 <span class="hljs-comment">#在300秒内至少10个key发生变化。</span><br>save 60 10000 <span class="hljs-comment">#在60秒之内至少有10000个可以发生变化。</span><br><br>stop-writes-on-bgsave-error <span class="hljs-built_in">yes</span> <span class="hljs-comment">#后台存储错误并停止写入命令。</span><br>rdbcompression <span class="hljs-built_in">yes</span> <span class="hljs-comment">#使用LZF方式压缩rdb文件。如果你想节省一些CPU可设置成&#x27;no&#x27;</span><br>rdbchecksum <span class="hljs-built_in">yes</span> <span class="hljs-comment">#在存储、加载rdb文件时进行校验。</span><br>dbfilename dump.rdb <span class="hljs-comment">#设置rdb文件名。</span><br><span class="hljs-built_in">dir</span> ./ <span class="hljs-comment">#设置工作目录，rdb文件会自动存放在该目录。</span><br></code></pre></td></tr></table></figure><h2 id="主从服务配置"><a href="#主从服务配置" class="headerlink" title="主从服务配置"></a>主从服务配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">slaveof &lt;masterip&gt; &lt;masterport&gt; <span class="hljs-comment">#将本机设为某台机器的从服务器</span><br>masterauth &lt;master-password&gt; <span class="hljs-comment">#连接主服务器的密码</span><br>slave-serve-stale-data <span class="hljs-built_in">yes</span> <span class="hljs-comment"># 当主机和从机断开时或这正处于在复制过程中，是否让从服务器是应答请求</span><br>slave-read-only <span class="hljs-built_in">yes</span> <span class="hljs-comment">#设置从服务器为只读模式</span><br>repl-diskless-sync no  <span class="hljs-comment">#是否同时向多个从服务器节点同时发数据</span><br>repl-diskless-sync-delay 5 <span class="hljs-comment">#发送数据的延迟时间</span><br>repl-ping-slave-period 10 <span class="hljs-comment">#主节点默认每隔 10 秒对从节点发送 ping 命令</span><br>repl-timeout 60 <span class="hljs-comment">#主从服务器超时时间(超时认为断线了),要比period设置的时间大</span><br><br><span class="hljs-comment">#如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，</span><br><span class="hljs-comment">#优先值为0表示不能提升为master，一般在哨兵sentinel环境中使用。</span><br>slave-priority 100 <br><br><span class="hljs-comment">#在slave和master同步后，后续的同步是否设置成TCP_NODELAY，设置成no，则redis master会立即发送同步数据，没有延迟</span><br>repl-disable-tcp-nodelay no <br>min-slaves-to-write 3 <span class="hljs-comment">#主节点仅允许当能够通信的从节点数量大于等于此处的值时，才允许接受写操作；</span><br>min-slaves-max-lag 10 <span class="hljs-comment">#从节点延迟时长超出此处指定的时间时，主节点会拒绝写入操作；</span><br></code></pre></td></tr></table></figure><h2 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">maxclients 10000 <span class="hljs-comment">#最大连接数</span><br>maxmemory &lt;bytes&gt; <span class="hljs-comment">#最大使用内存</span><br>maxmemory-policy volatile-lru <span class="hljs-comment">#内存到极限后的处理策略</span><br><br><span class="hljs-comment">#内存处理策略，用于在超出内存限制时，删除一些key</span><br>volatile-lru <span class="hljs-comment"># LRU算法删除过期key</span><br>allkeys-lru <span class="hljs-comment"># LRU算法删除key(不区分过不过期)</span><br>volatile-random <span class="hljs-comment"># 随机删除过期key</span><br>allkeys-random <span class="hljs-comment"># 随机删除key(不区分过不过期)</span><br>volatile-ttl <span class="hljs-comment"># 删除快过期的key</span><br>noeviction <span class="hljs-comment"># 禁止删除key,这如果内存不足，会直接返回错误。默认配置</span><br><br><span class="hljs-comment">#用于提高LRU/TTL算法的精准度，在自动清理内存时，指定的数字越大，CPU消耗就越多，默认为5。</span><br>maxmemory-samples 5<br></code></pre></td></tr></table></figure><h2 id="AOF日志模式"><a href="#AOF日志模式" class="headerlink" title="AOF日志模式"></a>AOF日志模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly no <span class="hljs-comment">#是否启用日志模式</span><br>appendfsync no <span class="hljs-comment"># 有系统决定何时写,统一写,速度快</span><br>appendfsync always <span class="hljs-comment"># 系统不缓冲,一直写,但是慢,这种方式几乎不丢失数据</span><br>appendfsync everysec <span class="hljs-comment">#每秒写1次</span><br>no-appendfsync-on-rewrite no <span class="hljs-comment">#相当于将appendfsync设置为no，不存在磁盘操作，只是将数据写入了缓冲区，写入速度非常快</span><br>auto-AOF-rewrite-percentage 100 <span class="hljs-comment">#触发aof重写操作，要求本次文件大小比上次重写时要增加1（100%）倍</span><br>auto-AOF-rewrite-min-size 64mb <span class="hljs-comment">#触发aof重写操作，至少要达到的aof文件大小</span><br></code></pre></td></tr></table></figure><h2 id="慢查询配置"><a href="#慢查询配置" class="headerlink" title="慢查询配置"></a>慢查询配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">slowlog-log-slower-than 10000 <span class="hljs-comment">#记录响应时间大于10000微秒的慢查询</span><br>slowlog-max-len 128 <span class="hljs-comment"># 最多记录128条</span><br></code></pre></td></tr></table></figure><h1 id="第七部分-常见面试题"><a href="#第七部分-常见面试题" class="headerlink" title="第七部分 常见面试题"></a>第七部分 <strong>常见面试题</strong></h1><p><strong>1、redis集群中槽为什么是16384个</strong></p><p><strong>2、布隆过滤器</strong></p>]]></content>
    
    
    <categories>
      
      <category>db</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
